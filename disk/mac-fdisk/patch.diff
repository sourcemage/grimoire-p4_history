--- mac-fdisk-0.1.orig/dpme.h
+++ mac-fdisk-0.1/dpme.h
@@ -124,6 +124,7 @@
 };
 typedef struct dpme DPME;
 
+#define	dpme_automount_set(p, v)	bitfield_set(&p->dpme_flags, 30, 1, v) /* MSch */
 #define	dpme_os_specific_1_set(p, v)	bitfield_set(&p->dpme_flags, 8, 1, v)
 #define	dpme_os_specific_2_set(p, v)	bitfield_set(&p->dpme_flags, 7, 1, v)
 #define	dpme_os_pic_code_set(p, v)	bitfield_set(&p->dpme_flags, 6, 1, v)
@@ -134,6 +135,7 @@
 #define	dpme_allocated_set(p, v)	bitfield_set(&p->dpme_flags, 1, 1, v)
 #define	dpme_valid_set(p, v)		bitfield_set(&p->dpme_flags, 0, 1, v)
 
+#define	dpme_automount_get(p)		bitfield_get(p->dpme_flags, 30, 1)	/* MSch */
 #define	dpme_os_specific_1_get(p)	bitfield_get(p->dpme_flags, 8, 1)
 #define	dpme_os_specific_2_get(p)	bitfield_get(p->dpme_flags, 7, 1)
 #define	dpme_os_pic_code_get(p)		bitfield_get(p->dpme_flags, 6, 1)
--- mac-fdisk-0.1.orig/dump.c
+++ mac-fdisk-0.1/dump.c
@@ -3,7 +3,11 @@
 //
 // Written by Eryk Vershen (eryk@apple.com)
 //
-
+/*
+ * Linux/m68k version by Christiaan Welvaart
+ * minor fixes and glibc change by Michael Schmitz
+ */
+ 
 /*
  * Copyright 1996,1997 by Apple Computer, Inc.
  *              All Rights Reserved 
@@ -60,6 +64,7 @@
 //
 NAMES plist[] = {
     "Drvr", "Apple_Driver",
+    "Dr43", "Apple_Driver43",
     "Free", "Apple_Free",
     " HFS", "Apple_HFS",
     " MFS", "Apple_MFS",
@@ -83,7 +88,7 @@
 // Forward declarations
 //
 void dump_block_zero(partition_map_header *map);
-void dump_partition_entry(partition_map *entry, int digits);
+void dump_partition_entry(partition_map *entry, int digits, char *dev);
 
 
 //
@@ -119,6 +124,7 @@
     }
     printf("\nBlock size=%u, Number of Blocks=%u\n",
 	    p->sbBlkSize, p->sbBlkCount);
+#ifndef __mc68000__
     printf("DeviceType=0x%x, DeviceId=0x%x\n",
 	    p->sbDevType, p->sbDevId);
     if (p->sbDrvrCount > 0) {
@@ -130,6 +136,7 @@
 	}
     }
     printf("\n");
+#endif
 }
 
 
@@ -138,31 +145,50 @@
 {
     partition_map * entry;
     int j;
+    size_t len;
+    char *buf;
 
     if (map == NULL) {
 	bad_input("No partition map exists");
 	return;
     }
+#ifdef __mc68000__
+    printf("Disk %s\n", map->name);
+#else
     printf("%s\n", map->name);
+#endif
 
     j = number_of_digits(map->media_size);
     if (j < 7) {
 	j = 7;
     }
-    printf("   #:                 type name               "
-	    "%*s   %-*s ( size )\n", j, "length", j, "base");
+#ifdef __mc68000__
+    printf("%*s  type name         "
+	    "%*s   %-*s ( size )  system\n", strlen(map->name)+1, "#", j, "length", j, "base");
+#else
+    printf("%*s                    type name               "
+	    "%*s   %-*s ( size )  system\n", strlen(map->name)+1, "#", j, "length", j, "base");
+#endif
+
+    /* Grok devfs names. (courtesy Colin Walters)*/
+
+    len = strlen(map->name);
+    buf = strdup(map->name);
+    if (len >= 4 && !strcmp(buf+len-4, "disc")) {
+	strcpy(buf+len-4, "part");
+    }
 
     if (disk_order) {
 	for (entry = map->disk_order; entry != NULL;
 		entry = entry->next_on_disk) {
 
-	    dump_partition_entry(entry, j);
+	    dump_partition_entry(entry, j, buf);
 	}
     } else {
 	for (entry = map->base_order; entry != NULL;
 		entry = entry->next_by_base) {
 
-	    dump_partition_entry(entry, j);
+	    dump_partition_entry(entry, j, buf);
 	}
     }
     dump_block_zero(map);
@@ -170,18 +196,23 @@
 
 
 void
-dump_partition_entry(partition_map *entry, int digits)
+dump_partition_entry(partition_map *entry, int digits, char *dev)
 {
     partition_map_header *map;
     int j;
     DPME *p;
     BZB *bp;
     char *s;
+#ifdef __mc68000__
+    int aflag = 1;
+#else
     int aflag = 0;
+#endif
     int pflag = 1;
     u32 size;
     double bytes;
 
+
     map = entry->the_map;
     p = entry->data;
     if (aflag) {
@@ -192,9 +223,13 @@
 		break;
 	    }
 	}
-	printf("%4d: %.4s %-18.32s ", entry->disk_address, s, p->dpme_name);
+#ifdef __mc68000__
+	printf("%s%-2d %.4s %-12.12s ", dev, entry->disk_address, s, p->dpme_name);
+#else
+	printf("%s%-4d  %.4s %-18.32s ", dev, entry->disk_address, s, p->dpme_name);
+#endif
     } else {
-	printf("%4d: %20.32s %-18.32s ",
+	printf("%s%-4d %20.32s %-18.32s ", dev, 
 		entry->disk_address, p->dpme_type, p->dpme_name);
     }
 
@@ -217,7 +252,10 @@
 	printf("@~%-*u", digits, p->dpme_pblock_start + p->dpme_lblock_start);
     }
     
+    j = 's';
+
     bytes = size / ONE_KILOBYTE_IN_BLOCKS;
+    j = 'k';
     if (bytes >= 1024.0) {
 	bytes = bytes / 1024.0;
 	if (bytes < 1024.0) {
@@ -226,58 +264,45 @@
 	    bytes = bytes / 1024.0;
 	    j = 'G';
 	}
-	printf(" (%#5.1f%c)", bytes, j);
     }
+    printf(" (%#5.1f%c)  ", bytes, j);
 
-#if 0
-    // Old A/UX fields that no one pays attention to anymore.
-    bp = (BZB *) (p->dpme_bzb);
-    j = -1;
-    if (bp->bzb_magic == BZBMAGIC) {
-	switch (bp->bzb_type) {
-	case FSTEFS:
-	    s = "EFS";
-	    break;
-	case FSTSFS:
-	    s = "SFS";
-	    j = 1;
-	    break;
-	case FST:
-	default:
-	    if (bzb_root_get(bp) != 0) {
-		if (bzb_usr_get(bp) != 0) {
-		    s = "RUFS";
-		} else {
-		    s = "RFS";
-		}
-		j = 0;
-	    } else if (bzb_usr_get(bp) != 0) {
-		s = "UFS";
-		j = 2;
-	    } else {
-		s = "FS";
-	    }
-	    break;
-	}
-	if (bzb_slice_get(bp) != 0) {
-	    printf(" s%1d %4s", bzb_slice_get(bp)-1, s);
-	} else if (j >= 0) {
-	    printf(" S%1d %4s", j, s);
-	} else {
-	    printf("    %4s", s);
-	}
-	if (bzb_crit_get(bp) != 0) {
-	    printf(" K%1d", bp->bzb_cluster);
-	} else if (j < 0) {
-	    printf("   ");
-	} else {
-	    printf(" k%1d", bp->bzb_cluster);
-	}
-	if (bp->bzb_mount_point[0] != 0) {
-	    printf("  %.64s", bp->bzb_mount_point);
-	}
-    }
-#endif
+    if (!strcmp(p->dpme_type, "Apple_UNIX_SVR2"))
+    {
+         if (!strcmp(p->dpme_name, "Swap") || !strcmp(p->dpme_name, "swap"))
+            printf("Linux swap");
+         else
+            printf("Linux native");
+    }
+    else
+    if (!strcmp(p->dpme_type, "Apple_Bootstrap"))
+         printf("NewWorld bootblock");
+    else
+    if (!strcmp(p->dpme_type, "Apple_Scratch"))
+         printf("Linux swap");  //not just linux, but who cares
+    else
+    if (!strcmp(p->dpme_type, "Apple_HFS"))
+         printf("HFS");
+    else
+    if (!strcmp(p->dpme_type, "Apple_MFS"))
+        printf("MFS");
+    else
+    if (!strcmp(p->dpme_type, "Apple_Driver"))
+        printf("Driver");
+    else
+    if (!strcmp(p->dpme_type, "Apple_Driver43"))
+        printf("Driver 4.3");
+    else
+    if (!strcmp(p->dpme_type, "Apple_partition_map"))
+        printf("Partition map");
+    else
+    if (!strcmp(p->dpme_type, "Apple_PRODOS"))
+        printf("ProDOS");
+    else
+    if (!strcmp(p->dpme_type, "Apple_Free"))
+        printf("Free space");
+    else
+        printf("Unknown");
     printf("\n");
 }
 
@@ -316,6 +341,24 @@
 
 	dump(name);
     }
+#ifdef __linux__
+    for (i = 0; i < 4; i++) {
+	sprintf(name, "/dev/hd%c", 'a'+i);
+	if ((fd = open_device(name, O_RDONLY)) < 0) {
+	    if (errno == EACCES) {
+		error(errno, "can't open file '%s'", name);
+	    }
+	    continue;
+	}
+	if (read_block(fd, 1, (char *)data, 1) == 0) {
+	    close_device(fd);
+	    continue;
+	}
+	close_device(fd);
+
+	dump(name);
+    }
+#endif
     free(data);
 }
 
@@ -385,7 +428,7 @@
 	printf("%2d: %20.32s ",
 		entry->disk_address, p->dpme_type);
 	printf("%7u @ %-7u ", p->dpme_pblocks, p->dpme_pblock_start);
-	printf("%c%c%c%c%c%c%c%c%c ",
+	printf("%c%c%c%c%c%c%c%c%c%c ",
 		(dpme_valid_get(p))?'V':'v',
 		(dpme_allocated_get(p))?'A':'a',
 		(dpme_in_use_get(p))?'I':'i',
@@ -394,7 +437,8 @@
 		(dpme_writable_get(p))?'W':'w',
 		(dpme_os_pic_code_get(p))?'P':'p',
 		(dpme_os_specific_1_get(p))?'1':'.',
-		(dpme_os_specific_2_get(p))?'2':'.');
+		(dpme_os_specific_2_get(p))?'2':'.',
+		(dpme_automount_get(p))?'M':'m');
 	if (p->dpme_lblock_start != 0 || p->dpme_pblocks != p->dpme_lblocks) {
 	    printf("(%u @ %u)", p->dpme_lblocks, p->dpme_lblock_start);
 	}
--- mac-fdisk-0.1.orig/io.c
+++ mac-fdisk-0.1/io.c
@@ -30,6 +30,10 @@
 #include <stdlib.h>
 #include <fcntl.h>
 #include <SCSI.h>
+#else
+#ifdef __GLIBC__
+#include <sys/types.h>
+#endif
 #endif
 #include <unistd.h>
 #include <string.h>
@@ -51,6 +55,8 @@
 #define SCSI_FD 8
 #define loff_t long
 #define llseek lseek
+#else
+#define llseek lseek64
 #endif
 
 
@@ -435,8 +441,8 @@
 #else
     {
 #endif
-	x = num * PBLOCK_SIZE;
-	if ((x = llseek(fd, x, 0)) < 0) {
+	x = ((long long) num * PBLOCK_SIZE); /* cast to ll to work around compiler bug */
+	if ((x = lseek64(fd, x, 0)) < 0) {
 	    if (quiet == 0) {
 		error(errno, "Can't seek on file");
 	    }
--- mac-fdisk-0.1.orig/partition_map.c
+++ mac-fdisk-0.1/partition_map.c
@@ -30,7 +30,6 @@
 #include <stdlib.h>
 #include <unistd.h>
 #endif
-#include <string.h>
 #include <errno.h>
 
 #include <fcntl.h>
@@ -65,6 +64,8 @@
 const char * kFreeType	= "Apple_Free";
 const char * kMapType	= "Apple_partition_map";
 const char * kUnixType	= "Apple_UNIX_SVR2";
+const char * kBootstrapType = "Apple_Bootstrap";
+const char * kBootstrapName = "bootstrap";
 
 const char * kFreeName = "Extra";
 
@@ -288,15 +289,17 @@
 	    free(block);
 	}
     }
-    printf("The partition table has been altered!\n\n");
+    printf("The partition map has been saved successfully!\n\n");
 
 #ifdef __linux__
     if (map->regular_file) {
 	close_device(map->fd);
     } else {
-	// printf("Calling ioctl() to re-read partition table.\n"
-	//       "(Reboot to ensure the partition table has been updated.)\n");
-	sync();
+	// printf("Calling ioctl() to re-read partition table.\n");
+	if ((i = ioctl(fd, BLKFLSBUF)) != 0) {
+	    perror("ioctl(BLKFLSBUF)");
+	    sync();
+	}
 	sleep(2);
 	if ((i = ioctl(fd, BLKRRPART)) != 0) {
 	    saved_errno = errno;
@@ -304,20 +307,26 @@
 	    // some kernel versions (1.2.x) seem to have trouble
 	    // rereading the partition table, but if asked to do it
 	    // twice, the second time works. - biro@yggdrasil.com */
-	    sync();
+	    // printf("Again calling ioctl() to re-read partition table.\n");
+	    if ((i = ioctl(fd, BLKFLSBUF)) != 0) {
+	    	perror("ioctl(BLKFLSBUF)");
+		sync();
+	    }
 	    sleep(2);
 	    if ((i = ioctl(fd, BLKRRPART)) != 0) {
 		saved_errno = errno;
 	    }
 	}
+	printf("Syncing disks.\n");
+	if ((i = ioctl(fd, BLKFLSBUF)) != 0) {
+	    perror("ioctl(BLKFLSBUF)");
+	    sync();
+	}
 	close_device(map->fd);
-
-	// printf("Syncing disks.\n");
-	sync();
 	sleep(4);		/* for sync() */
 
 	if (i < 0) {
-	    error(saved_errno, "Re-read of partition table failed");
+	    error(saved_errno, "Re-read of partition map failed");
 	    printf("Reboot your system to ensure the "
 		    "partition table is updated.\n");
 	}
@@ -692,9 +701,9 @@
 		geometry.heads*geometry.sectors*geometry.cylinders);
     }
 
-    if ((pos = llseek(fd, 0, SEEK_END)) < 0) {
+    if ((pos = lseek64(fd, 0, SEEK_END)) < 0) {
 	printf("llseek to end of device failed\n");
-    } else if ((pos = llseek(fd, 0, SEEK_CUR)) < 0) {
+    } else if ((pos = lseek64(fd, 0, SEEK_CUR)) < 0) {
 	printf("llseek to end of device failed on second try\n");
     } else {
 	printf("llseek: pos = %d, blocks=%d\n", pos, pos/PBLOCK_SIZE);
@@ -895,6 +904,7 @@
 	printf("No such partition\n");
     } else {
 	remove_from_disk_order(cur);
+	if (old_index < index) index++; /* renumber_disk_addresses(map); */
 	cur->disk_address = index;
 	insert_in_disk_order(cur);
 	renumber_disk_addresses(map);
--- mac-fdisk-0.1.orig/partition_map.h
+++ mac-fdisk-0.1/partition_map.h
@@ -69,6 +69,8 @@
 extern const char * kFreeType;
 extern const char * kMapType;
 extern const char * kUnixType;
+extern const char * kBootstrapType;
+extern const char * kBootstrapName;
 
 extern const char * kFreeName;
 
--- mac-fdisk-0.1.orig/pdisk.c
+++ mac-fdisk-0.1/pdisk.c
@@ -30,12 +30,12 @@
 #include <stdio.h>
 #ifdef __linux__
 #include <getopt.h>
+#include <stddef.h>
 #else
 #include <stdlib.h>
 #include <unistd.h>
 #include <SIOUX.h>
 #endif
-#include <string.h>
 #include <errno.h>
 
 #ifdef __linux__
@@ -94,6 +94,7 @@
 void do_add_intel_partition(partition_map_header *map);
 void do_change_map_size(partition_map_header *map);
 void do_create_partition(partition_map_header *map, int get_type);
+void do_create_bootstrap_partition(partition_map_header *map);
 void do_delete_partition(partition_map_header *map);
 int do_expert(partition_map_header *map);
 void do_reorder(partition_map_header *map);
@@ -114,6 +115,7 @@
 main(int argc, char **argv)
 {
     int name_index;
+    int err=0;
 
     if (sizeof(DPME) != PBLOCK_SIZE) {
 	fatal(-1, "Size of partion map entry (%d) "
@@ -150,7 +152,9 @@
     } else if (!vflag) {
 	usage("no device argument");
  	do_help();
+	err=-EINVAL;	// debatable
     }
+    exit(err);
 }
 #else
 main()
@@ -351,7 +355,8 @@
 	    printf("  P    (print ordered by base address)\n");
 	    printf("  i    initialize partition map\n");
 	    printf("  s    change size of partition map\n");
-	    printf("  c    create new partition\n");
+	    printf("  b    create new 800K bootstrap partition\n");
+	    printf("  c    create new Linux partition\n");
 	    printf("  C    (create with type also specified)\n");
 	    printf("  d    delete a partition\n");
 	    printf("  r    reorder partition entry in map\n");
@@ -378,6 +383,10 @@
 	case 'i':
 	    map = init_partition_map(name, map);
 	    break;
+	case 'B':
+	case 'b':
+	    do_create_bootstrap_partition(map);
+	    break;
 	case 'C':
 	    get_type = 1;
 	    // fall through
@@ -471,6 +480,30 @@
 }
 
 
+void
+do_create_bootstrap_partition(partition_map_header *map)
+{
+    long base;
+
+    if (map == NULL) {
+	bad_input("No partition map exists");
+	return;
+    }
+ 
+    if (!rflag && map->writeable == 0) {
+	printf("The map is not writeable.\n");
+    }
+
+    // XXX add help feature (i.e. '?' in any argument routine prints help string)
+    if (get_base_argument(&base, map) == 0) {
+	return;
+    }
+
+    // create 800K type Apple_Bootstrap partition named `bootstrap'
+    add_partition_to_map(kBootstrapName, kBootstrapType, base, 1600, map);
+}
+
+
 int
 get_base_argument(long *number, partition_map_header *map)
 {
@@ -508,7 +541,7 @@
     int result = 0;
     long multiple;
 
-    if (get_number_argument("Length in blocks: ", number, kDefault) == 0) {
+    if (get_number_argument("Length (in blocks, kB (k), MB (M) or GB (G)): ", number, kDefault) == 0) {
 	bad_input("Bad length");
     } else {
 	result = 1;
@@ -605,13 +638,22 @@
 	bad_input("The map is not writeable.");
 	return;
     }
-    printf("Writing the map destroys what was there before. ");
-    if (get_okay("Is that okay? [n/y]: ", 0) != 1) {
+//    printf("Writing the map destroys what was there before. ");
+    printf("IMPORTANT: You are about to write a changed partition map to disk. \n");
+    printf("For any partition you changed the start or size of, writing out \n");
+    printf("the map causes all data on that partition to be LOST FOREVER. \n");
+    printf("Make sure you have a backup of any data on such partitions you \n");
+    printf("want to keep before answering 'yes' to the question below! \n\n");
+    if (get_okay("Write partition map? [n/y]: ", 0) != 1) {
 	return;
     }
 
     write_partition_map(map);
 
+    printf("\nPartition map written to disk. If any partitions on this disk \n");
+    printf("were still in use by the system (see messages above), you will need \n");
+    printf("to reboot in order to utilize the new partition map.\n\n");
+
     // exit(0);
 }
 
--- mac-fdisk-0.1.orig/fdisk.c
+++ mac-fdisk-0.1/fdisk.c
@@ -62,7 +62,6 @@
 #include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
-#include <string.h>
 #include <fcntl.h>
 #include <ctype.h>
 #include <setjmp.h>
@@ -71,6 +70,10 @@
 
 #include <sys/ioctl.h>
 
+#include <linux/types.h>
+
+typedef unsigned short kdev_t;	/* BAD hack; kdev_t is not exported */
+
 #include <linux/genhd.h>
 #include <linux/hdreg.h>
 #include <linux/fs.h>
@@ -428,7 +431,7 @@
 		offsets[partitions] = extended_offset + SWAP32(p->start_sect);
 		if (!extended_offset)
 			extended_offset = SWAP32(p->start_sect);
-		if (llseek(fd, (loff_t)offsets[partitions]
+		if (lseek64(fd, (loff_t)offsets[partitions]
 			       * SECTOR_SIZE, SEEK_SET) < 0)
 			fatal(unable_to_seek);
 		if (!(buffers[partitions] = (char *) malloc(SECTOR_SIZE)))
@@ -438,14 +441,14 @@
 		part_table[partitions] = ext_pointers[partitions] = NULL;
 		q = p = offset(buffers[partitions], 0);
 		for (i = 0; i < 4; i++, p++) {
-			if (p->sys_ind == EXTENDED)
+			if (p->sys_ind == EXTENDED) {
 				if (ext_pointers[partitions])
 					fprintf(stderr, "Warning: extra link "
 						"pointer in partition table "
 						"%d\n", partitions + 1);
 				else
 					ext_pointers[partitions] = p;
-			else if (p->sys_ind)
+			} else if (p->sys_ind) {
 				if (part_table[partitions])
 					fprintf(stderr,
 						"Warning: ignoring extra data "
@@ -453,15 +456,18 @@
 						partitions + 1);
 				else
 					part_table[partitions] = p;
+			}
 		}
-		if (!part_table[partitions])
+		if (!part_table[partitions]) {
 			if (q != ext_pointers[partitions])
 				part_table[partitions] = q;
 			else part_table[partitions] = q + 1;
-		if (!ext_pointers[partitions])
+		}
+		if (!ext_pointers[partitions]) {
 			if (q != part_table[partitions])
 				ext_pointers[partitions] = q;
 			else ext_pointers[partitions] = q + 1;
+		}
 		p = ext_pointers[partitions++];
 	}
 }
@@ -497,11 +503,12 @@
 	warn_geometry();
 
 	for (i = 0; i < 4; i++)
-		if(part_table[i]->sys_ind == EXTENDED)
+		if(part_table[i]->sys_ind == EXTENDED) {
 			if (partitions != 4)
 				fprintf(stderr, "Ignoring extra extended "
 					"partition %d\n", i + 1);
 			else read_extended(part_table[ext_index = i]);
+		}
 
 	for (i = 3; i < partitions; i++)
 		if (SWAP16(*table_check(buffers[i])) != PART_TABLE_FLAG) {
@@ -621,6 +628,7 @@
 			case lower: i += low; break;
 			case upper: i += high; break;
 			case deflt: i += dflt; break;
+			default: break;
 			}
 		}
 		else
@@ -844,12 +852,12 @@
 		return;		/* do not check extended partitions */
 
 /* physical beginning c, h, s */
-	pbc = p->cyl & 0xff | (p->sector << 2) & 0x300;
+	pbc = (p->cyl & 0xff) | ((p->sector << 2) & 0x300);
 	pbh = p->head;
 	pbs = p->sector & 0x3f;
 
 /* physical ending c, h, s */
-	pec = p->end_cyl & 0xff | (p->end_sector << 2) & 0x300;
+	pec = (p->end_cyl & 0xff) | ((p->end_sector << 2) & 0x300);
 	peh = p->end_head;
 	pes = p->end_sector & 0x3f;
 
@@ -941,7 +949,7 @@
 		disk_device, heads, sectors, cylinders);
         printf("Nr AF  Hd Sec  Cyl  Hd Sec  Cyl   Start    Size ID\n");
 	for (i = 0 ; i < partitions; i++)
-		if (p = q[i]) {
+		if ((p = q[i])) {
                         printf("%2d %02x%4d%4d%5d%4d%4d%5d%8d%8d %02x\n",
 				i + 1, p->boot_ind, p->head,
 				sector(p->sector),
@@ -1026,7 +1034,7 @@
 				last[i]);
 			total += last[i] + 1 - first[i];
 			for (j = 0; j < i; j++)
-			if (first[i] >= first[j] && first[i] <= last[j]
+			if ((first[i] >= first[j] && first[i] <= last[j])
 					|| (last[i] <= last[j] &&
 					last[i] >= first[j])) {
 				printf("Warning: partition %d overlaps "
@@ -1060,11 +1068,11 @@
 	if (total > heads * sectors * cylinders)
 		printf("Total allocated sectors %d greater than the maximum "
 			"%d\n", total, heads * sectors * cylinders);
-	else if (total = heads * sectors * cylinders - total)
+	else if ((total = heads * sectors * cylinders - total))
 		printf("%d unallocated sectors\n", total);
 }
 
-void add_partition(int n, int sys)
+static void add_partition(int n, int sys)
 {
 	char mesg[48];
 	int i, read = 0;
@@ -1100,11 +1108,12 @@
 		for (i = 0; i < partitions; i++) {
 			if (start == offsets[i])
 				start += sector_offset;
-			if (start >= first[i] && start <= last[i])
+			if (start >= first[i] && start <= last[i]) {
 				if (n < 4)
 					start = last[i] + 1;
 				else
 					start = last[i] + sector_offset;
+			}
 		}
 		if (start > limit)
 			break;
@@ -1249,7 +1258,7 @@
 	for (i = 3; i < partitions; i++)
 		if (changed[i]) {
 			*table_check(buffers[i]) = SWAP16(PART_TABLE_FLAG);
-			if (llseek(fd, (loff_t)offsets[i]
+			if (lseek64(fd, (loff_t)offsets[i]
 					* SECTOR_SIZE, SEEK_SET) < 0)
 				fatal(unable_to_seek);
 			if (write(fd, buffers[i], SECTOR_SIZE) != SECTOR_SIZE)
@@ -1262,7 +1271,7 @@
 	       "(Reboot to ensure the partition table has been updated.)\n");
 	sync();
 	sleep(2);
-	if (i = ioctl(fd, BLKRRPART)) {
+	if ((i = ioctl(fd, BLKRRPART))) {
                 error = errno;
         } else {
                 /* some kernel versions (1.2.x) seem to have trouble
@@ -1270,7 +1279,7 @@
 		   twice, the second time works. - biro@yggdrasil.com */
                 sync();
                 sleep(2);
-                if(i = ioctl(fd, BLKRRPART))
+                if((i = ioctl(fd, BLKRRPART)))
                         error = errno;
         }
 
@@ -1391,7 +1400,7 @@
 void try(char *device)
 {
 	disk_device = device;
-	if (!setjmp(listingbuf))
+	if (!setjmp(listingbuf)) {
 		if ((fd = open(disk_device, type_open)) >= 0) {
 			close(fd);
 			get_boot();
@@ -1407,6 +1416,7 @@
 		    exit(1);
 		 }
 	      }
+	}
 }
 
 void main(int argc, char **argv)
--- mac-fdisk-0.1.orig/fdisklabel.c
+++ mac-fdisk-0.1/fdisklabel.c
@@ -38,7 +38,6 @@
 #include <unistd.h>
 #include <stdio.h>
 #include <stdlib.h>
-#include <string.h>
 #include <fcntl.h>
 #include <ctype.h>
 #include <setjmp.h>
@@ -47,7 +46,6 @@
 #include <sys/ioctl.h>
 #include <sys/param.h>
 
-#include <linux/genhd.h>
 #include <linux/hdreg.h>
 #include <linux/fs.h>
 
@@ -377,7 +375,7 @@
     {
 #if defined (i386)
       if (bsd_initlabel (bsd_part, &bsd_dlabel, bsd_part_index) == 1)
-#elif defined (__alpha__) || defined (__powerpc__)
+#elif defined (__alpha__) || defined (__powerpc__) || defined (__mc68000__)
       if (bsd_initlabel (NULL, &bsd_dlabel, 0) == 1)
 #endif
       {
@@ -515,7 +513,7 @@
   alpha_bootblock_checksum (buffer);
 #endif
 
-  if (llseek (fd, sector * SECTOR_SIZE, SEEK_SET) == -1)
+  if (lseek64 (fd, sector * SECTOR_SIZE, SEEK_SET) == -1)
     fatal (unable_to_seek);
   if (BSD_BBSIZE != write (fd, buffer, BSD_BBSIZE))
     fatal (unable_to_write);
@@ -679,7 +677,7 @@
   sector = 0;
 #endif
 
-  if (llseek (fd, sector * SECTOR_SIZE, SEEK_SET) == -1)
+  if (lseek64 (fd, sector * SECTOR_SIZE, SEEK_SET) == -1)
     fatal (unable_to_seek);
   if (BSD_BBSIZE != read (fd, buffer, BSD_BBSIZE))
     fatal (unable_to_read);
@@ -724,12 +722,12 @@
 
 #if defined (__alpha__) && BSD_LABELSECTOR == 0
   alpha_bootblock_checksum (buffer);
-  if (llseek (fd, 0, SEEK_SET) == -1)
+  if (lseek64 (fd, 0, SEEK_SET) == -1)
     fatal (unable_to_seek);
   if (BSD_BBSIZE != write (fd, buffer, BSD_BBSIZE))
     fatal (unable_to_write);
 #else
-  if (llseek (fd, sector * SECTOR_SIZE + BSD_LABELOFFSET, SEEK_SET) == -1)
+  if (lseek64 (fd, sector * SECTOR_SIZE + BSD_LABELOFFSET, SEEK_SET) == -1)
     fatal (unable_to_seek);
   if (sizeof (struct disklabel) != write (fd, d, sizeof (struct disklabel)))
     fatal (unable_to_write);
--- mac-fdisk-0.1.orig/fdisklabel.h
+++ mac-fdisk-0.1/fdisklabel.h
@@ -52,6 +52,12 @@
 #define BSD_LABELOFFSET   0
 #define	BSD_BBSIZE        0
 #define	BSD_SBSIZE        0
+#elif defined (__mc68000__)
+/* LABELSECTOR, LABELOFFSET, BBSIZE & SBSIZE are undefined for __powerpc__ */
+#define BSD_LABELSECTOR   0
+#define BSD_LABELOFFSET   0
+#define	BSD_BBSIZE        0
+#define	BSD_SBSIZE        0
 #else
 #error unknown architecture
 #endif
--- mac-fdisk-0.1.orig/Makefile
+++ mac-fdisk-0.1/Makefile
@@ -5,7 +5,14 @@
 fdisk: fdisk.o fdisklabel.o
 
 clean:
-	rm -f *.o pdisk fdisk
+	rm -f *.o pdisk fdisk mac-fdisk pmac-fdisk
+
+install: pdisk fdisk
+	-rm -f pmac-fdisk mac-fdisk
+	ln pdisk mac-fdisk
+	ln fdisk pmac-fdisk
+	install -o root -g root -m 0755 mac-fdisk ${DESTDIR}/sbin
+	install -o root -g root -m 0755 pmac-fdisk ${DESTDIR}/sbin
 
 distribution:
 	cd ..; tar cvf pdisk.src.tar.`date +%y%m%d` --files-from pdisk/list.src
--- mac-fdisk-0.1.orig/debian/README.debian
+++ mac-fdisk-0.1/debian/README.debian
@@ -0,0 +1,18 @@
+mac-fdisk for DEBIAN
+----------------------
+
+Comments regarding mac-fdisk
+
+mac-fdisk provides Apple partition format utilities required for
+installation of Debian/68k on Apple Macintosh computers. The Debian version
+of mac-fdisk is derived from pdisk 0.4a2 (pdisk.970115.tar) by Eryk Vershen 
+(eryk@apple.com).
+pmac-fdisk is a version of the PC partition format utilities for PowerPC
+computers, taken from the same pdisk source version and can be used for
+installation of Debian/68k on PC partition format disks on Macintosh.
+
+Modifications have been made to the pdisk partition table output code to permit
+parsing the output of 'mac-fdisk -l' in a manner consistent with other Linux
+fdisk utilities. (Christiaan Welvaart, <>)
+
+Michael Schmitz <schmitz@lcbvax.cchem.berkeley.edu>, Sat, 28 Feb 1998 12:58:07 -0800
--- mac-fdisk-0.1.orig/debian/postinst.debhelper
+++ mac-fdisk-0.1/debian/postinst.debhelper
@@ -0,0 +1,7 @@
+# Automatically added by dh_installdocs
+if [ "$1" = "configure" ]; then
+	if [ -d /usr/doc -a ! -e /usr/doc/mac-fdisk -a -d /usr/share/doc/mac-fdisk ]; then
+		ln -sf ../share/doc/mac-fdisk /usr/doc/mac-fdisk
+	fi
+fi
+# End automatically added section
--- mac-fdisk-0.1.orig/debian/changelog
+++ mac-fdisk-0.1/debian/changelog
@@ -0,0 +1,103 @@
+mac-fdisk (0.1-10) unstable; urgency=high
+
+  * Added .udeb magic to rules (kudos to Gaudenz Steinlin
+    <gaudenz@soziologie.ch>); kept mac-fdisk in /sbin though). 
+    Closes: #188420.
+
+ -- Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>  Wed, 04 Jun 2003 17:06:02 +0200
+
+mac-fdisk (0.1-9) unstable; urgency=high
+
+  * Rebuilt with woody binutils to allow for prelinking. Closes: #176353.
+
+  * Set 'automagically mount on boot' flag when creating HFS partitions
+    (thanks to Derrick Pates <dpates@dsdk12.net> for finding the
+    undocumented bit!). Experimental, but this is unstable, right?
+
+ -- Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>  Fri, 24 Jan 2003 16:20:20 +0200
+
+mac-fdisk (0.1-8) unstable; urgency=high
+
+  * Update mac-fdisk man page (kudos to Chris Tillman). Closes: #121928.
+
+  * Remove mac-fdisk-cross from control file; remove Sparc from Arch: entries
+    (to get rid of outdated mac-fdisk-cross 0.1-1 in the archive). Change
+    package descrption line for pmac-fdisk to emphasize it's a fdisk clone.
+
+  * Change sync() to ioctl(fd, BLKFLSBUF) to flush partition table to disk
+    on write - hopefully work around a kernel bug on new machines.
+
+ -- Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>  Fri, 07 Dec 2001 13:38:10 +0200
+
+mac-fdisk (0.1-7) unstable; urgency=high
+
+  * Bugfix: mac-fdisk didn't properly handle devfs device names. Mangle disk
+    name (.../disc) in dump routine to end in .../part%d (patch by Colin
+    Walters <walters@verbum.org>). Closes: #110056.
+
+ -- Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>  Mon, 04 Sep 2001 16:02:45 +0200
+
+mac-fdisk (0.1-6.0potato1) stable; urgency=high
+
+  * Feature added: menu option to create bootstrap partition needed for 
+    powerpc NewWorld machines with the proper type and size (patch supplied 
+    by Ethan Benson). This should help newbies that won't read the docs
+    anyway. Closes: #99660.
+
+  * Bugfix: mac-fdisk used to get the disk size wrong when brute force
+    probing for end-of-disk by seek&read. Turns out gcc did not cope with 
+    arithmetics on long long types without explicit cast. Closes: #99700.
+
+ -- Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>  Fri, 15 Jun 2001 12:16:35 +0200
+
+mac-fdisk (0.1-6) unstable; urgency=high
+
+  * Feature added: menu option to create bootstrap partition needed for 
+    powerpc NewWorld machines with the proper type and size (patch supplied 
+    by Ethan Benson). This should help newbies that won't read the docs
+    anyway. Closes: #99660.
+
+  * Bugfix: mac-fdisk used to get the disk size wrong when brute force
+    probing for end-of-disk by seek&read. Turns out gcc did not cope with 
+    arithmetics on long long types without explicit cast. Closes: #99700.
+
+ -- Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>  Mon, 04 Jun 2001 13:54:21 +0200
+
+mac-fdisk (0.1-5) unstable; urgency=low
+
+  * Bugfix: fix build problems for glibc 2.2 (remove string.h includes, 
+    use lseek64 for llseek, fix some petty gcc warnings)
+
+ -- Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>  Wed, 02 Mar 2001 19:42:01 +0200
+
+mac-fdisk (0.1-4) unstable; urgency=low
+
+  * Bugfix: correct off-by-one error on moving a partition downwards in the
+    partition map. Clarification of various program messages and prompts
+    (closes #69148, #69149 and #69152). Update of mac-fdisk man page.
+
+ -- Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>  Wed, 08 Oct 2000 17:49:07 +0200
+
+mac-fdisk (0.1-3) unstable; urgency=low
+
+  * PowerPC install fixes (work around lack of /proc/hardware), rename pmac-fdisk
+    package (previously pmac-fdisk-cross). Add pmac-fdisk man page.
+
+ -- Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>  Wed, 08 Mar 2000 18:29:07 +0200
+
+mac-fdisk (0.1-2) unstable; urgency=low
+
+  * Change man page name and install location, changed man page, rebuild for 2.2.
+
+ -- Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>  Fri, 22 Oct 1999 20:29:07 +0200
+
+mac-fdisk (0.1-1) unstable; urgency=low
+
+  * Initial Release. (built from previous pdisk-0.4a2 with fixes by Roman Hodek)
+
+ -- Michael Schmitz <schmitz@lcbvax.cchem.berkeley.edu>  Sat, 28 Feb 1998 21:58:07 -0800
+
+Local variables:
+mode: debian-changelog
+add-log-mailing-address: "schmitz@biophys.uni-duesseldorf.de"
+End:
--- mac-fdisk-0.1.orig/debian/prerm.debhelper
+++ mac-fdisk-0.1/debian/prerm.debhelper
@@ -0,0 +1,5 @@
+# Automatically added by dh_installdocs
+if [ \( "$1" = "upgrade" -o "$1" = "remove" \) -a -L /usr/doc/mac-fdisk ]; then
+	rm -f /usr/doc/mac-fdisk
+fi
+# End automatically added section
--- mac-fdisk-0.1.orig/debian/copyright
+++ mac-fdisk-0.1/debian/copyright
@@ -0,0 +1,25 @@
+This package was debianized by Michael Schmitz schmitz@lcbvax.cchem.berkeley.edu on
+Sun, 11 Jan 1998 22:58:07 -0800.
+
+It was downloaded from ftp.mklinux.apple.com:/pub/Other_Tools/
+
+Copyright:
+
+ * Copyright 1996,1997 by Apple Computer, Inc.
+ *              All Rights Reserved 
+ *  
+ * Permission to use, copy, modify, and distribute this software and 
+ * its documentation for any purpose and without fee is hereby granted, 
+ * provided that the above copyright notice appears in all copies and 
+ * that both the copyright notice and this permission notice appear in 
+ * supporting documentation. 
+ *  
+ * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
+ * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
+ * FOR A PARTICULAR PURPOSE. 
+ *  
+ * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
+ * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
+ * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
+ * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
+ * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
--- mac-fdisk-0.1.orig/debian/control
+++ mac-fdisk-0.1/debian/control
@@ -0,0 +1,68 @@
+Source: mac-fdisk
+Section: base
+Priority: required
+Build-Depends: debhelper, coreutils, grep
+Maintainer: Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>
+Standards-Version: 3.5.8.0
+
+Package: mac-fdisk
+Architecture: m68k powerpc
+Depends: ${shlibs:Depends}
+Description: Apple disk partition manipulation tool
+ The fdisk utilities from the MkLinux project, adopted for Linux/m68k.
+ Mac-fdisk allows you to create and edit the partition table of a disk. 
+ It supports only the Apple partition format used on Macintosh and PowerMac, 
+ use pmac-fdisk for PC partition format disks as used on PowerPC machines. 
+ Mac-fdisk is an interactive tool with a menu similar to PC fdisk, supported 
+ options are somewhat different from PC fdisk due to the differences in 
+ partition format.
+
+Package: pmac-fdisk
+Architecture: powerpc
+Depends: ${shlibs:Depends}
+Description: fdisk partition manipulation tool for PowerPC
+ The fdisk utilities from the MkLinux project, adopted for Linux/ppc.
+ Pmac-fdisk allows you to create and edit the partition table of a disk. 
+ It supports the PC partition format as used on PowerPC. It is an 
+ interactive tool similar to PC fdisk. 
+
+Package: pmac-fdisk-cross
+Architecture: m68k
+Section: otherosfs
+Priority: extra
+Depends: ${shlibs:Depends}
+Description: fdisk partition manipulation tool for PowerPC
+ The fdisk utilities from the MkLinux project, adopted for Linux/ppc.
+ Pmac-fdisk allows you to create and edit the partition table of a disk. 
+ It supports the PC partition format as used on PowerPC. It is an 
+ interactive tool similar to PC fdisk. 
+
+Package: mac-fdisk-udeb
+Architecture: powerpc m68k
+Priority: standard
+Section: debian-installer
+Depends: ${shlibs:Depends}
+Description:  Apple disk partition manipulation tool
+ The fdisk utilities from the MkLinux project, adopted for Linux/m68k.
+ Mac-fdisk allows you to create and edit the partition table of a disk. 
+ It supports only the Apple partition format used on Macintosh and PowerMac, 
+ use pmac-fdisk for PC partition format disks as used on PowerPC machines. 
+ Mac-fdisk is an interactive tool with a menu similar to PC fdisk, supported 
+ options are somewhat different from PC fdisk due to the differences in 
+ partition format.
+ .
+ This is a minimal mac-fdisk package used by the debian-installer.
+
+Package: pmac-fdisk-udeb
+Architecture: powerpc
+Priority: standard
+Section: debian-installer
+Depends: ${shlibs:Depends}
+Description: fdisk partition manipulation tool for PowerPC
+ The fdisk utilities from the MkLinux project, adopted for Linux/ppc.
+ Pmac-fdisk allows you to create and edit the partition table of a disk. 
+ It supports the PC partition format as used on PowerPC. It is an 
+ interactive tool similar to PC fdisk. 
+ .
+ This is a minimal pmac-fdisk package used by the debian-installer.
+
--- mac-fdisk-0.1.orig/debian/rules
+++ mac-fdisk-0.1/debian/rules
@@ -0,0 +1,183 @@
+#!/usr/bin/make -f
+# Made with the aid of debmake, by Christoph Lameter,
+# based on the sample debian/rules file for GNU hello by Ian Jackson.
+
+export DH_VERBOSE=1
+
+BUILDARCH = $(shell dpkg --print-gnu-build-architecture)
+
+packmn  = mac-fdisk
+packmc  = mac-fdisk-cross
+packpmn = pmac-fdisk
+packpmc = pmac-fdisk-cross
+packudeb = mac-fdisk-udeb
+packpudeb = pmac-fdisk-udeb
+tmpmn   = debian/tmp
+tmpmc   = debian/$(packmc)
+tmppmn  = debian/$(packpmn)
+tmppmc  = debian/$(packpmc)
+tmpudeb = debian/$(packudeb)
+tmppudeb = debian/$(packpudeb)
+docmn   = $(tmpmn)/usr/share/doc/$(packmn)
+docmc   = $(tmpmc)/usr/share/doc/$(packmc)
+docpmn  = $(tmppmn)/usr/share/doc/$(packpmn)
+docpmc  = $(tmppmc)/usr/share/doc/$(packpmc)
+
+build:
+	$(checkdir)
+	make CFLAGS="-O2 -g -Wall"
+	touch build
+
+clean:
+	$(checkdir)
+	-rm -f build
+	-make clean
+	-rm -f `find . -name "*~"`
+	-rm -rf $(tmpmn) $(tmpmc) $(tmppmn) $(tmppmc) $(tmpudeb) $(tmppudeb) debian/files* core debian/substvars
+
+binary-indep: build
+	$(checkdir)
+# There are no architecture-independent files to be uploaded
+# generated by this package.  If there were any they would be
+# made here.
+
+binary-arch: build
+	dh_testdir pdisk.h
+	dh_testroot
+	dh_clean -k
+	#dh_installdirs
+	# we don't want to package the pdisk man page
+	mv pdisk.8 pdisk.8.in
+	set -e; if [ "$(BUILDARCH)" = "m68k" -o "$(BUILDARCH)" = "powerpc" ]; then \
+		install -d $(tmpmn)/sbin; \
+		install -m 755 pdisk $(tmpmn)/sbin/mac-fdisk; \
+		install -d $(tmpmn)/usr/share/man/man8; \
+		install -m 644 mac-fdisk.8.in $(tmpmn)/usr/share/man/man8/mac-fdisk.8; \
+		dh_installdocs README -p$(packmn); \
+		dh_installmanpages -p$(packmn); \
+		dh_installchangelogs HISTORY -p$(packmn); \
+	else \
+		install -d $(tmpmc)/usr/sbin; \
+		install -m 755 pdisk $(tmpmc)/usr/sbin/mac-fdisk; \
+		install -d $(tmpmn)/usr/share/man/man8; \
+		install -m 644 mac-fdisk.8.in $(tmpmn)/usr/share/man/man8/mac-fdisk.8; \
+		dh_installdocs README -p$(packmc); \
+		dh_installmanpages  -p$(packmc); \
+		dh_installchangelogs HISTORY -p$(packmc); \
+	fi
+	set -e; if [ "$(BUILDARCH)" = "powerpc" ]; then \
+		install -d $(tmppmn)/sbin; \
+		install -m 755 fdisk $(tmppmn)/sbin/pmac-fdisk; \
+		install -d $(tmppmn)/usr/share/man/man8; \
+		install -m 644 pmac-fdisk.8.in $(tmppmn)/usr/share/man/man8/pmac-fdisk.8; \
+		dh_installdocs README -p$(packpmn); \
+		dh_installmanpages  -p$(packpmn); \
+		dh_installchangelogs HISTORY -p$(packpmn); \
+	else \
+		install -d $(tmppmc)/usr/sbin; \
+		install -m 755 fdisk $(tmppmc)/usr/sbin/pmac-fdisk; \
+		install -d $(tmppmc)/usr/share/man/man8; \
+		install -m 644 pmac-fdisk.8.in $(tmppmc)/usr/share/man/man8/pmac-fdisk.8; \
+		dh_installdocs README -p$(packpmc); \
+		dh_installmanpages  -p$(packpmc); \
+		dh_installchangelogs HISTORY -p$(packpmc); \
+	fi
+	# install README.Debian also in cross package (not done by dh_installdocs)
+	set -e; if [ "$(BUILDARCH)" != "m68k" -a "$(BUILDARCH)" != "powerpc" ]; then \
+		install -m 644 debian/README.debian $(docmc)/README.Debian; \
+	fi
+	# and move the pdisk man page back again ...
+	mv pdisk.8.in pdisk.8
+
+	# install mac-fdisk-udeb files
+	set -e; if [ "$(BUILDARCH)" = "m68k" -o "$(BUILDARCH)" = "powerpc" ]; then \
+		install -d $(tmpudeb)/sbin; \
+		install -d $(tmpudeb)/DEBIAN; \
+		install -m 755 pdisk $(tmpudeb)/sbin/mac-fdisk; \
+	fi
+
+	# install pmac-fdisk-udeb files
+	set -e; if [ "$(BUILDARCH)" = "powerpc" ]; then \
+		install -d $(tmppudeb)/usr/sbin; \
+		install -d $(tmppudeb)/DEBIAN; \
+		install -m 755 fdisk $(tmppudeb)/usr/sbin/pmac-fdisk; \
+	fi
+
+	# build native pdisk only for m68k, cross package only for others
+	set -e; if [ "$(BUILDARCH)" = "m68k" -o "$(BUILDARCH)" = "powerpc" ]; then \
+		dh_strip -p$(packmn) -P$(tmpmn); \
+		dh_compress -p$(packmn) -P$(tmpmn); \
+		dh_fixperms -p$(packmn) -P$(tmpmn); \
+		dh_installdeb -p$(packmn) -P$(tmpmn); \
+		dh_shlibdeps -p$(packmn) -P$(tmpmn); \
+		dh_gencontrol -p$(packmn) -P$(tmpmn); \
+		dh_md5sums -p$(packmn) -P$(tmpmn); \
+	else \
+		dh_strip -p$(packmc); \
+		dh_compress -p$(packmc); \
+		dh_fixperms -p$(packmc); \
+		dh_installdeb -p$(packmc); \
+		dh_shlibdeps -p$(packmc); \
+		dh_gencontrol -p$(packmc); \
+		dh_md5sums -p$(packmc); \
+	fi
+	# build native fdisk only for powerpc, cross package only for others
+	set -e; if [ "$(BUILDARCH)" = "powerpc" ]; then \
+		dh_strip -p$(packpmn); \
+		dh_compress -p$(packpmn); \
+		dh_fixperms -p$(packpmn); \
+		dh_installdeb -p$(packpmn); \
+		dh_shlibdeps -p$(packpmn); \
+		dh_gencontrol -p$(packpmn); \
+		dh_md5sums -p$(packpmn); \
+	else \
+		dh_strip -p$(packpmc); \
+		dh_compress -p$(packpmc); \
+		dh_fixperms -p$(packpmc); \
+		dh_installdeb -p$(packpmc); \
+		dh_shlibdeps -p$(packpmc); \
+		dh_gencontrol -p$(packpmc); \
+		dh_md5sums -p$(packpmc); \
+	fi
+	set -e; if [ "$(BUILDARCH)" = "m68k" -o "$(BUILDARCH)" = "powerpc" ]; then \
+		dh_builddeb -p$(packmn) -P$(tmpmn); \
+	else \
+		dh_builddeb -p$(packmc); \
+	fi
+	set -e; if [ "$(BUILDARCH)" = "powerpc" ]; then \
+		dh_builddeb -p$(packpmn); \
+	else \
+		dh_builddeb -p$(packpmc); \
+	fi
+
+	# build mac-fdisk-udeb on powerpc and m68k
+	set -e; if [ "$(BUILDARCH)" = "m68k" -o "$(BUILDARCH)" = "powerpc" ]; then \
+		dh_strip -p$(packudeb); \
+		dh_installdeb -p$(packudeb); \
+		dh_shlibdeps -p$(packudeb); \
+		dh_gencontrol -p$(packudeb) -- -isp -fdebian/files~; \
+		dpkg-distaddfile $(packudeb)_$(shell dpkg-parsechangelog | grep ^Version: | cut -d ' ' -f 2)_$(BUILDARCH).udeb debian-installer standard; \
+		dh_builddeb -p$(packudeb) --filename=$(packudeb)_$(shell dpkg-parsechangelog | grep ^Version: | cut -d ' ' -f 2)_$(BUILDARCH).udeb; \
+	fi
+
+	# build pmac-fdisk-udeb on powerpc
+	set -e; if [ "$(BUILDARCH)" = "powerpc" ]; then \
+		dh_strip -p$(packpudeb); \
+		dh_installdeb -p$(packpudeb); \
+		dh_shlibdeps -p$(packpudeb); \
+		dh_gencontrol -p$(packpudeb) -- -isp -fdebian/files~; \
+		dpkg-distaddfile $(packpudeb)_$(shell dpkg-parsechangelog | grep ^Version: | cut -d ' ' -f 2)_$(BUILDARCH).udeb debian-installer standard; \
+		dh_builddeb -p$(packpudeb) --filename=$(packpudeb)_$(shell dpkg-parsechangelog | grep ^Version: | cut -d ' ' -f 2)_$(BUILDARCH).udeb; \
+	fi
+
+define checkdir
+	test -f debian/rules
+endef
+
+binary: binary-indep binary-arch
+
+checkroot:
+	$(checkdir)
+	test root = "`whoami`"
+
+.PHONY: binary binary-arch binary-indep clean checkroot
--- mac-fdisk-0.1.orig/debian/pmac-fdisk.postinst.debhelper
+++ mac-fdisk-0.1/debian/pmac-fdisk.postinst.debhelper
@@ -0,0 +1,7 @@
+# Automatically added by dh_installdocs
+if [ "$1" = "configure" ]; then
+	if [ -d /usr/doc -a ! -e /usr/doc/pmac-fdisk -a -d /usr/share/doc/pmac-fdisk ]; then
+		ln -sf ../share/doc/pmac-fdisk /usr/doc/pmac-fdisk
+	fi
+fi
+# End automatically added section
--- mac-fdisk-0.1.orig/debian/postinst
+++ mac-fdisk-0.1/debian/postinst
@@ -0,0 +1,50 @@
+#! /bin/sh
+set -e
+
+Arch=`dpkg --print-installation-architecture`
+
+#
+# make symlink /sbin/fdisk point to the native fdisk
+#
+
+# This is also true if /sbin/fdisk is a dangling symlink; in that case we
+# want to update the link, too.
+if [ ! -e /sbin/fdisk ]; then
+	machine=""
+	if [ "$Arch" == "m68k" ]; then
+		case `awk '$1 == "Model:" { print $2 }' /proc/hardware` in
+			Atari)
+				machine=atari
+				;;
+			Amiga)
+				machine=amiga
+				;;
+			Macintosh)
+				machine=mac
+				;;
+			Motorola) # MVME
+				;;
+		esac
+	elif [ "$Arch" == "powerpc" ]; then
+		# case `awk '$1 == "motherboard" { print $6 }' /proc/cpuinfo` in
+		# case `cat /proc/cpuinfo | egrep "^motherboard" | sed -e 's/.* \([a-zA-Z]*\)$/\1/'` in
+		case `awk '$1 == "motherboard" { print $NF }' /proc/cpuinfo` in
+			Macintosh)
+				machine=mac
+				;;
+			*)
+				machine=pmac
+				;;
+		esac
+
+	fi
+	if [ -n "$machine" -a -f /sbin/$machine-fdisk ]; then
+		ln -sf $machine-fdisk /sbin/fdisk
+	else
+		echo "No native fdisk for this machine type!"
+	fi
+fi
+
+#DEBHELPER#
+
+exit 0
--- mac-fdisk-0.1.orig/debian/pmac-fdisk.prerm.debhelper
+++ mac-fdisk-0.1/debian/pmac-fdisk.prerm.debhelper
@@ -0,0 +1,5 @@
+# Automatically added by dh_installdocs
+if [ \( "$1" = "upgrade" -o "$1" = "remove" \) -a -L /usr/doc/pmac-fdisk ]; then
+	rm -f /usr/doc/pmac-fdisk
+fi
+# End automatically added section
--- mac-fdisk-0.1.orig/debian/mac-fdisk-udeb.substvars
+++ mac-fdisk-0.1/debian/mac-fdisk-udeb.substvars
@@ -0,0 +1 @@
+shlibs:Depends=libc6 (>= 2.2.5-13)
--- mac-fdisk-0.1.orig/debian/pmac-fdisk.substvars
+++ mac-fdisk-0.1/debian/pmac-fdisk.substvars
@@ -0,0 +1 @@
+shlibs:Depends=libc6 (>= 2.2.5-13)
--- mac-fdisk-0.1.orig/debian/pmac-fdisk-udeb.substvars
+++ mac-fdisk-0.1/debian/pmac-fdisk-udeb.substvars
@@ -0,0 +1 @@
+shlibs:Depends=libc6 (>= 2.2.5-13)
--- mac-fdisk-0.1.orig/mac-fdisk.8.in
+++ mac-fdisk-0.1/mac-fdisk.8.in
@@ -0,0 +1,262 @@
+.TH MAC-FDISK 8 "1 December 2001" "Debian" "Apple Disk Partitioning Manual"
+.SH NAME
+mac-fdisk \- Apple partition table editor for Linux
+.SH SYNOPSIS
+.B mac-fdisk
+.B "[ \-h | \--help ] [ \-v | \--version ] [ \-l | \--list device ... ]"
+.br
+.B mac-fdisk
+.B "[ \-r | \--readonly ] device ... "
+.SH DESCRIPTION
+.B mac-fdisk
+is a command line type program which partitions disks using the standard Apple
+disk partitioning scheme described in "Inside Macintosh: Devices".
+The
+.I device
+is usually one of the following:
+
+.nf
+.RS
+/dev/sda
+/dev/sdb
+/dev/sdc
+/dev/sdd
+/dev/sde
+/dev/sdf
+/dev/sdg
+/dev/hda
+/dev/hdb
+
+.RE
+.fi
+/dev/sda is the first hard disk on the SCSI bus (i.e. the
+one with the lowest id), /dev/sdb is the second hard disk, and so on.
+The
+.I partition
+is a
+.I device
+name followed by a partition number.
+The partition number is the index (starting from one) of the partition
+map entry in the partition map (and the partition map itself occupies the
+first entry).
+For example,
+.B /dev/sda2
+is the partition described by the second entry in the partiton map on /dev/sda.
+
+.SH OPTIONS
+.TP
+.B \-v | \--version
+Prints version number of the
+.B mac-fdisk
+program.
+.TP
+.B \-h | \--help
+Prints a list of available commands for the
+.B mac-fdisk
+program.
+.TP
+.B \-l | \--list
+Lists the partition tables for the specified
+.IR device(s).
+With no 
+.IR device(s)
+given, lists all SCSI and IDE devices found in the system.
+.TP
+.B \-r | \--readonly
+Prevents
+.B mac-fdisk
+from writing to the device.
+.SH "Editing Partition Tables"
+An argument which is simply the name of a
+.I device
+indicates that
+.B mac-fdisk
+should edit the partition table of that device. Once started, 
+.B mac-fdisk 
+presents an interactive command prompt to edit the partition table. 
+The partition editing commands are:
+
+.nf
+.RS
+h    list available commands
+p    print (list) the current edited partition table status
+P    print ordered by base address
+i    initialize the partition map
+s    change size of partition map
+b    create new 800K Apple_Bootstrap partition (used by yaboot)
+c    create new standard Linux type partition
+C    create new partition, specifying the partition type
+d    delete a partition
+r    reorder partition entry
+w    write the partition table to disk
+q    quit 
+
+.RE
+.fi
+Commands which take arguments prompt for each argument in turn.
+You can also type the arguments separated by spaces
+and those prompts will be skipped. The
+.B i
+and
+.B w
+commands will prompt for confirmation. None of the editing you do will 
+actually affect the state of the disk you are partitioning until the 
+.B w 
+command is issued. Then the map in its edited state will be 
+permanently written to the disk.
+
+Partitions are always specified by their number, the index of the
+partition entry in the partition map.  Many commands will change the
+index numbers of partitions which follow the affected partition; you are
+encouraged to use the 
+.B p
+command to print the partition table as frequently as necessary. For SCSI
+disks, the partition table should not contain more than fifteen partitions 
+(partition map excluded). IDE disks have a limit of 31 partitions.
+
+Here is a more-or-less typical output for the print command:
+
+.nf
+.RS
+Command (? for help): p
+/dev/sdb
+        #                type name              length   base    ( size )  system
+/dev/sdb1 Apple_partition_map Apple                 63 @ 1       ( 31.5k)  Partition map
+/dev/sdb2      Apple_Driver43 Macintosh             54 @ 64      ( 27.0k)  Driver 4.3
+/dev/sdb3      Apple_Driver43 Macintosh             74 @ 118     ( 37.0k)  Driver 4.3
+/dev/sdb4  Apple_Driver_IOKit Macintosh            512 @ 192     (256.0k)  Unknown
+/dev/sdb5       Apple_Patches Patch Partition      512 @ 704     (256.0k)  Unknown
+/dev/sdb6           Apple_HFS untitled         3072000 @ 1216    (  1.5G)  HFS
+/dev/sdb7           Apple_HFS untitled 2        333026 @ 3073216 (162.6M)  HFS
+/dev/sdb8          Apple_Free Extra                 10 @ 3406242 (  5.0k)  Free space
+
+Block size=512, Number of Blocks=3406252
+DeviceType=0x0, DeviceId=0x0
+Drivers-
+1: @ 64 for 22, type=0x1
+2: @ 118 for 36, type=0xffff
+
+.RE
+.fi
+
+The
+.B i
+(initialize) command prompts for the size of the device.  You can just
+type Return to accept the offered size, which should be correct.
+
+The
+.B b
+command is a shortcut to create the bootstrap partition used on PowerPC
+NewWorld machines. It is equivalent to creating an 800k
+.B Apple_Bootstrap
+type partition using the 
+.B C
+command described below. The sole purpose of this partition is to
+store the boot loader. In multiboot environments, the first bootable
+partition found on the disk takes precedence unless a specific boot
+partition is set in OpenFirmware, so it's best to create the bootstrap
+partition first, or move it to a position before any
+.B Apple_HFS 
+or 
+.B Apple_Boot
+partitions using the 
+.B r
+command described below. Then you will still able to boot Linux after
+the occasional OpenFirmware reset.
+
+The
+.B c
+(create new partition) command has three arguments. As mentioned
+above you can type the arguments following the command, separated by
+spaces, or respond to prompts for each argument:
+
+  1) The base address of the start of the partition.
+
+     You can specify a number in blocks (most likely reading from the
+     existing partition map) or you can also type a partition number
+     followed by the letter 'p' to indicate that the new partition
+     should take the place of that existing free space partition.
+
+  2) The length of the partition.
+
+     Again, you can specify a number in blocks or type a partition
+     number followed by the letter 'p' to indicate use of the entire
+     partition. You can also type a number followed by 'k', 'm', or
+     'g' to indicate the size in kilobytes, megabytes, or gigabytes
+     respectively. (These are powers of 1024, of course, not powers
+     of 1000.)
+
+  3) The name of the partition.
+
+     This can be a single word without quotes, or a string surrounded
+     by single or double quotes. It is best to name any swap partition
+     you create `swap'; other partition names are up to you. The names
+     are not visible to Linux.
+
+The
+.B C
+command is identical to the
+.B c
+command, with the addition of a partition type argument after the
+other arguments. The partition type used for Linux swap and data partitons
+is 
+.B APPLE_UNIX_SVR2
+(this is the partition type created by the 
+.B c
+command). Under normal circumstances, you should not need to use this
+command.
+
+The
+.B d
+command deletes the partition number specified, replacing that partition 
+with partitionable free space.
+
+The
+.B r
+(reorder) command allows the index number of partitions to be changed.
+The index numbers are constrained to be a contiguous sequence. 
+.B mac-fdisk
+will enforce this constraint by recalculating the partition numbers
+after each insert, delete or reorder operation. OpenFirmware looks for
+bootable partitions in the order specified by the index. The
+partitions are not moved on the disk. This command takes two
+arguments, the number of the partition to be moved and the partition
+number it should become.
+
+The
+.B w
+command writes the partition map out to disk. Note that partition
+maps for disks with mounted partitions cannot immediately be
+reinterpreted by the kernel. In order to use the new partition map you
+must reboot. Within the Debian installer system, 
+.B mac-fdisk 
+is normally invoked before any partitions are mounted, thus a reboot is not 
+necessary before continuing the installation.
+
+The
+.B q
+command terminates the program. If there was no 
+.B w
+command issued during the program run, then there will be no effect on the disk.
+
+.SH BUGS
+Some people believe there should really be just one disk partitioning utility.
+
+.B mac-fdisk
+should be able to create HFS partitions that work. Currently, if a
+pre-existing HFS partition is resized, MacOS will continue to use the
+partition size stored in the HFS 'superblock' instead of using the size from
+the partition table (the MacOS volume on the partition remains valid even
+though the sizes don't match anymore). This can have undesired side effects
+especially when creating a smaller HFS partition followed by a few Linux 
+partitions in place of the previous HFS partition space. To avoid this 
+issue, create MacOS partitions within MacOS and then don't resize them 
+in 
+.B mac-fdisk.
+
+.SH "SEE ALSO"
+.BR fdisk (8), 
+.BR mkswap (8),
+.BR mkfs (8)
+.SH AUTHOR
+Eryk Vershen (eryk@apple.com), man page revised by Chris Tillman (tillman@azstarnet.com)
--- mac-fdisk-0.1.orig/pmac-fdisk.8.in
+++ mac-fdisk-0.1/pmac-fdisk.8.in
@@ -0,0 +1,222 @@
+.\" Copyright 1992, 1993 Rickard E. Faith (faith@cs.unc.edu)
+.\" Copyright 1998 Andries E. Brouwer (aeb@cwi.nl)
+.\" Copyright 2000 Michael Schmitz (schmitz@biophys.uni-duesseldorf.de)
+.\" May be distributed under the GNU General Public License
+.TH PMAC-FDISK 8 "11 June 1998" "Linux 2.0" "Linux Programmer's Manual"
+.SH NAME
+pmac-fdisk \- Partition table manipulator for Linux
+.SH SYNOPSIS
+.BI "pmac-fdisk [\-u] " device
+.sp
+.BI "pmac-fdisk \-l [\-u] " "device ..."
+.sp
+.BI "pmac-fdisk \-s " "partition ..."
+.sp
+.BI "pmac-fdisk \-v
+.SH DESCRIPTION
+Hard disks can be divided into one or more logical disks called
+.IR partitions .
+This division is described in the
+.I "partition table"
+found in sector 0 of the disk.
+
+In the BSD world one talks about `disk slices' and a `disklabel'.
+
+Linux needs at least one partition, namely for its root file system.
+It can use swap files and/or swap partitions, but the latter are more
+efficient. So, usually one will want a second Linux partition
+dedicated as swap partition.
+On Intel compatible hardware, the BIOS that boots the system
+can often only access the first 1024 cylinders of the disk.
+For this reason people with large disks often create a third partition,
+just a few MB large, typically mounted on
+.IR /boot ,
+to store the kernel image and a few auxiliary files needed at boot time,
+so as to make sure that this stuff is accessible to the BIOS.
+There may be reasons of security, ease of administration and backup,
+or testing, to use more than the minimum number of partitions.
+
+.B pmac-fdisk
+(in the first form of invocation)
+is a menu driven program for creation and manipulation of
+partition tables.
+It understands DOS type partition tables and BSD or SUN type disklabels.
+
+The
+.I device
+is usually one of the following:
+.br
+.nf
+.RS
+/dev/hda
+/dev/hdb
+/dev/sda
+/dev/sdb
+.RE
+.fi
+(/dev/hd[a-h] for IDE disks, /dev/sd[a-p] for SCSI disks).
+A device name refers to the entire disk.
+
+The
+.I partition
+is a
+.I device
+name followed by a partition number.  For example,
+.B /dev/hda1
+is the first partition on the first IDE hard disk in the system.
+IDE disks can have up to 63 partitions, SCSI disks up to 15.
+See also
+.IR /usr/src/linux/Documentation/devices.txt .
+
+A BSD/SUN type disklabel can describe 8 partitions,
+the third of which should be a `whole disk' partition.
+Do not start a partition that actually uses its first sector
+(like a swap partition) at cylinder 0, since that will
+destroy the disklabel.
+
+An IRIX/SGI type disklabel can describe 16 partitions,
+the eleventh of which should be an entire `volume' partition,
+while the ninth should be labeled `volume header'.
+The volume header will also cover the partition table, i.e.,
+it starts at block zero and extends by default over five cylinders.
+The remaining space in the volume header may be used by header
+directory entries.  No partitions may overlap with the volume header.
+Also do not change its type and make some file system on it, since
+you will lose the partition table.  Use this type of label only when
+working with Linux on IRIX/SGI machines or IRIX/SGI disks under Linux.
+
+A DOS type partition table can describe an unlimited number
+of partitions. In sector 0 there is room for the description
+of 4 partitions (called `primary'). One of these may be an
+extended partition; this is a box holding logical partitions,
+with descriptors found in a linked list of sectors, each
+preceding the corresponding logical partitions.
+The four primary partitions, present or not, get numbers 1-4.
+Logical partitions start numbering from 5.
+
+In a DOS type partition table the starting offset and the size
+of each partition is stored in two ways: as an absolute number
+of sectors (given in 32 bits) and as a Cylinders/Heads/Sectors
+triple (given in 10+8+6 bits). The former is OK - with 512-byte
+sectors this will work up to 2 TB. The latter has two different
+problems. First of all, these C/H/S fields can be filled only
+when the number of heads and the number of sectors per track
+are known. Secondly, even if we know what these numbers should be,
+the 24 bits that are available do not suffice.
+DOS uses C/H/S only, Windows uses both, Linux never uses C/H/S.
+
+If possible,
+.B pmac-fdisk
+will obtain the disk geometry automatically.  This is not
+necessarily the physical disk geometry (indeed, modern disks do not
+really have anything like a physical geometry, certainly not something
+that can be described in simplistic Cylinders/Heads/Sectors form),
+but is the disk geometry that MS-DOS uses for the partition table.
+
+Usually all goes well by default, and there are no problems if
+Linux is the only system on the disk. However, if the disk has
+to be shared with other operating systems, it is often a good idea
+to let an fdisk from another operating system make at least one
+partition. When Linux boots it looks at the partition table, and
+tries to deduce what (fake) geometry is required for good
+cooperation with other systems.
+
+Whenever a partition table is printed out, a consistency check is performed
+on the partition table entries.  This check verifies that the physical and
+logical start and end points are identical, and that the partition starts
+and ends on a cylinder boundary (except for the first partition).
+
+Some versions of MS-DOS create a first partition which does not begin
+on a cylinder boundary, but on sector 2 of the first cylinder.
+Partitions beginning in cylinder 1 cannot begin on a cylinder boundary, but
+this is unlikely to cause difficulty unless you have OS/2 on your machine.
+
+A sync() and a BLKRRPART ioctl() (reread partition table from disk)
+are performed before exiting when the partition table has been updated.
+Long ago it used to be necessary to reboot after the use of pmac-fdisk.
+I do not think this is the case anymore - indeed, rebooting too quickly
+might cause loss of not-yet-written data. Note that both the kernel
+and the disk hardware may buffer data.
+
+.SH "DOS 6.x WARNING"
+
+The DOS 6.x FORMAT command looks for some information in the first
+sector of the data area of the partition, and treats this information
+as more reliable than the information in the partition table.  DOS
+FORMAT expects DOS FDISK to clear the first 512 bytes of the data area
+of a partition whenever a size change occurs.  DOS FORMAT will look at
+this extra information even if the /U flag is given -- we consider
+this a bug in DOS FORMAT and DOS FDISK.
+
+The bottom line is that if you use pmac-fdisk to change the size of a
+DOS partition table entry, then you must also use
+.B dd
+to zero the first 512 bytes of that partition before using DOS FORMAT to
+format the partition.  For example, if you were using pmac-fdisk to make a 
+DOS partition table entry for /dev/hda1, then (after exiting pmac-fdisk 
+and rebooting Linux so that the partition table information is valid) you
+would use the command "dd if=/dev/zero of=/dev/hda1 bs=512 count=1" to zero
+the first 512 bytes of the partition.
+
+.B BE EXTREMELY CAREFUL
+if you use the
+.B dd
+command, since a small typo can make all of the data on your disk useless.
+
+For best results, you should always use an OS-specific partition table
+program.  For example, you should make DOS partitions with the DOS FDISK
+program and Linux partitions with the Linux pmac-fdisk program.
+
+.SH OPTIONS
+.TP
+.B \-v
+Print version number of
+.B pmac-fdisk
+program and exit.
+.TP
+.B \-l
+List the partition tables for
+.BR /dev/hd[a-d] ,
+.BR /dev/sd[a-h] ,
+and then exit.
+.TP
+.B \-u
+When listing partition tables, give sizes in sectors instead
+of cylinders.
+.TP
+.BI "\-s " partition
+The
+.I size
+of the partition (in blocks) is printed on the standard output.
+.SH BUGS
+There are several *fdisk programs around.
+Each has its problems and strengths.
+Try them in the order
+.BR cfdisk ,
+.BR pmac-fdisk ,
+.BR sfdisk .
+(Indeed,
+.B cfdisk
+is a beautiful program that has strict requirements on
+the partition tables it accepts, and produces high quality partition
+tables. Use it if you can. 
+.B pmac-fdisk
+is a buggy program that does fuzzy things - usually it happens to
+produce reasonable results. Its single advantage is that it has
+some support for BSD disk labels and other non-DOS partition tables.
+Avoid it if you can.
+.B sfdisk
+is for hackers only - the user interface is terrible, but it is
+more correct than pmac-fdisk and more powerful than both pmac-fdisk and cfdisk.
+Moreover, it can be used noninteractively.)
+.PP
+The IRIX/SGI type disklabel is currently not supported by the kernel.
+Moreover, IRIX/SGI header directories are not fully supported yet.
+.PP
+The option `dump partition table to file' is missing.
+.\" .SH AUTHORS
+.\" A. V. Le Blanc (LeBlanc@mcc.ac.uk)
+.\" Bernhard Fastenrath (fasten@informatik.uni-bonn.de)
+.\" Jakub Jelinek (jj@sunsite.mff.cuni.cz)
+.\" Andreas Neuper (ANeuper@GUUG.de)
+.\" and many others.
