diff -urN ntfsprogs-1.7.1.orig/include/layout.h ntfsprogs-1.7.1/include/layout.h
--- ntfsprogs-1.7.1.orig/include/layout.h	2003-02-06 08:24:56.000000000 -0700
+++ ntfsprogs-1.7.1/include/layout.h	2003-06-21 12:46:28.000000000 -0600
@@ -292,7 +292,7 @@
  */
 typedef struct {
 /*Ofs*/
-/*  0*/	NTFS_RECORD;		/* Usually the magic is "FILE". */
+/*  0*/	NTFS_RECORD m;		/* Usually the magic is "FILE". */
 /*  8*/	u64 lsn;		/* $LogFile sequence number for this record.
 				   Changed every time the record is modified. */
 /* 16*/	u16 sequence_number;	/* Number of times this mft record has been
@@ -1428,7 +1428,7 @@
  * ACCESS_ALLOWED_ACE, ACCESS_DENIED_ACE, SYSTEM_AUDIT_ACE, SYSTEM_ALARM_ACE
  */
 typedef struct {
-	ACE_HEADER;		/* The ACE header. */
+	ACE_HEADER header;	/* The ACE header. */
 	ACCESS_MASK mask;	/* Access mask associated with the ACE. */
 	SID sid;		/* The SID associated with the ACE. */
 } __attribute__ ((__packed__)) ACCESS_ALLOWED_ACE, ACCESS_DENIED_ACE,
@@ -1443,7 +1443,7 @@
 } OBJECT_ACE_FLAGS;
 
 typedef struct {
-	ACE_HEADER;		/* The ACE_HEADER. */
+	ACE_HEADER header;	/* The ACE_HEADER. */
 	ACCESS_MASK mask;	/* Access mask associated with the ACE. */
 	OBJECT_ACE_FLAGS flags;	/* Flags describing the object ACE. */
 	GUID object_type;
@@ -1692,7 +1692,7 @@
  * $SDS data stream and the second copy will be at offset 0x451d0.
  */
 typedef struct {
-	SECURITY_DESCRIPTOR_HEADER;	  /* The security descriptor header. */
+	SECURITY_DESCRIPTOR_HEADER header;  /* The security descriptor header. */
 	SECURITY_DESCRIPTOR_RELATIVE sid; /* The self-relative security
 					     descriptor. */
 } __attribute__ ((__packed__)) SDS_ENTRY;
@@ -1867,7 +1867,7 @@
  * index entries (INDEX_ENTRY structures), as described by the INDEX_HEADER.
  */
 typedef struct {
-/*  0*/	NTFS_RECORD;		/* Magic is "INDX". */
+/*  0*/	NTFS_RECORD m;		/* Magic is "INDX". */
 /*  8*/	s64 lsn;		/* $LogFile sequence number of the last
 				   modification of this index block. */
 /* 16*/	VCN index_block_vcn;	/* Virtual cluster number of the index block. */
@@ -2018,7 +2018,7 @@
  * NOTE: Before NTFS 3.0 only filename attributes were indexed.
  */
 typedef struct {
-/*  0*/ INDEX_ENTRY_HEADER;	/* The index entry header (see above). */
+/*  0*/ INDEX_ENTRY_HEADER header;	/* The index entry header (see above). */
 /* 16*/	union {		/* The key of the indexed attribute. NOTE: Only present
 			   if INDEX_ENTRY_END bit in flags is not set. NOTE: On
 			   NTFS versions before 3.0 the only valid key is the
@@ -2030,7 +2030,7 @@
 		GUID object_id;		/* $O index in FILE_Extend/$ObjId: The
 					   object_id of the mft record found in
 					   the data part of the index. */
-		REPARSE_INDEX_KEY;	/* $R index in FILE_Extend/$Reparse. */
+		REPARSE_INDEX_KEY key;	/* $R index in FILE_Extend/$Reparse. */
 		SID sid;		/* $O index in FILE_Extend/$Quota:
 					   SID of the owner of the user_id. */
 		u32 owner_id;		/* $Q index in FILE_Extend/$Quota:
diff -urN ntfsprogs-1.7.1.orig/include/mft.h ntfsprogs-1.7.1/include/mft.h
--- ntfsprogs-1.7.1.orig/include/mft.h	2003-02-06 08:24:56.000000000 -0700
+++ ntfsprogs-1.7.1/include/mft.h	2003-06-21 12:41:06.000000000 -0600
@@ -95,7 +95,7 @@
  */
 static __inline__ u32 ntfs_mft_record_get_data_size(const MFT_RECORD *m)
 {
-	if (!m || !ntfs_is_mft_record(m->magic))
+	if (!m || !ntfs_is_mft_record(m->m.magic))
 		return 0;
 	/* Get the number of used bytes and return it. */
 	return le32_to_cpu(m->bytes_in_use);
diff -urN ntfsprogs-1.7.1.orig/libntfs/dir.c ntfsprogs-1.7.1/libntfs/dir.c
--- ntfsprogs-1.7.1.orig/libntfs/dir.c	2003-02-06 08:24:56.000000000 -0700
+++ ntfsprogs-1.7.1/libntfs/dir.c	2003-06-21 12:53:45.000000000 -0600
@@ -114,18 +114,18 @@
 	 * Loop until we exceed valid memory (corruption case) or until we
 	 * reach the last entry.
 	 */
-	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {
+	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->header.length))) {
 		/* Bounds checks. */
 		if ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +
 				sizeof(INDEX_ENTRY_HEADER) > index_end ||
-				(u8*)ie + le16_to_cpu(ie->key_length) >
+				(u8*)ie + le16_to_cpu(ie->header.key_length) >
 				index_end)
 			goto put_err_out;
 		/*
 		 * The last entry cannot contain a name. It can however contain
 		 * a pointer to a child node in the B+tree so we just break out.
 		 */
-		if (ie->flags & INDEX_ENTRY_END)
+		if (ie->header.flags & INDEX_ENTRY_END)
 			break;
 		/*
 		 * We perform a case sensitive comparison and if that matches
@@ -143,7 +143,7 @@
 			 * We have a perfect match, so we don't need to care
 			 * about having matched imperfectly before.
 			 */
-			mref = le64_to_cpu(ie->indexed_file);
+			mref = le64_to_cpu(ie->header.indexed_file);
 			ntfs_attr_put_search_ctx(ctx);
 			return mref;
 		}
@@ -169,7 +169,7 @@
 						"linux-ntfs-dev@lists.sf.net.");
 				goto put_err_out;
 			}
-			mref = le64_to_cpu(ie->indexed_file);
+			mref = le64_to_cpu(ie->header.indexed_file);
 		}
 		/*
 		 * Not a perfect match, need to do full blown collation so we
@@ -215,7 +215,7 @@
 	 * ENOENT, unless we have got the mft reference of a matching name
 	 * cached in mref in which case return mref.
 	 */
-	if (!(ie->flags & INDEX_ENTRY_NODE)) {
+	if (!(ie->header.flags & INDEX_ENTRY_NODE)) {
 		ntfs_attr_put_search_ctx(ctx);
 		if (mref)
 			return mref;
@@ -251,7 +251,7 @@
 	}
 
 	/* Get the starting vcn of the index_block holding the child node. */
-	vcn = sle64_to_cpup((u8*)ie + le16_to_cpu(ie->length) - 8);
+	vcn = sle64_to_cpup((u8*)ie + le16_to_cpu(ie->header.length) - 8);
 
 descend_into_child_node:
 
@@ -300,11 +300,11 @@
 	 * loop until we exceed valid memory (corruption case) or until we
 	 * reach the last entry.
 	 */
-	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {
+	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->header.length))) {
 		/* Bounds check. */
 		if ((u8*)ie < (u8*)ia || (u8*)ie +
 				sizeof(INDEX_ENTRY_HEADER) > index_end ||
-				(u8*)ie + le16_to_cpu(ie->key_length) >
+				(u8*)ie + le16_to_cpu(ie->header.key_length) >
 				index_end) {
 			Dprintf("Index entry out of bounds in directory inode "
 					"0x%Lx.\n",
@@ -316,7 +316,7 @@
 		 * The last entry cannot contain a name. It can however contain
 		 * a pointer to a child node in the B+tree so we just break out.
 		 */
-		if (ie->flags & INDEX_ENTRY_END)
+		if (ie->header.flags & INDEX_ENTRY_END)
 			break;
 		/*
 		 * We perform a case sensitive comparison and if that matches
@@ -334,7 +334,7 @@
 			 * We have a perfect match, so we don't need to care
 			 * about having matched imperfectly before.
 			 */
-			mref = le64_to_cpu(ie->indexed_file);
+			mref = le64_to_cpu(ie->header.indexed_file);
 			ntfs_attr_close(ia_na);
 			ntfs_attr_put_search_ctx(ctx);
 			return mref;
@@ -361,7 +361,7 @@
 						"linux-ntfs-dev@lists.sf.net.");
 				goto close_err_out;
 			}
-			mref = le64_to_cpu(ie->indexed_file);
+			mref = le64_to_cpu(ie->header.indexed_file);
 		}
 		/*
 		 * Not a perfect match, need to do full blown collation so we
@@ -405,7 +405,7 @@
 	 * We have finished with this index buffer without success. Check for
 	 * the presence of a child node.
 	 */
-	if (ie->flags & INDEX_ENTRY_NODE) {
+	if (ie->header.flags & INDEX_ENTRY_NODE) {
 		if ((ia->index.flags & NODE_MASK) == LEAF_NODE) {
 			Dprintf("Index entry with child node found in a leaf "
 					"node in directory inode 0x%Lx.\n",
@@ -414,7 +414,7 @@
 			goto close_err_out;
 		}
 		/* Child node present, descend into it. */
-		vcn = sle64_to_cpup((u8*)ie + le16_to_cpu(ie->length) - 8);
+		vcn = sle64_to_cpup((u8*)ie + le16_to_cpu(ie->header.length) - 8);
 		if (vcn >= 0)
 			goto descend_into_child_node;
 		Dprintf("Negative child node vcn in directory inode 0x%Lx.\n",
@@ -499,7 +499,7 @@
 	else /* if (index_type == INDEX_TYPE_ROOT) */
 		*pos = (u8*)ie - (u8*)iu.ir;
 	/* Skip root directory self reference entry. */
-	if (MREF_LE(ie->indexed_file) == FILE_root)
+	if (MREF_LE(ie->header.indexed_file) == FILE_root)
 		return 0;
 	if (ie->key.file_name.file_attributes &
 			FILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT)
@@ -508,7 +508,7 @@
 		dt_type = NTFS_DT_REG;
 	return filldir(dirent, fn->file_name, fn->file_name_length,
 			fn->file_name_type, *pos,
-			le64_to_cpu(ie->indexed_file), dt_type);
+			le64_to_cpu(ie->header.indexed_file), dt_type);
 }
 
 /**
@@ -713,16 +713,16 @@
 	 * reach the last entry or until filldir tells us it has had enough
 	 * or signals an error (both covered by the rc test).
 	 */
-	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {
+	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->header.length))) {
 		Dprintf("In index root, offset 0x%x.\n", (u8*)ie - (u8*)ir);
 		/* Bounds checks. */
 		if ((u8*)ie < (u8*)ctx->mrec || (u8*)ie +
 				sizeof(INDEX_ENTRY_HEADER) > index_end ||
-				(u8*)ie + le16_to_cpu(ie->key_length) >
+				(u8*)ie + le16_to_cpu(ie->header.key_length) >
 				index_end)
 			goto dir_err_out;
 		/* The last entry cannot contain a name. */
-		if (ie->flags & INDEX_ENTRY_END)
+		if (ie->header.flags & INDEX_ENTRY_END)
 			break;
 		/* Skip index root entry if continuing previous readdir. */
 		if (ir_pos > (u8*)ie - (u8*)ir)
@@ -863,13 +863,13 @@
 	 * reach the last entry or until ntfs_filldir tells us it has had
 	 * enough or signals an error (both covered by the rc test).
 	 */
-	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->length))) {
+	for (;; ie = (INDEX_ENTRY*)((u8*)ie + le16_to_cpu(ie->header.length))) {
 		Dprintf("In index allocation, offset 0x%Lx.\n",
 				(long long)ia_start + ((u8*)ie - (u8*)ia));
 		/* Bounds checks. */
 		if ((u8*)ie < (u8*)ia || (u8*)ie +
 				sizeof(INDEX_ENTRY_HEADER) > index_end ||
-				(u8*)ie + le16_to_cpu(ie->key_length) >
+				(u8*)ie + le16_to_cpu(ie->header.key_length) >
 				index_end) {
 			Dprintf("Index entry out of bounds in directory inode "
 					"0x%Lx.\n",
@@ -877,7 +877,7 @@
 			goto dir_err_out;
 		}
 		/* The last entry cannot contain a name. */
-		if (ie->flags & INDEX_ENTRY_END)
+		if (ie->header.flags & INDEX_ENTRY_END)
 			break;
 		/* Skip index entry if continuing previous readdir. */
 		if (ia_pos - ia_start > (u8*)ie - (u8*)ia)
diff -urN ntfsprogs-1.7.1.orig/libntfs/lcnalloc.c ntfsprogs-1.7.1/libntfs/lcnalloc.c
--- ntfsprogs-1.7.1.orig/libntfs/lcnalloc.c	2003-02-06 08:24:56.000000000 -0700
+++ ntfsprogs-1.7.1/libntfs/lcnalloc.c	2003-06-21 12:55:33.000000000 -0600
@@ -101,8 +101,8 @@
 	int err = 0, rlpos, rlsize, buf_size;
 	u8 pass, done_zones, search_zone, need_writeback, bit;
 
-	Dprintf("%s(): Entering with count = 0x%Lx, start_lcn = 0x%Lx,
-			zone = %s_ZONE.\n", (long long)count,
+	Dprintf("%s(): Entering with count = 0x%Lx, start_lcn = 0x%Lx,"
+			"zone = %s_ZONE.\n", (long long)count,
 			(long long)start_lcn,
 			zone == MFT_ZONE ? "MFT" : "DATA");
 	if (!vol || count < 0 || start_lcn < -1 || !vol->lcnbmp_na ||
diff -urN ntfsprogs-1.7.1.orig/libntfs/mft.c ntfsprogs-1.7.1/libntfs/mft.c
--- ntfsprogs-1.7.1.orig/libntfs/mft.c	2003-02-13 03:02:28.000000000 -0700
+++ ntfsprogs-1.7.1/libntfs/mft.c	2003-06-21 12:55:44.000000000 -0600
@@ -219,7 +219,7 @@
 		err = errno;
 		goto read_failed;
 	}
-	if (!ntfs_is_file_record(m->magic))
+	if (!ntfs_is_file_record(m->m.magic))
 		goto file_corrupt;
 	if (MSEQNO(mref) && MSEQNO(mref) != le16_to_cpu(m->sequence_number))
 		goto file_corrupt;
diff -urN ntfsprogs-1.7.1.orig/libntfs/volume.c ntfsprogs-1.7.1/libntfs/volume.c
--- ntfsprogs-1.7.1.orig/libntfs/volume.c	2003-02-06 08:24:56.000000000 -0700
+++ ntfsprogs-1.7.1/libntfs/volume.c	2003-06-21 12:56:05.000000000 -0600
@@ -126,12 +126,12 @@
 		Dperror("Error reading $MFT");
 		goto error_exit;
 	}
-	if (ntfs_is_baad_record(mb->magic)) {
+	if (ntfs_is_baad_record(mb->m.magic)) {
 		Dputs("Error: Incomplete multi sector transfer detected in "
 				"$MFT.");
 		goto io_error_exit;
 	}
-	if (!ntfs_is_mft_record(mb->magic)) {
+	if (!ntfs_is_mft_record(mb->m.magic)) {
 		Dputs("Error: $MFT has invalid magic.");
 		goto io_error_exit;
 	}
diff -urN ntfsprogs-1.7.1.orig/ntfsprogs/mkntfs.c ntfsprogs-1.7.1/ntfsprogs/mkntfs.c
--- ntfsprogs-1.7.1.orig/ntfsprogs/mkntfs.c	2003-02-10 05:00:47.000000000 -0700
+++ ntfsprogs-1.7.1/ntfsprogs/mkntfs.c	2003-06-21 13:07:41.000000000 -0600
@@ -867,12 +867,12 @@
 	MFT_REF r;
 
 	printf("-- Beginning dump of mft record. --\n");
-	u = le32_to_cpu(m->magic);
+	u = le32_to_cpu(m->m.magic);
 	printf("Mft record signature (magic) = %c%c%c%c\n", u & 0xff,
 			u >> 8 & 0xff, u >> 16 & 0xff, u >> 24 & 0xff);
-	u = le16_to_cpu(m->usa_ofs);
+	u = le16_to_cpu(m->m.usa_ofs);
 	printf("Update sequence array offset = %u (0x%x)\n", u, u);
-	printf("Update sequence array size = %u\n", le16_to_cpu(m->usa_count));
+	printf("Update sequence array size = %u\n", le16_to_cpu(m->m.usa_count));
 	printf("$LogFile sequence number (lsn) = %Lu\n", le64_to_cpu(m->lsn));
 	printf("Sequence number = %u\n", le16_to_cpu(m->sequence_number));
 	printf("Reference (hard link) count = %u\n",
@@ -915,14 +915,14 @@
 	ATTR_RECORD *a;
 
 	memset(m, 0, vol->mft_record_size);
-	m->magic = magic_FILE;
+	m->m.magic = magic_FILE;
 	/* Aligned to 2-byte boundary. */
-	m->usa_ofs = cpu_to_le16((sizeof(MFT_RECORD) + 1) & ~1);
+	m->m.usa_ofs = cpu_to_le16((sizeof(MFT_RECORD) + 1) & ~1);
 	if (vol->mft_record_size >= NTFS_SECTOR_SIZE)
-		m->usa_count = cpu_to_le16(vol->mft_record_size /
+		m->m.usa_count = cpu_to_le16(vol->mft_record_size /
 				NTFS_SECTOR_SIZE + 1);
 	else {
-		m->usa_count = cpu_to_le16(1);
+		m->m.usa_count = cpu_to_le16(1);
 		Qprintf("Sector size is bigger than MFT record size. Setting "
 			"usa_count to 1. If Windows\nchkdsk reports this as "
 			"corruption, please email linux-ntfs-dev@lists.sf.net\n"
@@ -935,8 +935,8 @@
 	m->sequence_number = cpu_to_le16(1);
 	m->link_count = cpu_to_le16(0);
 	/* Aligned to 8-byte boundary. */
-	m->attrs_offset = cpu_to_le16((le16_to_cpu(m->usa_ofs) +
-			(le16_to_cpu(m->usa_count) << 1) + 7) & ~7);
+	m->attrs_offset = cpu_to_le16((le16_to_cpu(m->m.usa_ofs) +
+			(le16_to_cpu(m->m.usa_count) << 1) + 7) & ~7);
 	m->flags = cpu_to_le16(0);
 	/*
 	 * Using attrs_offset plus eight bytes (for the termination attribute),
@@ -2077,13 +2077,13 @@
 		goto err_out;
 	}
 	/* Setup header. */
-	ia_val->magic = magic_INDX;
-	ia_val->usa_ofs = cpu_to_le16(sizeof(INDEX_ALLOCATION));
+	ia_val->m.magic = magic_INDX;
+	ia_val->m.usa_ofs = cpu_to_le16(sizeof(INDEX_ALLOCATION));
 	if (index_block_size >= NTFS_SECTOR_SIZE)
-		ia_val->usa_count = cpu_to_le16(index_block_size /
+		ia_val->m.usa_count = cpu_to_le16(index_block_size /
 				NTFS_SECTOR_SIZE + 1);
 	else {
-		ia_val->usa_count = cpu_to_le16(1);
+		ia_val->m.usa_count = cpu_to_le16(1);
 		Qprintf("Sector size is bigger than index block size. Setting "
 			"usa_count to 1. If Windows\nchkdsk reports this as "
 			"corruption, please email linux-ntfs-dev@lists.sf.net\n"
@@ -2091,23 +2091,23 @@
 			"system created was corrupt.\nThank you.");
 	}
 	/* Set USN to 1. */
-	*(u16*)((char*)ia_val + le16_to_cpu(ia_val->usa_ofs)) =
+	*(u16*)((char*)ia_val + le16_to_cpu(ia_val->m.usa_ofs)) =
 			cpu_to_le16(1);
 	ia_val->lsn = cpu_to_le64(0);
 	ia_val->index_block_vcn = cpu_to_le64(0);
 	ia_val->index.flags = LEAF_NODE;
 	/* Align to 8-byte boundary. */
 	ia_val->index.entries_offset = cpu_to_le32((sizeof(INDEX_HEADER) +
-			le16_to_cpu(ia_val->usa_count) * 2 + 7) & ~7);
+			le16_to_cpu(ia_val->m.usa_count) * 2 + 7) & ~7);
 	ia_val->index.allocated_size = cpu_to_le32(index_block_size -
 			(sizeof(INDEX_ALLOCATION) - sizeof(INDEX_HEADER)));
 	/* Find the last entry in the index root and save it in re. */
-	while ((char*)re < re_end && !(re->flags & INDEX_ENTRY_END)) {
+	while ((char*)re < re_end && !(re->header.flags & INDEX_ENTRY_END)) {
 		/* Next entry in index root. */
-		re = (INDEX_ENTRY*)((char*)re + le16_to_cpu(re->length));
+		re = (INDEX_ENTRY*)((char*)re + le16_to_cpu(re->header.length));
 	}
 	/* Copy all the entries including the termination entry. */
-	i = (char*)re - re_start + le16_to_cpu(re->length);
+	i = (char*)re - re_start + le16_to_cpu(re->header.length);
 	memcpy((char*)&ia_val->index +
 			le32_to_cpu(ia_val->index.entries_offset), re_start, i);
 	/* Finish setting up index allocation. */
@@ -2115,16 +2115,16 @@
 			le32_to_cpu(ia_val->index.entries_offset));
 	/* Move the termination entry forward to the beginning if necessary. */
 	if ((char*)re > re_start) {
-		memmove(re_start, (char*)re, le16_to_cpu(re->length));
+		memmove(re_start, (char*)re, le16_to_cpu(re->header.length));
 		re = (INDEX_ENTRY*)re_start;
 	}
 	/* Now fixup empty index root with pointer to index allocation VCN 0. */
 	r->index.flags = LARGE_INDEX;
-	re->flags |= INDEX_ENTRY_NODE;
-	if (le16_to_cpu(re->length) < sizeof(INDEX_ENTRY_HEADER) + sizeof(VCN))
-		re->length = cpu_to_le16(le16_to_cpu(re->length) + sizeof(VCN));
+	re->header.flags |= INDEX_ENTRY_NODE;
+	if (le16_to_cpu(re->header.length) < sizeof(INDEX_ENTRY_HEADER) + sizeof(VCN))
+		re->header.length = cpu_to_le16(le16_to_cpu(re->header.length) + sizeof(VCN));
 	r->index.index_length = cpu_to_le32(le32_to_cpu(r->index.entries_offset)
-			+ le16_to_cpu(re->length));
+			+ le16_to_cpu(re->header.length));
 	r->index.allocated_size = r->index.index_length;
 	/* Resize index root attribute. */
 	if (ntfs_resident_attr_value_resize(m, a, sizeof(INDEX_ROOT) -
@@ -2136,7 +2136,7 @@
 		goto err_out;
 	}
 	/* Set VCN pointer to 0LL. */
-	*(VCN*)((char*)re + cpu_to_le16(re->length) - sizeof(VCN)) =
+	*(VCN*)((char*)re + cpu_to_le16(re->header.length) - sizeof(VCN)) =
 			cpu_to_le64(0);
 	err = ntfs_mst_pre_write_fixup((NTFS_RECORD*)ia_val, index_block_size);
 	if (err) {
@@ -2243,7 +2243,7 @@
 	 * Loop until we exceed valid memory (corruption case) or until we
 	 * reach the last entry.
 	 */
-	while ((char*)ie < index_end && !(ie->flags & INDEX_ENTRY_END)) {
+	while ((char*)ie < index_end && !(ie->header.flags & INDEX_ENTRY_END)) {
 /*
 #ifdef DEBUG
 		Dprintf("file_name_attr1->file_name_length = %i\n",
@@ -2323,7 +2323,7 @@
 			break;
 		}
 #endif
-		ie = (INDEX_ENTRY*)((char*)ie + le16_to_cpu(ie->length));
+		ie = (INDEX_ENTRY*)((char*)ie + le16_to_cpu(ie->header.length));
 	};
 	i = (sizeof(INDEX_ENTRY_HEADER) + file_name_size + 7) & ~7;
 	err = make_room_for_index_entry_in_index_block(index, ie, i);
@@ -2333,11 +2333,11 @@
 		return err;
 	}
 	/* Create entry in place and copy file name attribute value. */
-	ie->indexed_file = file_ref;
-	ie->length = cpu_to_le16(i);
-	ie->key_length = cpu_to_le16(file_name_size);
-	ie->flags = cpu_to_le16(0);
-	ie->reserved = cpu_to_le16(0);
+	ie->header.indexed_file = file_ref;
+	ie->header.length = cpu_to_le16(i);
+	ie->header.key_length = cpu_to_le16(file_name_size);
+	ie->header.flags = cpu_to_le16(0);
+	ie->header.reserved = cpu_to_le16(0);
 	memcpy((char*)&ie->key.file_name, (char*)file_name, file_name_size);
 	return 0;
 }
@@ -3525,7 +3525,7 @@
 		 * $MFTMirr to have the exact same byte by byte content as
 		 * $MFT, rather than just equivalent meaning content.
 		 */
-		usnp = (u16*)((char*)m + le16_to_cpu(m->usa_ofs));
+		usnp = (u16*)((char*)m + le16_to_cpu(m->m.usa_ofs));
 		usn = le16_to_cpup(usnp);
 		if (usn-- <= 1)
 			usn = 0xfffe;
diff -urN ntfsprogs-1.7.1.orig/ntfsprogs/sd.c ntfsprogs-1.7.1/ntfsprogs/sd.c
--- ntfsprogs-1.7.1.orig/ntfsprogs/sd.c	2003-02-10 05:00:47.000000000 -0700
+++ ntfsprogs-1.7.1/ntfsprogs/sd.c	2003-06-21 12:57:52.000000000 -0600
@@ -76,12 +76,12 @@
 	 * ACE of the DACL. The type of the ACE is access allowed.
 	 */
 	aa_ace = (ACCESS_ALLOWED_ACE*)((char*)acl + sizeof(ACL));
-	aa_ace->type = ACCESS_ALLOWED_ACE_TYPE;
+	aa_ace->header.type = ACCESS_ALLOWED_ACE_TYPE;
 	if (sys_file_no == FILE_root)
-		aa_ace->flags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
+		aa_ace->header.flags = CONTAINER_INHERIT_ACE | OBJECT_INHERIT_ACE;
 	else
-		aa_ace->flags = 0;
-	aa_ace->size = cpu_to_le16(0x14);
+		aa_ace->header.flags = 0;
+	aa_ace->header.size = cpu_to_le16(0x14);
 	switch (sys_file_no) {
 	case FILE_MFT:		case FILE_MFTMirr:	case FILE_LogFile:
 	case FILE_AttrDef:	case FILE_Bitmap:	case FILE_Boot:
@@ -130,10 +130,10 @@
 	if (sys_file_no != FILE_root) {
 		/* The second ACE of the DACL. Type is access allowed. */
 		aa_ace = (ACCESS_ALLOWED_ACE*)((char*)aa_ace +
-				le16_to_cpu(aa_ace->size));
-		aa_ace->type = ACCESS_ALLOWED_ACE_TYPE;
-		aa_ace->flags = 0;
-		aa_ace->size = cpu_to_le16(0x18);
+				le16_to_cpu(aa_ace->header.size));
+		aa_ace->header.type = ACCESS_ALLOWED_ACE_TYPE;
+		aa_ace->header.flags = 0;
+		aa_ace->header.size = cpu_to_le16(0x18);
 		switch (sys_file_no) {
 		case FILE_MFT:		case FILE_MFTMirr:
 		case FILE_LogFile:	case FILE_AttrDef:
