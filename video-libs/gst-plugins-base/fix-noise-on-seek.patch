Index: gst-libs/gst/audio/gstbaseaudiosink.c
===================================================================
RCS file: /cvs/gstreamer/gst-plugins-base/gst-libs/gst/audio/gstbaseaudiosink.c,v
retrieving revision 1.48
diff -u -r1.48 gstbaseaudiosink.c
--- gst-libs/gst/audio/gstbaseaudiosink.c	2 Feb 2006 18:18:31 -0000	1.48
+++ gst-libs/gst/audio/gstbaseaudiosink.c	11 Feb 2006 14:04:59 -0000
@@ -454,10 +454,11 @@
 gst_base_audio_sink_render (GstBaseSink * bsink, GstBuffer * buf)
 {
   guint64 render_offset, in_offset;
-  GstClockTime time, stop, render_time, duration;
+  GstClockTime time, render_time, duration;
+  GstClockTimeDiff render_diff;
   GstBaseAudioSink *sink;
   GstRingBuffer *ringbuf;
-  gint64 diff, ctime, cstop;
+  gint64 diff;
   guint8 *data;
   guint size;
   guint samples, written;
@@ -469,11 +470,6 @@
 
   sink = GST_BASE_AUDIO_SINK (bsink);
 
-  if (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT)) {
-    /* always resync after a discont */
-    sink->next_sample = -1;
-  }
-
   ringbuf = sink->ringbuffer;
 
   /* can't do anything when we don't have the device */
@@ -501,80 +497,57 @@
    * sample ASAP */
   if (!GST_CLOCK_TIME_IS_VALID (time) || !bsink->sync) {
     render_offset = gst_base_audio_sink_get_offset (sink);
-    stop = -1;
     GST_DEBUG_OBJECT (sink,
         "Buffer of size %u has no time. Using render_offset=%" G_GUINT64_FORMAT,
         GST_BUFFER_SIZE (buf), render_offset);
     goto no_sync;
   }
 
+  render_diff = time - bsink->segment.start;
+  
   /* samples should be rendered based on their timestamp. All samples
-   * arriving before the segment.start or after segment.stop are to be 
-   * thrown away. All samples should also be clipped to the segment 
-   * boundaries */
-  /* let's calc stop based on the number of samples in the buffer instead
-   * of trusting the DURATION */
-  stop =
-      time + gst_util_uint64_scale_int (samples, GST_SECOND,
-      ringbuf->spec.rate);
-  if (!gst_segment_clip (&bsink->segment, GST_FORMAT_TIME, time, stop, &ctime,
-          &cstop))
+   * arriving before the segment.start are to be thrown away */
+  /* FIXME, for now we drop the sample completely, we should
+   * in fact clip the sample. Same for segment.stop, actually. */
+  if (render_diff < 0)
     goto out_of_segment;
 
-  /* see if some clipping happened */
-  diff = ctime - time;
-  if (diff > 0) {
-    diff = gst_util_uint64_scale_int (diff, ringbuf->spec.rate, GST_SECOND);
-    GST_DEBUG_OBJECT (sink, "clipping start to %" GST_TIME_FORMAT " %"
-        G_GUINT64_FORMAT " samples", GST_TIME_ARGS (ctime), diff);
-    samples -= diff;
-    data += samples * bps;
-    time = ctime;
-  }
-  diff = stop - cstop;
-  if (diff > 0) {
-    diff = gst_util_uint64_scale_int (diff, ringbuf->spec.rate, GST_SECOND);
-    GST_DEBUG_OBJECT (sink, "clipping stop to %" GST_TIME_FORMAT " %"
-        G_GUINT64_FORMAT " samples", GST_TIME_ARGS (cstop), diff);
-    samples -= diff;
-    stop = cstop;
-  }
-
   gst_clock_get_calibration (sink->provided_clock, &cinternal, &cexternal,
       &crate_num, &crate_denom);
 
-  /* bring buffer timestamp to running time */
-  render_time =
-      gst_segment_to_running_time (&bsink->segment, GST_FORMAT_TIME, time);
+  /* bring buffer timestamp to stream time */
+  render_time = render_diff;
+  /* adjust for rate */
+  render_time /= ABS (bsink->segment.rate);
+  /* adjust for accumulated segments */
+  render_time += bsink->segment.accum;
   /* add base time to get absolute clock time */
   render_time +=
       (gst_element_get_base_time (GST_ELEMENT_CAST (bsink)) - cexternal) +
       cinternal;
   /* and bring the time to the offset in the buffer */
-  render_offset =
-      gst_util_uint64_scale_int (render_time, ringbuf->spec.rate, GST_SECOND);
+  render_offset = render_time * ringbuf->spec.rate / GST_SECOND;
 
   GST_DEBUG_OBJECT (sink, "render time %" GST_TIME_FORMAT
       ", render offset %llu, samples %lu",
       GST_TIME_ARGS (render_time), render_offset, samples);
 
   /* roundoff errors in timestamp conversion */
-  if (sink->next_sample != -1) {
+  if (sink->next_sample != -1)
     diff = ABS ((gint64) render_offset - (gint64) sink->next_sample);
+  else
+    diff = ringbuf->spec.rate;
 
-    /* we tollerate a 10th of a second diff before we start resyncing. This
-     * should be enough to compensate for various rounding errors in the timestamp
-     * and sample offset position. We always resync if we got a discont anyway. */
-    if (diff < ringbuf->spec.rate / DIFF_TOLERANCE) {
-      GST_DEBUG_OBJECT (sink,
-          "align with prev sample, %" G_GINT64_FORMAT " < %lu", diff,
-          ringbuf->spec.rate / DIFF_TOLERANCE);
-      /* just align with previous sample then */
-      render_offset = sink->next_sample;
-    } else {
-      GST_DEBUG_OBJECT (sink,
-          "resync after discont with previous sample of diff: %lu", diff);
-    }
+
+  /* we tollerate a 10th of a second diff before we start resyncing. This
+   * should be enough to compensate for various rounding errors in the timestamp
+   * and sample offset position. We always resync if we got a discont anyway. */
+  if (diff < ringbuf->spec.rate / DIFF_TOLERANCE) {
+    GST_DEBUG_OBJECT (sink,
+        "align with prev sample, %" G_GINT64_FORMAT " < %lu", diff,
+        ringbuf->spec.rate / DIFF_TOLERANCE);
+    /* just align with previous sample then */
+    render_offset = sink->next_sample;
   } else {
     GST_DEBUG_OBJECT (sink, "resync after discont");
   }
@@ -587,7 +560,7 @@
 
 no_sync:
   /* clip length based on rate */
-  samples = MIN (samples, samples / (crate * bsink->segment.abs_rate));
+  samples = MIN (samples, samples / (crate * ABS (bsink->segment.rate)));
 
   /* the next sample should be current sample and its length */
   sink->next_sample = render_offset + samples;
@@ -614,7 +587,7 @@
     data += written * bps;
   } while (TRUE);
 
-  if (GST_CLOCK_TIME_IS_VALID (stop) && stop >= bsink->segment.stop) {
+  if (GST_CLOCK_TIME_IS_VALID (time) && time + duration >= bsink->segment.stop) {
     GST_DEBUG_OBJECT (sink,
         "start playback because we are at the end of segment");
     gst_ring_buffer_start (ringbuf);
