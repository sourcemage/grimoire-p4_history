--- dbdimp.c.orig	2003-09-08 16:18:30.000000000 +0200
+++ dbdimp.c	2003-09-08 16:19:04.000000000 +0200
@@ -2064,75 +2064,6 @@
     strcpy(imp_sth->proc, tok);
     free(buff);
     return 1;
-
-
-/* ahem. this stuff really doesn't work yet */
-#if 0
-    char buff[256];
-    char *db = "";
-    char *owner = "dbo";
-    char *proc;
-    char *p, *q;
-
-    char sql[256];  /* When this stuff does work, make this a char *sql and dynamically allocate/size/deallocate it */
-
-    /* statement should be in the form
-       exec db.owner.proc ...
-       db and owner are both optional */
-    
-    strncpy(statement, buff, 255);
-    p = &buff[0];
-    while(isspace(*p) && *p)
-	++p;
-    while(!isspace(*p) && *p)
-	++p;			/* skip over exec(ute) */
-    while(isspace(*p) && *p)
-	++p;			/* skip over any additional space... */
-    /* now put a \0 byte at the end of the proc name */
-    q = p;
-    while(!isspace(*q) && *q)
-	++q;
-    *q = 0;
-    /* if there is no . then we have the proc name... */
-    if(!(q = strchr(p, '.'))) {
-	proc = p;
-	db = "";
-	owner = "dbo";
-    } else {
-	*q++ = 0;
-	db = p;
-	p = q;
-	if((q = strchr(p, '.'))) {
-	    *q++ = 0;
-	    owner = p;
-	    proc = q;
-	}
-	if(!*owner)
-	    owner = "dbo";
-    }
-    PerlIO_printf(DBILOGFP, " describe_proc: %s %s %s\n", db, owner, proc);
-
-    if(db && *db) {
-	sprintf(sql, "
-select c.colid, c.name, c.usertype, c.prec, c.scale 
- from %s..sysobjects o, %s..syscolumns c, %s..sysusers u
- where c.id = o.id 
-   and o.name = '%s'
-   and o.type = 'P'
-   and o.uid = u.uid
-   and u.name = '%s'
-", db, db, db, proc, owner);
-    } else {
-	sprintf(sql, "
-select c.colid, c.name, c.usertype, c.prec, c.scale 
- from sysobjects o, syscolumns c
- where c.id = o.id 
-   and o.name = '%s'
-   and o.type = 'P'
-   and o.uid = user_id(u.uid
-   and u.name = '%s'", proc, owner);
-    }
-#endif    
 }
 
 int      syb_st_rows(sth, imp_sth)
