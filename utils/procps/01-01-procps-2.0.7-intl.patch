diff -u --recursive procps-2.0.7-orig/proc/sysinfo.c procps-2.0.7-hacked/proc/sysinfo.c
--- procps-2.0.7-orig/proc/sysinfo.c	Mon Jul 10 20:36:13 2000
+++ procps-2.0.7-hacked/proc/sysinfo.c	Wed Nov 29 23:11:41 2000
@@ -13,6 +13,8 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
+#include <locale.h>
+#include <assert.h>
 
 #include <unistd.h>
 #include <fcntl.h>
@@ -62,12 +64,19 @@
 /***********************************************************************/
 int uptime(double *uptime_secs, double *idle_secs) {
     double up=0, idle=0;
+    char*numeric=setlocale(LC_NUMERIC,0);
+    /* It is necessary to save and restore the numeric locale, because
+    if the locale we're in happens to use , instead of decimal point,
+    we can't sscanf the values in /proc/uptime */
+    setlocale(LC_NUMERIC,"C");
 
     FILE_TO_BUF(UPTIME_FILE,uptime_fd);
     if (sscanf(buf, "%lf %lf", &up, &idle) < 2) {
 	fprintf(stderr, "bad data in " UPTIME_FILE "\n");
 	return 0;
     }
+    setlocale(LC_NUMERIC,numeric);
+
     SET_IF_DESIRED(uptime_secs, up);
     SET_IF_DESIRED(idle_secs, idle);
     return up;	/* assume never be zero seconds in practice */
@@ -171,12 +180,20 @@
 /***********************************************************************/
 int loadavg(double *av1, double *av5, double *av15) {
     double avg_1=0, avg_5=0, avg_15=0;
+    /* It is necessary to save and restore the numeric locale, because
+    if the locale we're in happens to use , instead of decimal point,
+    we can't sscanf the values in /proc/loadavg */
+    char*numeric=setlocale(LC_NUMERIC,0);
+    setlocale(LC_NUMERIC,"C");
     
     FILE_TO_BUF(LOADAVG_FILE,loadavg_fd);
     if (sscanf(buf, "%lf %lf %lf", &avg_1, &avg_5, &avg_15) < 3) {
 	fprintf(stderr, "bad data in " LOADAVG_FILE "\n");
 	exit(1);
+
     }
+    setlocale(LC_NUMERIC,numeric);
+    
     SET_IF_DESIRED(av1,  avg_1);
     SET_IF_DESIRED(av5,  avg_5);
     SET_IF_DESIRED(av15, avg_15);


