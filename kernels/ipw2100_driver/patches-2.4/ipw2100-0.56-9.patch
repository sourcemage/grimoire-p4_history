diff -u -p -r -b ipw2100-0.56-0/Makefile ipw2100-0.56-9/Makefile
--- ipw2100-0.56-0/Makefile	2004-11-05 14:08:26.000000000 +0100
+++ ipw2100-0.56-9/Makefile	2004-11-04 22:53:44.000000000 +0100
@@ -206,6 +206,8 @@ modules:
 
 endif # End 2.4 / 2.6 specific
 
+ifeq ($(OLDMAKE),)
+
 install: modules
 	install -d $(KMISC)
 	install -m 644 -c $(addsuffix .ko,$(list-m)) $(KMISC)
@@ -222,6 +224,25 @@ uninstall:
 	rm -rf $(addprefix $(KMISC),$(addsuffix .ko,$(list-m)))
 	/sbin/depmod -a
 
+else
+
+install: modules
+	install -d $(KMISC)
+	install -m 644 -c $(addsuffix .o,$(list-m)) $(KMISC)
+	/sbin/depmod -a
+ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	@echo "Don't forget to copy firmware to /etc/firmware/."
+else
+	@echo "Don't forget to copy firmware to /usr/lib/hotplug/firmware/ "
+endif
+	@echo "See INSTALL for more information."
+
+uninstall:
+	rm -rf $(addprefix $(KMISC),$(addsuffix .o,$(list-m)))
+	/sbin/depmod -a
+
+endif
+
 endif # End of internal build
 
 
diff -u -p -r -b ipw2100-0.56-0/ieee80211.h ipw2100-0.56-9/ieee80211.h
--- ipw2100-0.56-0/ieee80211.h	2004-10-13 21:06:57.000000000 +0200
+++ ipw2100-0.56-9/ieee80211.h	2004-11-04 21:25:43.000000000 +0100
@@ -828,4 +828,9 @@ static inline const char *escape_essid(c
 	*d = '\0';
 	return escaped;
 }
+
+#ifndef offset_in_page
+#define offset_in_page(p) ((unsigned long)(p) & ~PAGE_MASK)
+#endif
+
 #endif /* IEEE80211_H */
diff -u -p -r -b ipw2100-0.56-0/ieee80211_crypt.c ipw2100-0.56-9/ieee80211_crypt.c
--- ipw2100-0.56-0/ieee80211_crypt.c	2004-10-13 21:06:57.000000000 +0200
+++ ipw2100-0.56-9/ieee80211_crypt.c	2004-11-04 21:25:43.000000000 +0100
@@ -55,7 +55,11 @@ void ieee80211_crypt_deinit_entries(stru
 
 		if (entry->ops) {
 			entry->ops->deinit(entry->priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			if (entry->ops->owner) __MOD_DEC_USE_COUNT(entry->ops->owner);
+#else
 			module_put(entry->ops->owner);
+#endif
 		}
 		kfree(entry);
 	}
diff -u -p -r -b ipw2100-0.56-0/ieee80211_module.c ipw2100-0.56-9/ieee80211_module.c
--- ipw2100-0.56-0/ieee80211_module.c	2004-10-13 21:06:57.000000000 +0200
+++ ipw2100-0.56-9/ieee80211_module.c	2004-11-04 21:25:43.000000000 +0100
@@ -39,7 +39,9 @@
 #include <linux/ip.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 #include <linux/moduleparam.h>
+#endif
 #include <linux/netdevice.h>
 #include <linux/pci.h>
 #include <linux/proc_fs.h>
@@ -156,7 +158,11 @@ void ieee80211_free(struct ieee80211_dev
 		if (crypt) {
 			if (crypt->ops) {
 				crypt->ops->deinit(crypt->priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+				if (crypt->ops->owner) __MOD_DEC_USE_COUNT(crypt->ops->owner);
+#else
 				module_put(crypt->ops->owner);
+#endif
 			}
 			kfree(crypt);
 			ieee->crypt[i] = NULL;
@@ -240,7 +246,12 @@ static void __exit ieee80211_exit(void)
 	}
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+MODULE_PARM(debug, "i");
+#else
 module_param(debug, int, 0444);
+#endif
+
 MODULE_PARM_DESC(debug, "debug output mask");
 
 
diff -u -p -r -b ipw2100-0.56-0/ieee80211_wx.c ipw2100-0.56-9/ieee80211_wx.c
--- ipw2100-0.56-0/ieee80211_wx.c	2004-10-13 21:06:57.000000000 +0200
+++ ipw2100-0.56-9/ieee80211_wx.c	2004-11-04 21:25:43.000000000 +0100
@@ -337,7 +337,11 @@ int ieee80211_wx_set_encode(struct ieee8
 			new_crypt->ops = ieee80211_get_crypto_ops("WEP");
 		}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		if (new_crypt->ops && new_crypt->ops->owner && __MOD_INC_USE_COUNT(new_crypt->ops->owner))
+#else
 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner)) 
+#endif
 			new_crypt->priv = new_crypt->ops->init(key);
 
 		if (!new_crypt->ops || !new_crypt->priv) {
diff -u -p -r -b ipw2100-0.56-0/ipw2100.c ipw2100-0.56-9/ipw2100.c
--- ipw2100-0.56-0/ipw2100.c	2004-10-13 21:06:57.000000000 +0200
+++ ipw2100-0.56-9/ipw2100.c	2004-11-05 16:02:14.000000000 +0100
@@ -147,6 +147,7 @@ TODO
 #include <linux/in.h>
 #include <linux/ip.h>
 #include <linux/kernel.h>
+#include <linux/kmod.h>
 #include <linux/module.h>
 #include <linux/netdevice.h>
 #include <linux/ethtool.h>
@@ -171,8 +172,13 @@ TODO
 
 #include "ipw2100.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define IPW2100_VERSION "0.56-9 (kernel 2.4)"
+#define IPW2100_VERSION "0.56-9 (kernel 2.4)"
+#else
 #define IPW2100_VERSION "0.56"
 #define IPW2100_VERSION "0.56"
+#endif
 
 #define DRV_NAME	"ipw2100"
 #define DRV_VERSION	IPW2100_VERSION
@@ -202,6 +208,14 @@ static int disable = 0;
 static struct ipw2100_fw ipw2100_firmware;
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+MODULE_PARM(debug, "i");
+MODULE_PARM(if_name, "s");
+MODULE_PARM(mode, "i");
+MODULE_PARM(channel, "i");
+MODULE_PARM(associate, "i");
+MODULE_PARM(disable, "i");
+#else
 #include <linux/moduleparam.h>
 module_param(debug, int, 0444);
 module_param(if_name, charp, 0444);
@@ -209,6 +223,7 @@ module_param(mode, int, 0444);
 module_param(channel, int, 0444);
 module_param(associate, int, 0444);
 module_param(disable, int, 0444);
+#endif
 
 MODULE_PARM_DESC(debug, "debug level");
 MODULE_PARM_DESC(if_name, "interface name (default 'eth%d')");
@@ -1188,7 +1203,12 @@ static int ipw2100_enable_adapter(struct
 
 	if (priv->stop_hang_check) {
 		priv->stop_hang_check = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		priv->hang_check_timer.expires = jiffies + 2 * HZ;
+		add_timer(&priv->hang_check_timer);
+#else
 		queue_delayed_work(priv->workqueue, &priv->hang_check, 2 * HZ);
+#endif
 	}
 
 	IPW_DEBUG_INFO("TODO: implement scan state machine\n");
@@ -1318,7 +1338,11 @@ static int ipw2100_disable_adapter(struc
 
 	if (!priv->stop_hang_check) {
 		priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->hang_check_timer);
+#else
 		cancel_delayed_work(&priv->hang_check);
+#endif
 	}
 
 	err = ipw2100_hw_send_command(priv, &cmd);
@@ -1407,7 +1431,12 @@ static int ipw2100_up(struct ipw2100_pri
 
 		if (priv->stop_rf_kill) {
 			priv->stop_rf_kill = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			priv->rf_kill_timer.expires = jiffies + HZ;
+			add_timer(&priv->rf_kill_timer);
+#else
 			queue_delayed_work(priv->workqueue, &priv->rf_kill, HZ);
+#endif
 		}
 		/* Since the RF switch is off, we will defer
 		 * the sending of the HOST_COMPLETE */
@@ -1464,18 +1493,28 @@ static void ipw2100_down(struct ipw2100_
 	/* Kill the RF switch timer */
 	if (!priv->stop_rf_kill) {
 		priv->stop_rf_kill = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->rf_kill_timer);
+#else
 		cancel_delayed_work(&priv->rf_kill);
+#endif
 	}
 	
 	/* Kill the firmare hang check timer */
 	if (!priv->stop_hang_check) {
 		priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->hang_check_timer);
+#else
 		cancel_delayed_work(&priv->hang_check);
+#endif
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	/* Kill any pending resets */
 	if (priv->reset_pending == 2) /* 1 == instant reset, 2 == scheduled */
 		cancel_delayed_work(&priv->reset_work);
+#endif
 
 	/* Make sure the interrupt is on so that FW commands will be 
 	 * processed correctly */
@@ -1499,6 +1538,14 @@ void ipw2100_reset_adapter(struct ipw210
 {
 	unsigned long flags;
 	spin_lock_irqsave(&priv->low_lock, flags);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (priv->reset_backoff) {
+		spin_unlock_irqrestore(&priv->low_lock, flags);
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(priv->reset_backoff * HZ);
+		spin_lock_irqsave(&priv->low_lock, flags);
+	}
+#endif
 	printk(KERN_INFO DRV_NAME ": %s: Restarting adapter.\n", 
 	       priv->ndev->name);
 	priv->resets++;
@@ -1660,7 +1707,12 @@ static void isr_indicate_rf_kill(struct 
 	 * the firmware if the switch is enabled */
 	if (priv->stop_rf_kill) {
 		priv->stop_rf_kill = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		priv->rf_kill_timer.expires = jiffies + HZ;
+		add_timer(&priv->rf_kill_timer);
+#else
 		queue_delayed_work(priv->workqueue, &priv->hang_check, HZ);
+#endif
 	}
 }
 
@@ -1813,8 +1865,12 @@ static inline void schedule_reset(struct
 			queue_work(priv->workqueue, &priv->reset_work);
 		} else {
 			priv->reset_pending = 2;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			queue_work(priv->workqueue, &priv->reset_work);
+#else
 			queue_delayed_work(priv->workqueue, &priv->reset_work, 
 					   priv->reset_backoff * HZ);
+#endif
 			if (priv->reset_backoff < MAX_RESET_BACKOFF)
 				priv->reset_backoff++;
 		}
@@ -3003,9 +3059,20 @@ static void ipw2100_msg_free(struct ipw2
 	priv->msg_buffers = NULL;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_pci(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	struct pci_dev *pdev = priv->pdev;
+	*eof = 1;
+#else
 static ssize_t show_pci(struct device *d, char *buf)
 {
 	struct pci_dev *pdev = container_of(d, struct pci_dev, dev);
+#endif
 	char * out = buf;
 	int i, j;
 	u32 val;
@@ -3202,10 +3269,21 @@ const struct {
 };
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_registers(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	int i;
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_registers(struct device *d, char *buf)
 {
 	int i;
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->ndev;
 	char * out = buf;
 	u32 val = 0;
@@ -3223,9 +3301,19 @@ static ssize_t show_registers(struct dev
 static DEVICE_ATTR(registers, S_IRUGO, show_registers, NULL);
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_hardware(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_hardware(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->ndev;
 	char * out = buf;
 	int i;
@@ -3263,9 +3351,18 @@ static ssize_t show_hardware(struct devi
 static DEVICE_ATTR(hardware, S_IRUGO, show_hardware, NULL);
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_memory(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t show_memory(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->ndev;
 	static unsigned long loop = 0;
 	int len = 0;
@@ -3273,11 +3370,25 @@ static ssize_t show_memory(struct device
 	int i;
 	char line[81];
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (offset == 0)
+		loop = 0;
+
+	if (loop >= 0x30000) {
+		*start = NULL;
+		*eof = 1;
+		return 0;
+	}
+
+	/* Return around 2k per pass... */
+	while (count - len > 256 && len < 2048 && loop < 0x30000) {
+#else
 	if (loop >= 0x30000)
 		loop = 0;
 
 	/* sysfs provides us PAGE_SIZE buffer */
 	while (len < PAGE_SIZE - 128 && loop < 0x30000) {
+#endif
 
 		if (priv->snapshot[0]) for (i = 0; i < 4; i++) 
 			buffer[i] = *(u32 *)SNAPSHOT_ADDR(loop + i * 4);
@@ -3313,12 +3424,35 @@ static ssize_t show_memory(struct device
 		loop += 16;
 	}
 	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (len) 
+		*start = (char*)len; 
+	else
+		*eof = 1;
+#endif	
 	return len;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_memory(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	char buf[] = "00000";
+	unsigned long len =
+	    (sizeof(buf) - 1) > count ? count : sizeof(buf) - 1;
+
+	if (copy_from_user(buf, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+	buf[len] = 0;
+#else
 static ssize_t store_memory(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->ndev;
 	const char *p = buf;
 
@@ -3352,20 +3486,44 @@ static ssize_t store_memory(struct devic
 static DEVICE_ATTR(memory, S_IWUSR|S_IRUGO, show_memory, store_memory);
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_ordinals(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t show_ordinals(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	u32 val = 0;
 	int len = 0;
 	u32 val_len;
 	static int loop = 0;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (offset == 0)
+		loop = 0;
+
+	if (loop >= (sizeof(ord_data) / sizeof(*ord_data))) {
+		*start = NULL;
+		*eof = 1;
+		return 0;
+	}
+
+	/* Return around 2k per pass... */
+	while (count - len > 256 && len < 2048 &&
+	       loop < (sizeof(ord_data) / sizeof(*ord_data))) {
+#else
 	if (loop >= sizeof(ord_data) / sizeof(*ord_data))
 		loop = 0;
 
 	/* sysfs provides us PAGE_SIZE buffer */
 	while (len < PAGE_SIZE - 128 &&
 	       loop < (sizeof(ord_data) / sizeof(*ord_data))) {
+#endif
 		
 		val_len = sizeof(u32);
 
@@ -3380,15 +3538,30 @@ static ssize_t show_ordinals(struct devi
 				       ord_data[loop].desc);
 		loop++;
 	}
-
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (len)
+		*start = (char*)len;
+	else
+		*eof = 1;
+#endif
 	return len;
 }
 static DEVICE_ATTR(ordinals, S_IRUGO, show_ordinals, NULL);
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_version(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_version(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char * out = buf;
 	char tmp[MAX_FW_VERSION_LEN];
 	int err;
@@ -3437,9 +3610,19 @@ static ssize_t show_version(struct devic
 static DEVICE_ATTR(version, S_IRUGO, show_version, NULL);
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_stats(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_stats(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char * out = buf;
 
 	out += sprintf(out, "interrupts: %d {tx: %d, rx: %d, other: %d}\n",
@@ -3553,9 +3736,19 @@ int ipw2100_switch_mode(struct ipw2100_p
 	return 0;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_internals(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_internals(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	int len = 0;
 
 #define DUMP_VAR(x,y) len += sprintf(buf + len, # x ": %" # y "\n", priv-> x)
@@ -3604,9 +3797,19 @@ static ssize_t show_internals(struct dev
 static DEVICE_ATTR(internals, S_IRUGO, show_internals, NULL);
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_bssinfo(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_bssinfo(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char essid[IW_ESSID_MAX_SIZE + 1];
 	u8 bssid[ETH_ALEN];
 	u32 chan = 0;
@@ -3647,9 +3850,19 @@ static ssize_t show_bssinfo(struct devic
 static DEVICE_ATTR(bssinfo, S_IRUGO, show_bssinfo, NULL);
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_txqueue(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_txqueue(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->ndev;
 	char * out = buf;
 	u32 tbdr_r, tbdr_w;
@@ -3676,9 +3889,19 @@ static ssize_t show_txqueue(struct devic
 static DEVICE_ATTR(txqueue, S_IRUGO, show_txqueue, NULL);
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_rxqueue(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_rxqueue(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->ndev;
 	char * out = buf;
 	u32 rbdr_r, rbdr_w;
@@ -3704,14 +3927,34 @@ static DEVICE_ATTR(rxqueue, S_IRUGO, sho
 
 
 #ifdef CONFIG_IPW_DEBUG
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_debug_level(char *buf, char **start, off_t offset,
+				int count, int *eof, void *data)
+#else
 static ssize_t show_debug_level(struct device_driver *d, char *buf)
+#endif
 {
 	return sprintf(buf, "0x%08X\n", ipw2100_debug_level);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_debug_level(struct file *file, const char *user_buffer,
+				unsigned long count, void *data)
+{
+	char buf[] = "0x00000000";
+	unsigned long len =
+	    (sizeof(buf) -1) > count ? count : sizeof(buf) - 1;
+
+	if (copy_from_user(buf, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+	buf[len] = 0;
+#else
 static ssize_t store_debug_level(struct device_driver *d, const char *buf,
 				 size_t count)
 {
+#endif
 	char *p = (char *)buf;
 	u32 val;
 
@@ -3728,16 +3971,28 @@ static ssize_t store_debug_level(struct 
 	else
 		ipw2100_debug_level = val;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return count;
+#else
 	return strnlen(buf, count);
+#endif
 }
 static DRIVER_ATTR(debug_level, S_IWUSR | S_IRUGO, show_debug_level,
 		   store_debug_level);
 #endif /* CONFIG_IPW_DEBUG */
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_fatal_error(char *buf, char **start, off_t offset,
+				int count, int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t show_fatal_error(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char * out = buf;
 	int errors = 0;
 	int i;
@@ -3778,19 +4033,37 @@ static ssize_t show_fatal_error(struct d
 	return out - buf;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_fatal_error(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *dev = data;
+	struct ipw2100_priv *priv = netdev_priv(dev);
+#else
 static ssize_t store_fatal_error(struct device *d, const char *buf,
 				 size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	schedule_reset(priv);
 	return count;
 }
 static DEVICE_ATTR(fatal_error, S_IWUSR|S_IRUGO, show_fatal_error, store_fatal_error);
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_cardmem(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_cardmem(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->ndev;
 	char * out = buf;
 	u32 dword;
@@ -3803,9 +4076,17 @@ static ssize_t show_cardmem(struct devic
 	return out - buf;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_cardmem(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t store_cardmem(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->ndev;
 	char buffer[] = "00000000";
 	unsigned long len =
@@ -3815,7 +4096,14 @@ static ssize_t store_cardmem(struct devi
 
 	IPW_DEBUG_INFO("enter\n");
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) 
+	if (copy_from_user(buffer, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+#else
 	strncpy(buffer, buf, len);
+#endif
 	buffer[len] = 0;
 
 	if (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {
@@ -3835,23 +4123,45 @@ static ssize_t store_cardmem(struct devi
 	}
 	
 	IPW_DEBUG_INFO("exit\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return count;
+#else
 	return len;
+#endif
 }
 static DEVICE_ATTR(cardmem, S_IWUSR | S_IRUGO, show_cardmem, store_cardmem);
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_scan_age(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_scan_age(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 
 	return sprintf(buf, "Scan entries will expire after %u missed scans. "
 		       "(default is %u, 0 = never expire)\n",
 		       priv->ieee->scan_age, DEFAULT_MAX_SCAN_AGE);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_scan_age(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t store_scan_age(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->ndev;
 	char buffer[] = "00000000";
 	unsigned long len =
@@ -3861,7 +4171,14 @@ static ssize_t store_scan_age(struct dev
 
 	IPW_DEBUG_INFO("enter\n");
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (copy_from_user(buffer, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+#else
 	strncpy(buffer, buf, len);
+#endif
 	buffer[len] = 0;
 
 	if (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {
@@ -3880,14 +4197,28 @@ static ssize_t store_scan_age(struct dev
 	}
 	
 	IPW_DEBUG_INFO("exit\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return count;
+#else
 	return len;
+#endif
 }
 static DEVICE_ATTR(scan_age, S_IWUSR | S_IRUGO, show_scan_age, store_scan_age);
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_rf_kill(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_rf_kill(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char * out = buf;
 	
 	if (priv->manual_disable) 
@@ -3903,13 +4234,30 @@ static ssize_t show_rf_kill(struct devic
 	return out - buf;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_rf_kill(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	char buf[] = "0";
+	unsigned long len =
+	    (sizeof(buf) - 1) > count ? count : sizeof(buf) - 1;
+#else
 static ssize_t store_rf_kill(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	int state;
 
 	IPW_DEBUG_INFO("enter\n");
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (copy_from_user(buf, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+#endif
 	sscanf(buf, "%d", &state);
 	switch (state) {
 	case 0: /* Turn off Manual Disable */
@@ -3948,6 +4296,7 @@ static ssize_t store_rf_kill(struct devi
 static DEVICE_ATTR(rf_kill, S_IWUSR|S_IRUGO, show_rf_kill, store_rf_kill);
 
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
 static struct attribute *ipw2100_sysfs_entries[] = {
 	&dev_attr_hardware.attr,
 	&dev_attr_registers.attr,
@@ -3970,6 +4319,7 @@ static struct attribute *ipw2100_sysfs_e
 static struct attribute_group ipw2100_attribute_group = {
 	.attrs = ipw2100_sysfs_entries,
 };
+#endif
 
 
 static int status_queue_allocate(struct ipw2100_priv *priv, int entries)
@@ -5984,7 +6334,11 @@ static int ipw2100_wpa_set_encryption(st
 		}
 		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
 		new_crypt->ops = ops;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		if (new_crypt->ops && new_crypt->ops->owner && __MOD_INC_USE_COUNT(new_crypt->ops->owner))
+#else
 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
+#endif
 			new_crypt->priv = new_crypt->ops->init(param->u.crypt.idx);
 
 		if (new_crypt->priv == NULL) {
@@ -6137,9 +6491,15 @@ static struct ethtool_ops ipw2100_ethtoo
     .get_link        = ipw2100_ethtool_get_link,
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void ipw2100_hang_check(unsigned long arg)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv *)arg;
+#else
 static void ipw2100_hang_check(void *adapter)
 {
 	struct ipw2100_priv *priv = adapter;
+#endif
 	unsigned long flags;
 	u32 rtc = 0xa5a5a5a5;
 	u32 len = sizeof(rtc);
@@ -6160,6 +6520,7 @@ static void ipw2100_hang_check(void *ada
 		       priv->ndev->name);
 
 		restart = 1;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	} else {
 		spin_unlock_irqrestore(&priv->low_lock, flags);
 		if (ipw2100_set_rts_threshold(priv, priv->rts_threshold)) {
@@ -6170,6 +6531,7 @@ static void ipw2100_hang_check(void *ada
 			restart = 1;
 		}
 		spin_lock_irqsave(&priv->low_lock, flags);
+#endif
 	}
 
 	if (restart) {
@@ -6185,15 +6547,25 @@ static void ipw2100_hang_check(void *ada
 
 	/* Check again in two seconds */
 	if (!priv->stop_hang_check)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		mod_timer(&priv->hang_check_timer, jiffies + HZ);
+#else
 		queue_delayed_work(priv->workqueue, &priv->hang_check, HZ);
+#endif
 
 	spin_unlock_irqrestore(&priv->low_lock, flags);
 }
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void ipw2100_rf_kill(unsigned long arg)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv *)arg;
+#else
 static void ipw2100_rf_kill(void *adapter)
 {
 	struct ipw2100_priv *priv = adapter;
+#endif
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->low_lock, flags);
@@ -6222,7 +6594,11 @@ static void ipw2100_rf_kill(void *adapte
 	
 	/* Check again in one second */
 	if (!priv->stop_rf_kill) 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		mod_timer(&priv->rf_kill_timer, jiffies + HZ);
+#else
 		queue_delayed_work(priv->workqueue, &priv->rf_kill, HZ);
+#endif
 
 	spin_unlock_irqrestore(&priv->low_lock, flags);
 }
@@ -6379,19 +6755,32 @@ static struct net_device *ipw2100_alloc_
 	INIT_STAT(&priv->fw_pend_stat);
 	
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	priv->workqueue = (void *)1;
+#else
 #ifdef CONFIG_SOFTWARE_SUSPEND2
 	priv->workqueue = create_workqueue(DRV_NAME, 0);
 #else
 	priv->workqueue = create_workqueue(DRV_NAME);
 #endif	
+#endif
 	INIT_WORK(&priv->reset_work, 
 		  (void (*)(void *))ipw2100_reset_adapter, priv);
 	INIT_WORK(&priv->security_work, 
 		  (void (*)(void *))ipw2100_security_work, priv);
 	INIT_WORK(&priv->wx_event_work,
 		  (void (*)(void *))ipw2100_wx_event_work, priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	init_timer(&priv->rf_kill_timer);
+	priv->rf_kill_timer.data = (unsigned long)priv;
+	priv->rf_kill_timer.function = ipw2100_rf_kill;
+	init_timer(&priv->hang_check_timer);
+	priv->hang_check_timer.data = (unsigned long)priv;
+	priv->hang_check_timer.function = ipw2100_hang_check;
+#else
 	INIT_WORK(&priv->hang_check, ipw2100_hang_check, priv);
 	INIT_WORK(&priv->rf_kill, ipw2100_rf_kill, priv);
+#endif
 
 	priv->wx_ap_event_pending = 0;
 	
@@ -6482,7 +6871,9 @@ static int ipw2100_pci_init_one(struct p
 		goto fail;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	SET_NETDEV_DEV(dev, &pdev->dev);
+#endif
 
 	/* begin initializing the hardware */
 	ipw2100_hw_disable_interrupt(priv);
@@ -6535,7 +6926,17 @@ static int ipw2100_pci_init_one(struct p
 	printk(KERN_INFO "%s: Bound to %s\n", dev->name, pci_name(pdev));
 
 	/* perform this after register_netdev so that dev->name is set */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	sysfs_create_group(&pdev->dev.kobj, &ipw2100_attribute_group);
+#else
+	err = ipw2100_proc_dev_init(priv);
+	if (err) {
+		printk(KERN_ERR
+		       "%s: Failed to create /proc node\n", dev->name);
+		err = -EIO;
+		goto fail;
+	}
+#endif
 	netif_carrier_off(dev);
 	
 	/* If the RF Kill switch is disabled, go ahead and complete the
@@ -6574,15 +6975,24 @@ static int ipw2100_pci_init_one(struct p
 		if (priv->workqueue) {
 			priv->stop_rf_kill = 1;
 			priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			del_timer_sync(&priv->hang_check_timer);
+			del_timer_sync(&priv->rf_kill_timer);
+#else
 			cancel_delayed_work(&priv->hang_check);
 			cancel_delayed_work(&priv->rf_kill);
 			destroy_workqueue(priv->workqueue);
+#endif
 			priv->workqueue = NULL;
 		}
 
 		/* These are safe to call even if they weren't allocated */
 		ipw2100_queues_free(priv);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 		sysfs_remove_group(&pdev->dev.kobj, &ipw2100_attribute_group);
+#else
+		ipw2100_proc_dev_cleanup(priv);
+#endif
 
 		free_netdev(dev);
 		pci_set_drvdata(pdev, NULL);
@@ -6604,7 +7014,11 @@ static void __devexit ipw2100_pci_remove
 
 	if (priv) {
 		dev = priv->ndev;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 		sysfs_remove_group(&pdev->dev.kobj, &ipw2100_attribute_group);
+#else
+		ipw2100_proc_dev_cleanup(priv);
+#endif
 
 #ifdef CONFIG_PM
 		if (ipw2100_firmware.version)
@@ -6622,9 +7036,14 @@ static void __devexit ipw2100_pci_remove
 		 * in the workqueue's, so we can safely remove them now. */
 		priv->stop_rf_kill = 1;
 		priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->hang_check_timer);
+		del_timer_sync(&priv->rf_kill_timer);
+#else
 		cancel_delayed_work(&priv->hang_check);
 		cancel_delayed_work(&priv->rf_kill);
 		destroy_workqueue(priv->workqueue);
+#endif
 		priv->workqueue = NULL;
 		
 		ieee80211_free(priv->ieee);
@@ -6801,17 +7220,29 @@ static int __init ipw2100_init(void)
 	printk(KERN_INFO DRV_NAME ": Compiled with LEGACY FW load.\n");
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	ret = pci_module_init(&ipw2100_pci_driver);
+#endif
 
 	/* If debug module parameter declared, set debug_level to that */
 	if (debug != -1)
 		ipw2100_debug_level = debug;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 #ifdef CONFIG_IPW_DEBUG
 	driver_create_file(&ipw2100_pci_driver.driver,
 			   &driver_attr_debug_level);
 #endif
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	ret = ipw2100_proc_init();
+	if (!ret) {
+		ret = pci_module_init(&ipw2100_pci_driver);
+		if (ret)
+			ipw2100_proc_cleanup();
+	}
+#endif
 	return ret;
 }
 
@@ -6822,11 +7253,16 @@ static int __init ipw2100_init(void)
 static void __exit ipw2100_exit(void)
 {
 	/* FIXME: IPG: check that we have no instances of the devices open */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 #ifdef CONFIG_IPW_DEBUG
 	driver_remove_file(&ipw2100_pci_driver.driver,
 			   &driver_attr_debug_level);
 #endif
+#endif
 	pci_unregister_driver(&ipw2100_pci_driver);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	ipw2100_proc_cleanup();
+#endif
 }
 
 module_init(ipw2100_init);
@@ -8121,8 +8557,12 @@ void ipw2100_wx_event_work(struct ipw210
 static char *firmware = NULL;
 
 /* Module paramter for path to the firmware*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+MODULE_PARM(firmware,"s");
+#else
 #include <linux/moduleparam.h>
 module_param(firmware, charp, 0);
+#endif
 
 MODULE_PARM_DESC(firmware, "complete path to firmware file");
 
@@ -8184,7 +8624,11 @@ static void ipw2100_fw_free(struct ipw21
 }
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int ipw2100_fw_load(int fd, struct ipw2100_fw_chunk_set *cs, long size)
+#else
 static int ipw2100_fw_load(struct file *filp, struct ipw2100_fw_chunk_set *cs, long size)
+#endif
 {
 	struct ipw2100_fw_chunk *c;
 	int i = 0;
@@ -8224,7 +8668,11 @@ static int ipw2100_fw_load(struct file *
 			goto fail;
 			
 		}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		if (read(fd, c->buf, c->len) != c->len) {
+#else
 		if (vfs_read(filp, c->buf, c->len, &filp->f_pos) != c->len) {
+#endif
 			printk(KERN_INFO "Failed to read chunk firmware "
 			       "chunk %d.\n", i);
 			goto fail;
@@ -8245,7 +8693,11 @@ static int ipw2100_fw_load(struct file *
 
 static int ipw2100_do_mod_firmware_load(const char *fn, struct ipw2100_fw *fw)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	int fd;
+#else
 	struct file *filp;
+#endif
 	long l;
 	struct ipw2100_fw_header h;
 
@@ -8254,16 +8706,30 @@ static int ipw2100_do_mod_firmware_load(
 	INIT_LIST_HEAD(&fw->fw.chunk_list);
 	INIT_LIST_HEAD(&fw->uc.chunk_list);
 	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	fd = open(fn, 0, 0);
+	if (fd == -1) {
+#else	
 	filp = filp_open(fn, 0, 0);
 	if (IS_ERR(filp)) {
+#endif
 		printk(KERN_INFO "Unable to load '%s'.\n", fn);
 		return 1;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	l = lseek(fd, 0L, 2);
+	lseek(fd, 0L, 0);
+#else
 	l = i_size_read(filp->f_dentry->d_inode);
+#endif
 	IPW_DEBUG_FW("Loading %ld bytes for firmware '%s'\n", l, fn);
 	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (read(fd, (char *)&h, sizeof(h)) != sizeof(h)) {
+#else	
 	if (vfs_read(filp, (char *)&h, sizeof(h), &filp->f_pos) != sizeof(h)) {
+#endif
 		printk(KERN_INFO "Failed to read '%s'.\n", fn);
 		goto fail;
 	}
@@ -8278,6 +8744,15 @@ static int ipw2100_do_mod_firmware_load(
 
 	fw->version = h.version;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (ipw2100_fw_load(fd, &fw->fw, h.fw_size))
+		goto fail;
+
+	if (ipw2100_fw_load(fd, &fw->uc, h.uc_size))
+		goto fail;
+
+	close(fd);
+#else
 	if (ipw2100_fw_load(filp, &fw->fw, h.fw_size))
 		goto fail;
 
@@ -8285,11 +8760,16 @@ static int ipw2100_do_mod_firmware_load(
 		goto fail;
 
 	filp_close(filp, current->files);
+#endif
 	return 0;
 
  fail:
 	ipw2100_fw_free(fw);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	close(fd);
+#else
 	filp_close(filp, current->files);
+#endif
 	return 1;
 }
 
@@ -8435,7 +8915,11 @@ int ipw2100_get_firmware(struct ipw2100_
 		break;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	rc = request_firmware(&fw->fw_entry, fw_name, pci_name(priv->pdev));
+#else
 	rc = request_firmware(&fw->fw_entry, fw_name, &priv->pdev->dev);
+#endif
 
 	if (rc < 0) {
 		printk(KERN_ERR
@@ -8724,3 +9208,280 @@ int ipw2100_ucode_download(struct ipw210
 
 	return 0;
 }
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+int ipw2100_proc_dev_init(struct ipw2100_priv *priv)
+{
+	struct proc_dir_entry *e;
+
+	IPW_DEBUG_INFO("enter %s\n", priv->ndev->name);
+
+	priv->dir_dev = create_proc_entry(priv->ndev->name, 
+					  S_IFDIR | S_IRUGO | S_IXUGO, 
+					  ipw2100_proc);
+	if (!priv->dir_dev) {
+		printk(KERN_ERR
+		       "Unable to initialize /proc/net/ipw2100/%s\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("hw", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_hardware, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/hw\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("registers", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_registers, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/registers\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("ordinals", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_ordinals, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/ordinals\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("pci", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_pci, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/pci\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("version", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_version, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/version\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("stats", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_stats, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/stats\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("internals", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_internals, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/internals\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("txqueue", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_txqueue, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/txqueue\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("rxqueue", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_rxqueue, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/rxqueue\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("bssinfo", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_bssinfo, priv->ndev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/bssinfo\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("memory", S_IFREG | S_IRUGO | S_IWUSR,
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_memory;
+		e->write_proc = proc_set_memory;
+		e->data = priv->ndev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/memory\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("cardmem", S_IFREG | S_IRUGO | S_IWUSR, 
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_cardmem;
+		e->write_proc = proc_set_cardmem;
+		e->data = priv->ndev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/cardmem\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("scan_age", S_IFREG | S_IRUGO | S_IWUSR, 
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_scan_age;
+		e->write_proc = proc_set_scan_age;
+		e->data = priv->ndev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/scan_age\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("fatal_error", S_IFREG | S_IRUGO | S_IWUSR, 
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_fatal_error;
+		e->write_proc = proc_set_fatal_error;
+		e->data = priv->ndev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/fatal_error\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("rf_kill", S_IFREG | S_IRUGO | S_IWUSR,
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_rf_kill;
+		e->write_proc = proc_set_rf_kill;
+		e->data = priv->ndev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/rf_kill\n",
+		       priv->ndev->name);
+		goto fail;
+	}
+
+	IPW_DEBUG_INFO("exit %s\n", priv->ndev->name);
+
+	return 0;
+
+ fail:
+	ipw2100_proc_dev_cleanup(priv);
+	IPW_DEBUG_INFO("exit on fail %s\n", priv->ndev->name);
+	
+	return -ENOMEM;
+}
+
+void ipw2100_proc_dev_cleanup(struct ipw2100_priv *priv)
+{
+	IPW_DEBUG_INFO("enter %s\n", priv->ndev->name);
+
+	if (priv->dir_dev) {
+		remove_proc_entry("stats", priv->dir_dev);
+		remove_proc_entry("internals", priv->dir_dev);
+		remove_proc_entry("txqueue", priv->dir_dev);
+		remove_proc_entry("rxqueue", priv->dir_dev);
+		remove_proc_entry("cardmem", priv->dir_dev);
+		remove_proc_entry("scan_age", priv->dir_dev);
+		remove_proc_entry("bssinfo", priv->dir_dev);
+		remove_proc_entry("rf_kill", priv->dir_dev);
+		remove_proc_entry("version", priv->dir_dev);
+		remove_proc_entry("hw", priv->dir_dev);
+		remove_proc_entry("registers", priv->dir_dev);
+		remove_proc_entry("memory", priv->dir_dev);
+		remove_proc_entry("ordinals", priv->dir_dev);
+		remove_proc_entry("pci", priv->dir_dev);
+		remove_proc_entry("fatal_error", priv->dir_dev);
+		remove_proc_entry(priv->ndev->name, ipw2100_proc);
+		priv->dir_dev = NULL;
+	}
+
+	IPW_DEBUG_INFO("exit %s\n", priv->ndev->name);
+}
+
+static int ipw2100_proc_init(void)
+{	
+	struct proc_dir_entry *e;
+	
+	IPW_DEBUG_INFO("enter\n");
+
+	ipw2100_proc = create_proc_entry(DRV_NAME, S_IFDIR, proc_net);
+	if (ipw2100_proc == NULL)
+		goto fail_ipw2100;
+
+#ifdef CONFIG_IPW_DEBUG
+	e = create_proc_entry("debug_level", S_IFREG | S_IRUGO | S_IWUSR, 
+			      ipw2100_proc);
+	if (e == NULL)
+		goto fail_debug;
+	e->read_proc = proc_get_debug_level;
+	e->write_proc = proc_set_debug_level;
+	e->data = NULL;
+
+	IPW_DEBUG_INFO("exit\n");
+	return 0;
+
+fail_debug:
+	printk(KERN_ERR DRV_NAME ": Unable to initialize "
+	       "/proc/net/" DRV_NAME "/debug_level\n");
+	remove_proc_entry(DRV_NAME, proc_net);
+	ipw2100_proc = NULL;
+	goto fail;
+#endif
+
+fail_ipw2100:
+	printk(KERN_ERR DRV_NAME ": Unable to initialize " 
+	      "/proc/net/" DRV_NAME "\n");
+
+fail:
+	IPW_DEBUG_INFO("exit on fail\n");	
+	return -ENOMEM;
+}
+
+static void ipw2100_proc_cleanup(void)
+{
+	IPW_DEBUG_INFO("enter\n");
+
+#ifdef CONFIG_IPW_DEBUG
+	if (ipw2100_proc)
+		remove_proc_entry("debug_level", ipw2100_proc);
+#endif
+	remove_proc_entry(DRV_NAME, proc_net);
+	IPW_DEBUG_INFO("exit\n");
+}
+#endif
diff -u -p -r -b ipw2100-0.56-0/ipw2100.h ipw2100-0.56-9/ipw2100.h
--- ipw2100-0.56-0/ipw2100.h	2004-10-13 21:06:57.000000000 +0200
+++ ipw2100-0.56-9/ipw2100.h	2004-11-04 21:25:43.000000000 +0100
@@ -42,7 +42,53 @@
 
 #include "ieee80211.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int errno;
+#define get_seconds() CURRENT_TIME
+#define DEVICE_ATTR(a,b,c,d) int dev_attr_##a __attribute__((unused))
+#define DRIVER_ATTR(a,b,c,d) int driver_attr_##a __attribute__((unused))
+#include <linux/tqueue.h>
+#define work_struct tq_struct
+#define INIT_WORK INIT_TQUEUE
+#define queue_work(x,y) schedule_task(y)
+#else
 #include <linux/workqueue.h>
+#endif
+
+#ifndef __wait_event_interruptible_timeout
+#define __wait_event_interruptible_timeout(wq, condition, ret)		\
+do {									\
+	wait_queue_t __wait;						\
+	init_waitqueue_entry(&__wait, current);				\
+									\
+	add_wait_queue(&wq, &__wait);					\
+	for (;;) {							\
+		set_current_state(TASK_INTERRUPTIBLE);			\
+		if (condition)						\
+			break;						\
+		if (!signal_pending(current)) {				\
+			ret = schedule_timeout(ret);			\
+			if (!ret)					\
+				break;					\
+			continue;					\
+		}							\
+		ret = -ERESTARTSYS;					\
+		break;							\
+	}								\
+	current->state = TASK_RUNNING;					\
+	remove_wait_queue(&wq, &__wait);				\
+} while (0)
+#endif
+
+#ifndef wait_event_interruptible_timeout
+#define wait_event_interruptible_timeout(wq, condition, timeout)	\
+({									\
+	long __ret = timeout;						\
+	if (!(condition))						\
+		__wait_event_interruptible_timeout(wq, condition, __ret); \
+	__ret;								\
+})
+#endif
 
 #ifndef IRQ_NONE
 typedef void irqreturn_t;
@@ -588,8 +634,13 @@ struct ipw2100_priv {
 	struct work_struct reset_work;
 	struct work_struct security_work;
 	struct work_struct wx_event_work;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	struct timer_list hang_check_timer;
+	struct timer_list rf_kill_timer;
+#else
 	struct work_struct hang_check;
 	struct work_struct rf_kill;
+#endif
 	
 	int wx_ap_event_pending;
 
@@ -1490,4 +1541,12 @@ int ipw2100_ucode_download(struct ipw210
 int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf, size_t max);
 int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf, size_t max);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static struct proc_dir_entry *ipw2100_proc = NULL;
+static int ipw2100_proc_init(void);
+static void ipw2100_proc_cleanup(void);
+static int ipw2100_proc_dev_init(struct ipw2100_priv *priv);
+static void ipw2100_proc_dev_cleanup(struct ipw2100_priv *priv);
+#endif
+
 #endif /* _IPW2100_H */
