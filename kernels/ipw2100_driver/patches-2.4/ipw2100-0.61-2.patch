diff -u -p -r -b ipw2100-0.61-0/Makefile ipw2100-0.61-2/Makefile
--- ipw2100-0.61-0/Makefile	2004-11-08 23:11:42.000000000 +0100
+++ ipw2100-0.61-2/Makefile	2004-11-10 11:18:15.000000000 +0100
@@ -27,7 +27,7 @@ CONFIG_IPW2100_PROMISC=y
 
 # If you are building externally and you want to use the legacy firmware,
 # then uncomment the following line:
-# CONFIG_IPW2100_LEGACY_FW_LOAD=y
+CONFIG_IPW2100_LEGACY_FW_LOAD=y
 
 endif
 
@@ -206,6 +206,8 @@ modules:
 
 endif # End 2.4 / 2.6 specific
 
+ifeq ($(OLDMAKE),)
+
 install: modules
 	install -d $(KMISC)
 	install -m 644 -c $(addsuffix .ko,$(list-m)) $(KMISC)
@@ -222,6 +224,25 @@ uninstall:
 	rm -rf $(addprefix $(KMISC),$(addsuffix .ko,$(list-m)))
 	/sbin/depmod -a
 
+else
+
+install: modules
+	install -d $(KMISC)
+	install -m 644 -c $(addsuffix .o,$(list-m)) $(KMISC)
+	/sbin/depmod -a
+ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	@echo "Don't forget to copy firmware to /etc/firmware/."
+else
+	@echo "Don't forget to copy firmware to /usr/lib/hotplug/firmware/ "
+endif
+	@echo "See INSTALL for more information."
+
+uninstall:
+	rm -rf $(addprefix $(KMISC),$(addsuffix .o,$(list-m)))
+	/sbin/depmod -a
+
+endif
+
 endif # End of internal build
 
 
diff -u -p -r -b ipw2100-0.61-0/ieee80211.h ipw2100-0.61-2/ieee80211.h
--- ipw2100-0.61-0/ieee80211.h	2004-11-08 23:11:42.000000000 +0100
+++ ipw2100-0.61-2/ieee80211.h	2004-11-10 11:18:15.000000000 +0100
@@ -21,6 +21,7 @@
 #ifndef IEEE80211_H
 #define IEEE80211_H
 #include <linux/if_ether.h> /* ETH_ALEN */
+#include <linux/kernel.h>
 
 #define IEEE80211_DATA_LEN		2304
 /* Maximum size for the MA-UNITDATA primitive, 802.11 standard section
@@ -45,6 +46,26 @@ struct ieee80211_hdr {
 	u8 addr4[ETH_ALEN];
 } __attribute__ ((packed));
 
+static const char *eap_types[] = {
+	"EAP-Packet", "EAPOL-Start", "EAPOL-Logoff", "EAPOL-Key", 
+	"EAPOL-Encap-ASF-Alert", "Unknown"
+};
+
+static inline const char *eap_get_type(int type)
+{
+	if (type > ARRAY_SIZE(eap_types))
+		type = ARRAY_SIZE(eap_types) - 1;
+	return eap_types[type];
+}
+
+struct eapol {
+	u8 snap[6];
+	u16 ethertype;
+	u8 version;
+	u8 type;
+	u16 length;
+} __attribute__ ((packed));
+
 #define IEEE80211_3ADDR_SIZE (24)
 #define IEEE80211_4ADDR_SIZE (30)
 
diff -u -p -r -b ipw2100-0.61-0/ieee80211_crypt.c ipw2100-0.61-2/ieee80211_crypt.c
--- ipw2100-0.61-0/ieee80211_crypt.c	2004-11-08 23:11:42.000000000 +0100
+++ ipw2100-0.61-2/ieee80211_crypt.c	2004-11-10 11:18:15.000000000 +0100
@@ -55,7 +55,11 @@ void ieee80211_crypt_deinit_entries(stru
 
 		if (entry->ops) {
 			entry->ops->deinit(entry->priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			if (entry->ops->owner) __MOD_DEC_USE_COUNT(entry->ops->owner);
+#else
 			module_put(entry->ops->owner);
+#endif
 		}
 		kfree(entry);
 	}
diff -u -p -r -b ipw2100-0.61-0/ieee80211_module.c ipw2100-0.61-2/ieee80211_module.c
--- ipw2100-0.61-0/ieee80211_module.c	2004-11-08 23:11:42.000000000 +0100
+++ ipw2100-0.61-2/ieee80211_module.c	2004-11-10 11:18:15.000000000 +0100
@@ -155,7 +155,11 @@ void ieee80211_free(struct ieee80211_dev
 		if (crypt) {
 			if (crypt->ops) {
 				crypt->ops->deinit(crypt->priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+				if (crypt->ops->owner) __MOD_DEC_USE_COUNT(crypt->ops->owner);
+#else
 				module_put(crypt->ops->owner);
+#endif
 			}
 			kfree(crypt);
 			ieee->crypt[i] = NULL;
@@ -239,8 +243,13 @@ static void __exit ieee80211_exit(void)
 	}
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+MODULE_PARM(debug, "i");
+#else
 #include <linux/moduleparam.h>
 module_param(debug, int, 0444);
+#endif
+
 MODULE_PARM_DESC(debug, "debug output mask");
 
 
diff -u -p -r -b ipw2100-0.61-0/ieee80211_rx.c ipw2100-0.61-2/ieee80211_rx.c
--- ipw2100-0.61-0/ieee80211_rx.c	2004-11-08 23:11:42.000000000 +0100
+++ ipw2100-0.61-2/ieee80211_rx.c	2004-11-11 11:06:22.000000000 +0100
@@ -638,8 +638,10 @@ int ieee80211_rx(struct ieee80211_device
 		    ieee80211_is_eapol_frame(ieee, skb)) {
 			/* pass unencrypted EAPOL frames even if encryption is
 			 * configured */
-			IEEE80211_DEBUG_EAP("RX: IEEE 802.1X - passing "
-					    "unencrypted EAPOL frame\n");
+			struct eapol *eap = (struct eapol *)(skb->data + 
+				24);
+			IEEE80211_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
+						eap_get_type(eap->type));
 		} else {
 			printk(KERN_DEBUG "%s: encryption configured, but RX "
 			       "frame not encrypted (SA=" MAC_FMT ")\n",
@@ -651,8 +653,10 @@ int ieee80211_rx(struct ieee80211_device
 #ifdef CONFIG_IEEE80211_DEBUG
 	if (crypt && !(fc & IEEE80211_FCTL_WEP) && 
 	    ieee80211_is_eapol_frame(ieee, skb)) {
-		IEEE80211_DEBUG_EAP("RX: IEEE 802.1X - passing "
-				    "unencrypted EAPOL frame\n");
+			struct eapol *eap = (struct eapol *)(skb->data + 
+				24);
+			IEEE80211_DEBUG_EAP("RX: IEEE 802.1X EAPOL frame: %s\n",
+						eap_get_type(eap->type));
 	}
 #endif
 
@@ -842,13 +846,12 @@ static inline int ieee80211_network_init
 	struct ieee80211_device *ieee,
 	struct ieee80211_probe_response *beacon,
 	struct ieee80211_network *network,
-	struct ieee80211_rx_stats *stats)
+	struct ieee80211_rx_stats *stats,
+	u8 update)
 {
 	struct ieee80211_info_element *info_element;
  	u16 left;
 	u8 i;
-	int probe_response = WLAN_FC_GET_STYPE(beacon->header.frame_ctl) ==
-		IEEE80211_STYPE_PROBE_RESP;
 
 	if (stats->freq == IEEE80211_52GHZ_BAND) {
 		/* for A band (No DS info) */
@@ -862,10 +865,11 @@ static inline int ieee80211_network_init
 	network->time_stamp[0] = beacon->time_stamp[0];
 	network->time_stamp[1] = beacon->time_stamp[1];
 	network->beacon_interval = beacon->beacon_interval;
-	network->listen_interval = 0x0A; /* Where to pull this? beacon->listen_interval;*/
-	network->flags = 0;
+	/* Where to pull this? beacon->listen_interval;*/
+	network->listen_interval = 0x0A; 
 	network->rates_len = network->rates_ex_len = 0;
 	network->last_associate = 0;
+	network->flags = 0;
 
 #ifdef CONFIG_IEEE80211_WPA		
  	network->wpa_ie_len = 0;
@@ -884,7 +888,16 @@ static inline int ieee80211_network_init
   		
 		switch (info_element->id) {
 		case MFIE_TYPE_SSID:
-			if (!probe_response) {
+			/* We need to make sure we support the following 
+			 * sequence:
+			 * beacon received for existing network, hidden ESSID -
+			 *     do not modify the ESSID
+			 * beacon received for new network, hidden ESSID -
+			 *     create New network w/ NETWORK_EMPTY_ESSID
+			 */
+			if (update && 
+			    ieee80211_is_empty_essid(info_element->data, 
+						     info_element->len)) {
 				IEEE80211_DEBUG_SCAN(
 					"MFIE_TYPE_SSID: "
 					"Ignored from BEACON FRAME.\n");
@@ -1024,6 +1037,7 @@ static inline void ieee80211_process_pro
 	u8 ssid[IW_ESSID_MAX_SIZE];
 	u8 empty_ssid;
 #endif
+	u8 update;
 
 	IEEE80211_DEBUG_SCAN(
 		"\n"
@@ -1073,6 +1087,7 @@ static inline void ieee80211_process_pro
 			list_del(ieee->network_free_list.next);
 		}
 		
+		
 #ifdef CONFIG_IEEE80211_DEBUG
 		ssid_ie = &beacon->info_element;
 		if (ssid_ie->id == MFIE_TYPE_SSID) {
@@ -1087,12 +1102,15 @@ static inline void ieee80211_process_pro
 			memcpy(ssid, "<hidden>", sizeof("<hidden>"));
 		else 
 			memcpy(ssid, ssid_ie->data, ssid_len);
-#endif
 
 		IEEE80211_DEBUG_SCAN("Adding '%s (" MAC_FMT ")' to network "
 				     "list.\n", 
 				     escape_essid(ssid, ssid_len),
 				     MAC_ARG(beacon->header.addr3));
+#endif
+
+		update = 0;
+
 		list_add_tail(&network->list, &ieee->network_list);
 	} else {
 		IEEE80211_DEBUG_SCAN("Updating '%s (" MAC_FMT ")' to network "
@@ -1100,9 +1118,10 @@ static inline void ieee80211_process_pro
 				     escape_essid(network->ssid, 
 						  network->ssid_len),
 				     MAC_ARG(network->bssid));
+		update = 1;
 	}
 	
-	if (ieee80211_network_init(ieee, beacon, network, stats)) {
+	if (ieee80211_network_init(ieee, beacon, network, stats, update)) {
 		/* If parsing of the beacon probe was not successful then
 		 * nuke this network from the list and stick it on the free
 		 * list for future use */
diff -u -p -r -b ipw2100-0.61-0/ieee80211_tx.c ipw2100-0.61-2/ieee80211_tx.c
--- ipw2100-0.61-0/ieee80211_tx.c	2004-11-08 23:11:42.000000000 +0100
+++ ipw2100-0.61-2/ieee80211_tx.c	2004-11-10 14:19:29.000000000 +0100
@@ -309,15 +309,17 @@ struct ieee80211_txb *ieee80211_skb_to_t
 	}
 
 #endif /* CONFIG_IEEE80211_WPA */
-	if (crypt && !encrypt && ether_type == ETH_P_PAE) 
-		IEEE80211_DEBUG_EAP("TX: IEEE 802.11 - sending EAPOL frame\n");
+	if (crypt && !encrypt && ether_type == ETH_P_PAE) {
+		struct eapol *eap = (struct eapol *)(skb->data + 
+			sizeof(struct ethhdr) - SNAP_SIZE - sizeof(u16));
+		IEEE80211_DEBUG_EAP("TX: IEEE 802.11 EAPOL frame: %s\n",
+			eap_get_type(eap->type));
+	}
 #endif  /* CONFIG_IEEE80211_CRYPT */
 
-	if (encrypt) {
 		/* Save source and destination addresses */
 		memcpy(&dest, skb->data, ETH_ALEN);
 		memcpy(&src, skb->data+ETH_ALEN, ETH_ALEN);
-	}
 
 	/* Advance the SKB to the start of the payload */
 	skb_pull(skb, sizeof(struct ethhdr));
diff -u -p -r -b ipw2100-0.61-0/ieee80211_wx.c ipw2100-0.61-2/ieee80211_wx.c
--- ipw2100-0.61-0/ieee80211_wx.c	2004-11-08 23:11:42.000000000 +0100
+++ ipw2100-0.61-2/ieee80211_wx.c	2004-11-10 11:18:15.000000000 +0100
@@ -369,7 +369,11 @@ int ieee80211_wx_set_encode(struct ieee8
 			new_crypt->ops = ieee80211_get_crypto_ops("WEP");
 		}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		if (new_crypt->ops && new_crypt->ops->owner && __MOD_INC_USE_COUNT(new_crypt->ops->owner))
+#else
 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner)) 
+#endif
 			new_crypt->priv = new_crypt->ops->init(key);
 
 		if (!new_crypt->ops || !new_crypt->priv) {
diff -u -p -r -b ipw2100-0.61-0/ipw2100.c ipw2100-0.61-2/ipw2100.c
--- ipw2100-0.61-0/ipw2100.c	2004-11-08 23:11:42.000000000 +0100
+++ ipw2100-0.61-2/ipw2100.c	2004-11-11 11:35:21.000000000 +0100
@@ -164,7 +164,11 @@ that protects the following:
 
 #include "ipw2100.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define IPW2100_VERSION "0.61-2 (kernel 2.4)"
+#else
 #define IPW2100_VERSION "0.61"
+#endif
 
 #define DRV_NAME	"ipw2100"
 #define DRV_VERSION	IPW2100_VERSION
@@ -191,6 +195,14 @@ static int disable = 0;
 static struct ipw2100_fw ipw2100_firmware;
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+MODULE_PARM(debug, "i");
+MODULE_PARM(ifname, "s");
+MODULE_PARM(mode, "i");
+MODULE_PARM(channel, "i");
+MODULE_PARM(associate, "i");
+MODULE_PARM(disable, "i");
+#else
 #include <linux/moduleparam.h>
 module_param(debug, int, 0444);
 module_param(ifname, charp, 0444);
@@ -198,6 +210,7 @@ module_param(mode, int, 0444);
 module_param(channel, int, 0444);
 module_param(associate, int, 0444);
 module_param(disable, int, 0444);
+#endif
 
 MODULE_PARM_DESC(debug, "debug level");
 MODULE_PARM_DESC(ifname, "interface name (default 'eth%d')");
@@ -656,8 +669,12 @@ static inline void schedule_reset(struct
 		netif_stop_queue(priv->net_dev);
 		priv->status |= STATUS_RESET_PENDING;
 		if (priv->reset_backoff) 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			queue_work(priv->workqueue, &priv->reset_work);
+#else
 			queue_delayed_work(priv->workqueue, &priv->reset_work, 
 					   priv->reset_backoff * HZ);
+#endif
 		else 
 			queue_work(priv->workqueue, &priv->reset_work);
 
@@ -689,19 +706,19 @@ static int ipw2100_hw_send_command(struc
 	spin_lock_irqsave(&priv->low_lock, flags);
 
 	if (priv->fatal_error) {
-		IPW_DEBUG_INFO("Attempt to send command while hardware in fatal error condition.");
+		IPW_DEBUG_INFO("Attempt to send command while hardware in fatal error condition.\n");
 		err = -EIO;
 		goto fail_unlock;
 	}
 
 	if (!(priv->status & STATUS_RUNNING)) {
-		IPW_DEBUG_INFO("Attempt to send command while hardware is not running.");
+		IPW_DEBUG_INFO("Attempt to send command while hardware is not running.\n");
 		err = -EIO;
 		goto fail_unlock;
 	}
 
 	if (priv->status & STATUS_CMD_ACTIVE) {
-		IPW_DEBUG_INFO("Attempt to send command while hardware another command is pending.");
+		IPW_DEBUG_INFO("Attempt to send command while hardware another command is pending.\n");
 		err = -EBUSY;
 		goto fail_unlock;
 	}
@@ -746,9 +763,15 @@ static int ipw2100_hw_send_command(struc
 	 * then there is a problem.
 	 */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	err = interruptible_sleep_on_timeout(
+		&priv->wait_command_queue,
+		HOST_COMPLETE_TIMEOUT);
+#else
 	err = wait_event_interruptible_timeout(
 		priv->wait_command_queue, !(priv->status & STATUS_CMD_ACTIVE),
 		HOST_COMPLETE_TIMEOUT);
+#endif
 
 	if (err == 0) {
 		IPW_DEBUG_INFO("Command completion failed out after %dms.\n",
@@ -1421,7 +1444,12 @@ static int ipw2100_enable_adapter(struct
 
 	if (priv->stop_hang_check) {
 		priv->stop_hang_check = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		priv->hang_check_timer.expires = jiffies + 2 * HZ;
+		add_timer(&priv->hang_check_timer);
+#else
 		queue_delayed_work(priv->workqueue, &priv->hang_check, 2 * HZ);
+#endif
 	}
 
 	return 0;
@@ -1442,6 +1470,8 @@ static int ipw2100_hw_stop_adapter(struc
 	if (!(priv->status & STATUS_RUNNING))
 		return 0;
 
+	priv->status |= STATUS_STOPPING;
+
 	/* We can only shut down the card if the firmware is operational.  So,
 	 * if we haven't reset since a fatal_error, then we can not send the
 	 * shutdown commands. */
@@ -1527,7 +1557,8 @@ static int ipw2100_hw_stop_adapter(struc
 	write_register(priv->net_dev, IPW_REG_RESET_REG,
 		       IPW_AUX_HOST_RESET_REG_SW_RESET);
 
-	priv->status &= ~STATUS_RUNNING;
+	priv->status &= ~(STATUS_RUNNING | STATUS_STOPPING);
+	
 
 	return 0;
 }
@@ -1552,7 +1583,11 @@ static int ipw2100_disable_adapter(struc
 
 	if (!priv->stop_hang_check) {
 		priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->hang_check_timer);
+#else
 		cancel_delayed_work(&priv->hang_check);
+#endif
 	}
 
 	err = ipw2100_hw_send_command(priv, &cmd);
@@ -1711,7 +1746,12 @@ static int ipw2100_up(struct ipw2100_pri
 
 		if (priv->stop_rf_kill) {
 			priv->stop_rf_kill = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			priv->rf_kill_timer.expires = jiffies + HZ;
+			add_timer(&priv->rf_kill_timer);
+#else
 			queue_delayed_work(priv->workqueue, &priv->rf_kill, HZ);
+#endif
 		}
 
 		deferred = 1;
@@ -1764,18 +1804,28 @@ static void ipw2100_down(struct ipw2100_
 	/* Kill the RF switch timer */
 	if (!priv->stop_rf_kill) {
 		priv->stop_rf_kill = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->rf_kill_timer);
+#else
 		cancel_delayed_work(&priv->rf_kill);
+#endif
 	}
 	
 	/* Kill the firmare hang check timer */
 	if (!priv->stop_hang_check) {
 		priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->hang_check_timer);
+#else
 		cancel_delayed_work(&priv->hang_check);
+#endif
 	}
 
 	/* Kill any pending resets */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	if (priv->status & STATUS_RESET_PENDING)
 		cancel_delayed_work(&priv->reset_work);
+#endif
 
 	/* Make sure the interrupt is on so that FW commands will be 
 	 * processed correctly */
@@ -1810,6 +1860,12 @@ static void ipw2100_down(struct ipw2100_
 void ipw2100_reset_adapter(struct ipw2100_priv *priv)
 {
 	unsigned long flags;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (priv->reset_backoff) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(priv->reset_backoff * HZ);
+	}
+#endif
 	spin_lock_irqsave(&priv->low_lock, flags);
 	IPW_DEBUG_INFO(DRV_NAME ": %s: Restarting adapter.\n", 
 		       priv->net_dev->name);
@@ -1819,13 +1875,19 @@ void ipw2100_reset_adapter(struct ipw210
 	
 	/* Force a power cycle even if interface hasn't been opened
 	 * yet */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	cancel_delayed_work(&priv->reset_work);
+#endif
 	priv->status |= STATUS_RESET_PENDING;
 	spin_unlock_irqrestore(&priv->low_lock, flags);
 
 	/* stop timed checks so that they don't interfere with reset */
 	priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	del_timer_sync(&priv->hang_check_timer);
+#else
 	cancel_delayed_work(&priv->hang_check);
+#endif
 
 	ipw2100_up(priv, 0);
 
@@ -1929,7 +1991,11 @@ static void isr_indicate_associated(stru
 		netif_start_queue(priv->net_dev);
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	queue_work(priv->workqueue, &priv->wx_event_work);
+#else
 	queue_delayed_work(priv->workqueue, &priv->wx_event_work, HZ / 10);
+#endif
 }
 
 		
@@ -1988,10 +2054,14 @@ int ipw2100_set_essid(struct ipw2100_pri
 static void isr_indicate_association_lost(struct ipw2100_priv *priv, u32 status)
 {
 	IPW_DEBUG(IPW_DL_NOTIF | IPW_DL_STATE | IPW_DL_ASSOC,
-		  "disassociated: '%s'" MAC_FMT " \n",
+		  "disassociated: '%s' " MAC_FMT " \n",
 		  escape_essid(priv->essid, priv->essid_len),
 		  MAC_ARG(priv->bssid));
 
+	if (priv->status & STATUS_STOPPING) {
+		IPW_DEBUG_INFO("Card is stopping itself, discard ASSN_LOST.\n");
+		return;
+	}
 	priv->status &= ~STATUS_ASSOCIATED;
 
 	netif_carrier_off(priv->net_dev);
@@ -2019,13 +2089,16 @@ static void isr_indicate_rf_kill(struct 
 	}
 #endif
 
-	/* If not already running, we now fire up a timer that will poll
-	 * the state of the RF switch on the hardware so we can re-enable
-	 * the firmware if the switch is enabled */
-	if (priv->stop_rf_kill) {
+	/* Make sure the RF_KILL check timer is running */
 		priv->stop_rf_kill = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	del_timer_sync(&priv->rf_kill_timer);
+	priv->rf_kill_timer.expires = jiffies + HZ;
+	add_timer(&priv->rf_kill_timer);
+#else
+	cancel_delayed_work(&priv->rf_kill);
 		queue_delayed_work(priv->workqueue, &priv->rf_kill, HZ);
-	}
+#endif
 }
 
 static void isr_scan_complete(struct ipw2100_priv *priv, u32 status)
@@ -3324,9 +3397,20 @@ static void ipw2100_msg_free(struct ipw2
 	priv->msg_buffers = NULL;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_pci(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	struct pci_dev *pci_dev = priv->pci_dev;
+	*eof = 1;
+#else
 static ssize_t show_pci(struct device *d, char *buf)
 {
 	struct pci_dev *pci_dev = container_of(d, struct pci_dev, dev);
+#endif
 	char *out = buf;
 	int i, j;
 	u32 val;
@@ -3342,28 +3426,66 @@ static ssize_t show_pci(struct device *d
 
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(pci, S_IRUGO, show_pci, NULL);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_cfg(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *p = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_cfg(struct device *d, char *buf)
 {
 	struct ipw2100_priv *p = (struct ipw2100_priv *)d->driver_data;
+#endif
 	return sprintf(buf, "0x%08x\n", (int)p->config);
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(cfg, S_IRUGO, show_cfg, NULL);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_status(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *p = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_status(struct device *d, char *buf)
 {
 	struct ipw2100_priv *p = (struct ipw2100_priv *)d->driver_data;
+#endif
 	return sprintf(buf, "0x%08x\n", (int)p->status);
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(status, S_IRUGO, show_status, NULL);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_capability(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *p = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_capability(struct device *d, char *buf)
 {
 	struct ipw2100_priv *p = (struct ipw2100_priv *)d->driver_data;
+#endif
 	return sprintf(buf, "0x%08x\n", (int)p->capability);
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(capability, S_IRUGO, show_capability, NULL);
+#endif
 
 
 #define IPW2100_REG(x) { IPW_ ##x, #x }
@@ -3543,10 +3665,21 @@ const struct {
 };
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_registers(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	int i;
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_registers(struct device *d, char *buf)
 {
 	int i;
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	char * out = buf;
 	u32 val = 0;
@@ -3561,12 +3694,24 @@ static ssize_t show_registers(struct dev
 
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(registers, S_IRUGO, show_registers, NULL);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_hardware(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_hardware(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	char * out = buf;
 	int i;
@@ -3601,12 +3746,23 @@ static ssize_t show_hardware(struct devi
 	}
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(hardware, S_IRUGO, show_hardware, NULL);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_memory(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t show_memory(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	static unsigned long loop = 0;
 	int len = 0;
@@ -3614,11 +3770,25 @@ static ssize_t show_memory(struct device
 	int i;
 	char line[81];
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (offset == 0)
+		loop = 0;
+
+	if (loop >= 0x30000) {
+		*start = NULL;
+		*eof = 1;
+		return 0;
+	}
+
+	/* Return around 2k per pass... */
+	while (count - len > 256 && len < 2048 && loop < 0x30000) {
+#else
 	if (loop >= 0x30000)
 		loop = 0;
 
 	/* sysfs provides us PAGE_SIZE buffer */
 	while (len < PAGE_SIZE - 128 && loop < 0x30000) {
+#endif
 
 		if (priv->snapshot[0]) for (i = 0; i < 4; i++) 
 			buffer[i] = *(u32 *)SNAPSHOT_ADDR(loop + i * 4);
@@ -3654,12 +3824,35 @@ static ssize_t show_memory(struct device
 		loop += 16;
 	}
 	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (len) 
+		*start = (char*)len; 
+	else
+		*eof = 1;
+#endif	
 	return len;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_memory(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	char buf[] = "00000";
+	unsigned long len =
+	    (sizeof(buf) - 1) > count ? count : sizeof(buf) - 1;
+
+	if (copy_from_user(buf, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+	buf[len] = 0;
+#else
 static ssize_t store_memory(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	const char *p = buf;
 
@@ -3690,23 +3883,49 @@ static ssize_t store_memory(struct devic
 
 	return count;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(memory, S_IWUSR|S_IRUGO, show_memory, store_memory);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_ordinals(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t show_ordinals(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	u32 val = 0;
 	int len = 0;
 	u32 val_len;
 	static int loop = 0;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (offset == 0)
+		loop = 0;
+
+	if (loop >= (sizeof(ord_data) / sizeof(*ord_data))) {
+		*start = NULL;
+		*eof = 1;
+		return 0;
+	}
+
+	/* Return around 2k per pass... */
+	while (count - len > 256 && len < 2048 &&
+	       loop < (sizeof(ord_data) / sizeof(*ord_data))) {
+#else
 	if (loop >= sizeof(ord_data) / sizeof(*ord_data))
 		loop = 0;
 
 	/* sysfs provides us PAGE_SIZE buffer */
 	while (len < PAGE_SIZE - 128 &&
 	       loop < (sizeof(ord_data) / sizeof(*ord_data))) {
+#endif
 		
 		val_len = sizeof(u32);
 
@@ -3722,14 +3941,32 @@ static ssize_t show_ordinals(struct devi
 		loop++;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (len)
+		*start = (char*)len;
+	else
+		*eof = 1;
+#endif
 	return len;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(ordinals, S_IRUGO, show_ordinals, NULL);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_stats(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_stats(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char * out = buf;
 
 	out += sprintf(out, "interrupts: %d {tx: %d, rx: %d, other: %d}\n",
@@ -3744,7 +3981,9 @@ static ssize_t show_stats(struct device 
 
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(stats, S_IRUGO, show_stats, NULL);
+#endif
 
 
 int ipw2100_switch_mode(struct ipw2100_priv *priv, u32 mode)
@@ -3778,9 +4017,11 @@ int ipw2100_switch_mode(struct ipw2100_p
 	
 	priv->ieee->iw_mode = mode;
 
+#ifdef CONFIG_PM
         /* Indicate ipw2100_download_firmware download firmware
 	 * from disk instead of memory. */
 	ipw2100_firmware.version = 0;
+#endif
 
 	priv->reset_backoff = 0;
 	ipw2100_reset_adapter(priv);
@@ -3788,9 +4029,19 @@ int ipw2100_switch_mode(struct ipw2100_p
 	return 0;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_internals(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_internals(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	int len = 0;
 
 #define DUMP_VAR(x,y) len += sprintf(buf + len, # x ": %" # y "\n", priv-> x)
@@ -3834,12 +4085,24 @@ static ssize_t show_internals(struct dev
 
 	return len;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(internals, S_IRUGO, show_internals, NULL);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_bssinfo(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_bssinfo(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char essid[IW_ESSID_MAX_SIZE + 1];
 	u8 bssid[ETH_ALEN];
 	u32 chan = 0;
@@ -3877,20 +4140,43 @@ static ssize_t show_bssinfo(struct devic
 
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(bssinfo, S_IRUGO, show_bssinfo, NULL);
+#endif
 
 
 
 
 #ifdef CONFIG_IPW_DEBUG
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_debug_level(char *buf, char **start, off_t offset,
+			int count, int *eof, void *data)
+{
+#else
 static ssize_t show_debug_level(struct device_driver *d, char *buf)
 {
+#endif
 	return sprintf(buf, "0x%08X\n", ipw2100_debug_level);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_debug_level(struct file *file, const char *user_buffer,
+				unsigned long count, void *data)
+{
+	char buf[] = "0x00000000";
+	unsigned long len =
+	    (sizeof(buf) -1) > count ? count : sizeof(buf) - 1;
+
+	if (copy_from_user(buf, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+	buf[len] = 0;
+#else
 static ssize_t store_debug_level(struct device_driver *d, const char *buf,
 				 size_t count)
 {
+#endif
 	char *p = (char *)buf;
 	u32 val;
 
@@ -3907,16 +4193,30 @@ static ssize_t store_debug_level(struct 
 	else
 		ipw2100_debug_level = val;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return count;
+#else
 	return strnlen(buf, count);
+#endif
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DRIVER_ATTR(debug_level, S_IWUSR | S_IRUGO, show_debug_level,
 		   store_debug_level);
+#endif
 #endif /* CONFIG_IPW_DEBUG */
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_fatal_error(char *buf, char **start, off_t offset,
+			int count, int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t show_fatal_error(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char *out = buf;
 	int i;
 
@@ -3939,25 +4239,53 @@ static ssize_t show_fatal_error(struct d
 	return out - buf;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_fatal_error(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *dev = data;
+	struct ipw2100_priv *priv = netdev_priv(dev);
+#else
 static ssize_t store_fatal_error(struct device *d, const char *buf,
 				 size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	schedule_reset(priv);
 	return count;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(fatal_error, S_IWUSR|S_IRUGO, show_fatal_error, store_fatal_error);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_scan_age(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_scan_age(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	return sprintf(buf, "%d\n", priv->ieee->scan_age);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_scan_age(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t store_scan_age(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	char buffer[] = "00000000";
 	unsigned long len =
@@ -3967,7 +4295,14 @@ static ssize_t store_scan_age(struct dev
 
 	IPW_DEBUG_INFO("enter\n");
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) 
+	if (copy_from_user(buffer, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+#else
 	strncpy(buffer, buf, len);
+#endif
 	buffer[len] = 0;
 
 	if (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {
@@ -3986,11 +4321,26 @@ static ssize_t store_scan_age(struct dev
 	}
 	
 	IPW_DEBUG_INFO("exit\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return count;
+#else
 	return len;
+#endif
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(scan_age, S_IWUSR | S_IRUGO, show_scan_age, store_scan_age);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_rf_kill(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_rf_kill(struct device *d, char *buf)
 {
 	/* 0 - RF kill not enabled
@@ -3998,6 +4348,7 @@ static ssize_t show_rf_kill(struct devic
 	   2 - HW based RF kill active
 	   3 - Both HW and SW baed RF kill active */
 	struct ipw2100_priv *priv = (struct ipw2100_priv *)d->driver_data;
+#endif
 	int val = ((priv->status & STATUS_RF_KILL_SW) ? 0x1 : 0x0) |
 		(rf_kill_active(priv) ? 0x2 : 0x0);
 	return sprintf(buf, "%i\n", val);
@@ -4021,9 +4372,16 @@ static int ipw_radio_kill_sw(struct ipw2
 			IPW_DEBUG_RF_KILL("Can not turn radio back on - "
 					  "disabled by HW switch\n");
 			/* Make sure the RF_KILL check timer is running */
+			priv->stop_rf_kill = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			del_timer_sync(&priv->rf_kill_timer);
+			priv->rf_kill_timer.expires = jiffies + HZ;
+			add_timer(&priv->rf_kill_timer);
+#else
 			cancel_delayed_work(&priv->rf_kill);
 			queue_delayed_work(priv->workqueue, &priv->rf_kill, 
 					   HZ);
+#endif
 		} else 
 			schedule_reset(priv);		
 	}
@@ -4031,15 +4389,34 @@ static int ipw_radio_kill_sw(struct ipw2
 	return 1;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_rf_kill(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	char buf[] = "0";
+	unsigned long len =
+	    (sizeof(buf) - 1) > count ? count : sizeof(buf) - 1;
+
+	if (copy_from_user(buf, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+#else
 static ssize_t store_rf_kill(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	ipw_radio_kill_sw(priv, buf[0] == '1');
 	return count;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(rf_kill, S_IWUSR|S_IRUGO, show_rf_kill, store_rf_kill);
+#endif
 
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
 static struct attribute *ipw2100_sysfs_entries[] = {
 	&dev_attr_hardware.attr,
 	&dev_attr_registers.attr,
@@ -4061,6 +4438,7 @@ static struct attribute *ipw2100_sysfs_e
 static struct attribute_group ipw2100_attribute_group = {
 	.attrs = ipw2100_sysfs_entries,
 };
+#endif
 
 
 static int status_queue_allocate(struct ipw2100_priv *priv, int entries)
@@ -5401,7 +5779,8 @@ static void shim__set_security(struct ie
  * forces a disassocation with force_update...
  *
  *	if (force_update || !(priv->status & STATUS_ASSOCIATED))*/
-	if (!(priv->status & STATUS_ASSOCIATED))
+	if (!(priv->status & STATUS_ASSOCIATED) &&
+	    priv->status & STATUS_SECURITY_UPDATED)
 		ipw2100_configure_security(priv, 0);
 }
 
@@ -5911,6 +6290,7 @@ static int ipw2100_wpa_set_encryption(st
 
 	if (strcmp(param->u.crypt.alg, "none") == 0) {
 		if (crypt){
+			priv->ieee->tx_payload_only = 1;
 			sec.enabled = 0;
 			sec.level = SEC_LEVEL_0;
 			sec.flags |= SEC_ENABLED | SEC_LEVEL;
@@ -5920,6 +6300,7 @@ static int ipw2100_wpa_set_encryption(st
 	}
 	sec.enabled = 1;
 	sec.flags |= SEC_ENABLED;		
+	priv->ieee->tx_payload_only = 0;
 
 	ops = ieee80211_get_crypto_ops(param->u.crypt.alg);
 	if (ops == NULL && strcmp(param->u.crypt.alg, "WEP") == 0) {
@@ -5953,7 +6334,11 @@ static int ipw2100_wpa_set_encryption(st
 		}
 		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
 		new_crypt->ops = ops;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		if (new_crypt->ops && new_crypt->ops->owner && __MOD_INC_USE_COUNT(new_crypt->ops->owner))
+#else
 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
+#endif
 			new_crypt->priv = new_crypt->ops->init(param->u.crypt.idx);
 
 		if (new_crypt->priv == NULL) {
@@ -6126,9 +6511,15 @@ static struct ethtool_ops ipw2100_ethtoo
     .get_drvinfo     = ipw_ethtool_get_drvinfo,
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void ipw2100_hang_check(unsigned long arg)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv *)arg;
+#else
 static void ipw2100_hang_check(void *adapter)
 {
 	struct ipw2100_priv *priv = adapter;
+#endif
 	unsigned long flags;
 	u32 rtc = 0xa5a5a5a5;
 	u32 len = sizeof(rtc);
@@ -6174,15 +6565,25 @@ static void ipw2100_hang_check(void *ada
 
 	/* Check again in two seconds */
 	if (!priv->stop_hang_check)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		mod_timer(&priv->hang_check_timer, jiffies + HZ);
+#else
 		queue_delayed_work(priv->workqueue, &priv->hang_check, HZ);
+#endif
 
 	spin_unlock_irqrestore(&priv->low_lock, flags);
 }
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void ipw2100_rf_kill(unsigned long arg)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv *)arg;
+#else
 static void ipw2100_rf_kill(void *adapter)
 {
 	struct ipw2100_priv *priv = adapter;
+#endif
 	unsigned long flags;
 	
 	spin_lock_irqsave(&priv->low_lock, flags);
@@ -6190,12 +6591,15 @@ static void ipw2100_rf_kill(void *adapte
 	if (rf_kill_active(priv)) {
 		IPW_DEBUG_RF_KILL("RF Kill active, rescheduling GPIO check\n");
 		if (!priv->stop_rf_kill) 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			mod_timer(&priv->rf_kill_timer, jiffies + HZ);
+#else
 			queue_delayed_work(priv->workqueue, &priv->rf_kill, HZ);
+#endif
 		goto exit_unlock;
 	}
 
 	/* RF Kill is now disabled, so bring the device back up */
-
 	if (!(priv->status & STATUS_RF_KILL_MASK)) {
 		IPW_DEBUG_RF_KILL("HW RF Kill no longer active, restarting "
 				  "device\n");
@@ -6343,19 +6747,32 @@ static struct net_device *ipw2100_alloc_
 	INIT_STAT(&priv->fw_pend_stat);
 	
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	priv->workqueue = (void *)1;
+#else
 #ifdef CONFIG_SOFTWARE_SUSPEND2
 	priv->workqueue = create_workqueue(DRV_NAME, 0);
 #else
 	priv->workqueue = create_workqueue(DRV_NAME);
 #endif	
+#endif
 	INIT_WORK(&priv->reset_work, 
 		  (void (*)(void *))ipw2100_reset_adapter, priv);
 	INIT_WORK(&priv->security_work, 
 		  (void (*)(void *))ipw2100_security_work, priv);
 	INIT_WORK(&priv->wx_event_work,
 		  (void (*)(void *))ipw2100_wx_event_work, priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	init_timer(&priv->rf_kill_timer);
+	priv->rf_kill_timer.data = (unsigned long)priv;
+	priv->rf_kill_timer.function = ipw2100_rf_kill;
+	init_timer(&priv->hang_check_timer);
+	priv->hang_check_timer.data = (unsigned long)priv;
+	priv->hang_check_timer.function = ipw2100_hang_check;
+#else
 	INIT_WORK(&priv->hang_check, ipw2100_hang_check, priv);
 	INIT_WORK(&priv->rf_kill, ipw2100_rf_kill, priv);
+#endif
 
 	tasklet_init(&priv->irq_tasklet, (void (*)(unsigned long))
 		     ipw2100_irq_tasklet, (unsigned long)priv);
@@ -6455,7 +6872,9 @@ static int ipw2100_pci_init_one(struct p
 		goto fail;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	SET_NETDEV_DEV(dev, &pci_dev->dev);
+#endif
 
 	/* begin initializing the hardware */
 	ipw2100_disable_interrupts(priv);
@@ -6508,7 +6927,17 @@ static int ipw2100_pci_init_one(struct p
 	IPW_DEBUG_INFO("%s: Bound to %s\n", dev->name, pci_name(pci_dev));
 
 	/* perform this after register_netdev so that dev->name is set */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	err = ipw2100_proc_dev_init(priv);
+	if (err) {
+		printk(KERN_ERR
+		       "%s: Failed to create /proc node\n", dev->name);
+		err = -EIO;
+		goto fail;
+	}
+#else
 	sysfs_create_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);
+#endif
 	netif_carrier_off(dev);
 	
 	/* If the RF Kill switch is disabled, go ahead and complete the
@@ -6544,17 +6973,27 @@ static int ipw2100_pci_init_one(struct p
 		if (priv->workqueue) {
 			priv->stop_rf_kill = 1;
 			priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			del_timer_sync(&priv->hang_check_timer);
+			del_timer_sync(&priv->rf_kill_timer);
+			flush_scheduled_work();
+#else
 			cancel_delayed_work(&priv->hang_check);
 			cancel_delayed_work(&priv->rf_kill);
 			cancel_delayed_work(&priv->wx_event_work);
 			cancel_delayed_work(&priv->reset_work);
 			destroy_workqueue(priv->workqueue);
+#endif
 			priv->workqueue = NULL;
 		}
 
 		/* These are safe to call even if they weren't allocated */
 		ipw2100_queues_free(priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		ipw2100_proc_dev_cleanup(priv);
+#else
 		sysfs_remove_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);
+#endif
 
 		free_netdev(dev);
 		pci_set_drvdata(pci_dev, NULL);
@@ -6576,7 +7015,11 @@ static void __devexit ipw2100_pci_remove
 
 	if (priv) {
 		dev = priv->net_dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		ipw2100_proc_dev_cleanup(priv);
+#else
 		sysfs_remove_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);
+#endif
 
 #ifdef CONFIG_PM
 		if (ipw2100_firmware.version)
@@ -6594,11 +7037,17 @@ static void __devexit ipw2100_pci_remove
 		 * in the workqueue's, so we can safely remove them now. */
 		priv->stop_rf_kill = 1;
 		priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->hang_check_timer);
+		del_timer_sync(&priv->rf_kill_timer);
+		flush_scheduled_work();
+#else
 		cancel_delayed_work(&priv->hang_check);
 		cancel_delayed_work(&priv->rf_kill);
 		cancel_delayed_work(&priv->reset_work);
 		cancel_delayed_work(&priv->wx_event_work);
 		destroy_workqueue(priv->workqueue);
+#endif
 		priv->workqueue = NULL;
 		
 		ieee80211_free(priv->ieee);
@@ -6780,14 +7229,26 @@ static int __init ipw2100_init(void)
 	IPW_DEBUG_INFO(DRV_NAME ": Compiled with LEGACY FW load.\n");
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	ret = pci_module_init(&ipw2100_pci_driver);
+#endif
 
 #ifdef CONFIG_IPW_DEBUG
 	ipw2100_debug_level = debug;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	driver_create_file(&ipw2100_pci_driver.driver,
 			   &driver_attr_debug_level);
 #endif
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	ret = ipw2100_proc_init();
+	if (!ret) {
+		ret = pci_module_init(&ipw2100_pci_driver);
+		if (ret)
+			ipw2100_proc_cleanup();
+	}
+#endif
 	return ret;
 }
 
@@ -6799,10 +7260,15 @@ static void __exit ipw2100_exit(void)
 {
 	/* FIXME: IPG: check that we have no instances of the devices open */
 #ifdef CONFIG_IPW_DEBUG
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	driver_remove_file(&ipw2100_pci_driver.driver,
 			   &driver_attr_debug_level);
 #endif
+#endif
 	pci_unregister_driver(&ipw2100_pci_driver);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	ipw2100_proc_cleanup();
+#endif
 }
 
 module_init(ipw2100_init);
@@ -8056,8 +8522,17 @@ void ipw2100_wx_event_work(struct ipw210
 
       IPW_DEBUG_WX("enter\n");
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+      if (priv->status & STATUS_ASSOCIATED) {
+	  set_current_state(TASK_UNINTERRUPTIBLE);
+	  schedule_timeout(HZ / 10);
+      }
+#endif
       wrqu.ap_addr.sa_family = ARPHRD_ETHER;
       
+      if (priv->status & STATUS_STOPPING)
+	      return;
+
       /* Fetch BSSID from the hardware */
       if (!(priv->status & STATUS_ENABLED) || 
 	  priv->status & STATUS_RF_KILL_MASK || 
@@ -8071,12 +8546,15 @@ void ipw2100_wx_event_work(struct ipw210
 
       if (!(priv->status & STATUS_ASSOCIATED)) {
 	      /* This is a disassociation event, so kick the firmware to 
-	       * look for another AP */
+	       * look for another AP if we are not in an RF kill state */
+	      if (!(priv->status & STATUS_RF_KILL_MASK)) {
 	      if (priv->config & CFG_STATIC_ESSID)
-		      ipw2100_set_essid(priv, priv->essid, priv->essid_len, 0);
+			      ipw2100_set_essid(priv, priv->essid, 
+						priv->essid_len, 0);
 	      else
 		      ipw2100_set_essid(priv, NULL, 0, 0);
       }
+      }
 
       
       wireless_send_event(priv->net_dev, SIOCGIWAP, &wrqu, NULL);
@@ -8101,10 +8579,14 @@ void ipw2100_wx_event_work(struct ipw210
 static char *firmware = NULL;
 
 /* Module paramter for path to the firmware*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+MODULE_PARM(firmware,"s");
+#else
 #include <linux/moduleparam.h>
 module_param(firmware, charp, 0);
+#endif
 
-MODULE_PARM_DEC(firmware, "complete path to firmware file");
+MODULE_PARM_DESC(firmware, "complete path to firmware file");
 
 #endif /* CONFIG_IPW2100_LEGACY_FW_LOAD */
 
@@ -8164,7 +8646,11 @@ static void ipw2100_fw_free(struct ipw21
 }
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int ipw2100_fw_load(int fd, struct ipw2100_fw_chunk_set *cs, long size)
+#else
 static int ipw2100_fw_load(struct file *filp, struct ipw2100_fw_chunk_set *cs, long size)
+#endif
 {
 	struct ipw2100_fw_chunk *c;
 	int i = 0;
@@ -8204,7 +8690,11 @@ static int ipw2100_fw_load(struct file *
 			goto fail;
 			
 		}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		if (read(fd, c->buf, c->len) != c->len) {
+#else
 		if (vfs_read(filp, c->buf, c->len, &filp->f_pos) != c->len) {
+#endif
 			IPW_DEBUG_INFO("Failed to read chunk firmware "
 			       "chunk %d.\n", i);
 			goto fail;
@@ -8225,7 +8715,11 @@ static int ipw2100_fw_load(struct file *
 
 static int ipw2100_do_mod_firmware_load(const char *fn, struct ipw2100_fw *fw)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	int fd;
+#else
 	struct file *filp;
+#endif
 	long l;
 	struct ipw2100_fw_header h;
 
@@ -8234,16 +8728,30 @@ static int ipw2100_do_mod_firmware_load(
 	INIT_LIST_HEAD(&fw->fw.chunk_list);
 	INIT_LIST_HEAD(&fw->uc.chunk_list);
 	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	fd = open(fn, 0, 0);
+	if (fd == -1) {
+#else	
 	filp = filp_open(fn, 0, 0);
 	if (IS_ERR(filp)) {
+#endif
 		IPW_DEBUG_INFO("Unable to load '%s'.\n", fn);
 		return 1;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	l = lseek(fd, 0L, 2);
+	lseek(fd, 0L, 0);
+#else
 	l = i_size_read(filp->f_dentry->d_inode);
+#endif
 	IPW_DEBUG_FW("Loading %ld bytes for firmware '%s'\n", l, fn);
 	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (read(fd, (char *)&h, sizeof(h)) != sizeof(h)) {
+#else	
 	if (vfs_read(filp, (char *)&h, sizeof(h), &filp->f_pos) != sizeof(h)) {
+#endif
 		IPW_DEBUG_INFO("Failed to read '%s'.\n", fn);
 		goto fail;
 	}
@@ -8258,6 +8766,15 @@ static int ipw2100_do_mod_firmware_load(
 
 	fw->version = h.version;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (ipw2100_fw_load(fd, &fw->fw, h.fw_size))
+		goto fail;
+
+	if (ipw2100_fw_load(fd, &fw->uc, h.uc_size))
+		goto fail;
+
+	close(fd);
+#else
 	if (ipw2100_fw_load(filp, &fw->fw, h.fw_size))
 		goto fail;
 
@@ -8265,11 +8782,16 @@ static int ipw2100_do_mod_firmware_load(
 		goto fail;
 
 	filp_close(filp, current->files);
+#endif
 	return 0;
 
  fail:
 	ipw2100_fw_free(fw);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	close(fd);
+#else
 	filp_close(filp, current->files);
+#endif
 	return 1;
 }
 
@@ -8370,7 +8892,7 @@ int ipw2100_get_firmware(struct ipw2100_
 
 	if (!firmware) {
 		switch (priv->ieee->iw_mode) {
-		case IW_MDOE_ADHOC:
+		case IW_MODE_ADHOC:
 			fw_name = "/etc/firmware/" IPW2100_FW_NAME("-i");
 			break;
 #ifdef CONFIG_IPW2100_PROMISC
@@ -8415,7 +8937,11 @@ int ipw2100_get_firmware(struct ipw2100_
 		break;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	rc = request_firmware(&fw->fw_entry, fw_name, pci_name(priv->pci_dev));
+#else
 	rc = request_firmware(&fw->fw_entry, fw_name, &priv->pci_dev->dev);
+#endif
 
 	if (rc < 0) {
 		IPW_DEBUG_ERROR(
@@ -8704,3 +9230,265 @@ int ipw2100_ucode_download(struct ipw210
 
 	return 0;
 }
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+int ipw2100_proc_dev_init(struct ipw2100_priv *priv)
+{
+	struct proc_dir_entry *e;
+
+	IPW_DEBUG_INFO("enter %s\n", priv->net_dev->name);
+
+	priv->dir_dev = create_proc_entry(priv->net_dev->name, 
+					  S_IFDIR | S_IRUGO | S_IXUGO, 
+					  ipw2100_proc);
+	if (!priv->dir_dev) {
+		printk(KERN_ERR
+		       "Unable to initialize /proc/net/ipw2100/%s\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("hardware", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_hardware, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/hardware\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("registers", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_registers, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/registers\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("ordinals", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_ordinals, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/ordinals\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("pci", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_pci, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/pci\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("stats", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_stats, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/stats\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("internals", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_internals, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/internals\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("bssinfo", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_bssinfo, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/bssinfo\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("memory", S_IFREG | S_IRUGO | S_IWUSR,
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_memory;
+		e->write_proc = proc_set_memory;
+		e->data = priv->net_dev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/memory\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("scan_age", S_IFREG | S_IRUGO | S_IWUSR, 
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_scan_age;
+		e->write_proc = proc_set_scan_age;
+		e->data = priv->net_dev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/scan_age\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("fatal_error", S_IFREG | S_IRUGO | S_IWUSR, 
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_fatal_error;
+		e->write_proc = proc_set_fatal_error;
+		e->data = priv->net_dev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/fatal_error\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("rf_kill", S_IFREG | S_IRUGO | S_IWUSR,
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_rf_kill;
+		e->write_proc = proc_set_rf_kill;
+		e->data = priv->net_dev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/rf_kill\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("cfg", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_cfg, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/cfg\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("status", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_status, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/status\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("capability", S_IFREG | S_IRUGO, 
+				   priv->dir_dev, proc_get_capability, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/capability\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	IPW_DEBUG_INFO("exit %s\n", priv->net_dev->name);
+
+	return 0;
+
+ fail:
+	ipw2100_proc_dev_cleanup(priv);
+	IPW_DEBUG_INFO("exit on fail %s\n", priv->net_dev->name);
+	
+	return -ENOMEM;
+}
+
+void ipw2100_proc_dev_cleanup(struct ipw2100_priv *priv)
+{
+	IPW_DEBUG_INFO("enter %s\n", priv->net_dev->name);
+
+	if (priv->dir_dev) {
+		remove_proc_entry("hardware", priv->dir_dev);
+		remove_proc_entry("registers", priv->dir_dev);
+		remove_proc_entry("ordinals", priv->dir_dev);
+		remove_proc_entry("pci", priv->dir_dev);
+		remove_proc_entry("stats", priv->dir_dev);
+		remove_proc_entry("internals", priv->dir_dev);
+		remove_proc_entry("bssinfo", priv->dir_dev);
+		remove_proc_entry("memory", priv->dir_dev);
+		remove_proc_entry("scan_age", priv->dir_dev);
+		remove_proc_entry("fatal_error", priv->dir_dev);
+		remove_proc_entry("rf_kill", priv->dir_dev);
+		remove_proc_entry("cfg", priv->dir_dev);
+		remove_proc_entry("status", priv->dir_dev);
+		remove_proc_entry("capability", priv->dir_dev);
+		remove_proc_entry(priv->net_dev->name, ipw2100_proc);
+		priv->dir_dev = NULL;
+	}
+
+	IPW_DEBUG_INFO("exit %s\n", priv->net_dev->name);
+}
+
+static int ipw2100_proc_init(void)
+{	
+	struct proc_dir_entry *e;
+	
+	IPW_DEBUG_INFO("enter\n");
+
+	ipw2100_proc = create_proc_entry(DRV_NAME, S_IFDIR, proc_net);
+	if (ipw2100_proc == NULL)
+		goto fail_ipw2100;
+
+#ifdef CONFIG_IPW_DEBUG
+	e = create_proc_entry("debug_level", S_IFREG | S_IRUGO | S_IWUSR, 
+			      ipw2100_proc);
+	if (e == NULL)
+		goto fail_debug;
+	e->read_proc = proc_get_debug_level;
+	e->write_proc = proc_set_debug_level;
+	e->data = NULL;
+
+	IPW_DEBUG_INFO("exit\n");
+	return 0;
+
+fail_debug:
+	printk(KERN_ERR DRV_NAME ": Unable to initialize "
+	       "/proc/net/" DRV_NAME "/debug_level\n");
+	remove_proc_entry(DRV_NAME, proc_net);
+	ipw2100_proc = NULL;
+	goto fail;
+#endif
+
+fail_ipw2100:
+	printk(KERN_ERR DRV_NAME ": Unable to initialize " 
+	      "/proc/net/" DRV_NAME "\n");
+
+fail:
+	IPW_DEBUG_INFO("exit on fail\n");	
+	return -ENOMEM;
+}
+
+static void ipw2100_proc_cleanup(void)
+{
+	IPW_DEBUG_INFO("enter\n");
+
+#ifdef CONFIG_IPW_DEBUG
+	if (ipw2100_proc)
+		remove_proc_entry("debug_level", ipw2100_proc);
+#endif
+	remove_proc_entry(DRV_NAME, proc_net);
+	IPW_DEBUG_INFO("exit\n");
+}
+#endif
diff -u -p -r -b ipw2100-0.61-0/ipw2100.h ipw2100-0.61-2/ipw2100.h
--- ipw2100-0.61-0/ipw2100.h	2004-11-08 23:11:42.000000000 +0100
+++ ipw2100-0.61-2/ipw2100.h	2004-11-10 18:10:04.000000000 +0100
@@ -42,7 +42,21 @@
 
 #include "ieee80211.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int errno;
+#define get_seconds() CURRENT_TIME
+#include <linux/tqueue.h>
+#define work_struct tq_struct
+#define INIT_WORK INIT_TQUEUE
+#define queue_work(x,y) schedule_task(y)
+#define flush_scheduled_work() flush_scheduled_tasks()
+#else
 #include <linux/workqueue.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27)
+static inline void *netdev_priv(struct net_device *dev) { return dev->priv; }
+#endif
 
 #ifndef IRQ_NONE
 typedef void irqreturn_t;
@@ -485,10 +499,8 @@ enum {
 #define STATUS_POWERED          BIT(0)
 #define STATUS_CMD_ACTIVE       BIT(1)  /**< host command in progress */
 #define STATUS_RUNNING          BIT(2)  /* Card initialized, but not enabled */
-#define STATUS_ENABLED          BIT(3)  /* Card enabled -- can scann,Tx,Rx */
-#define STATUS_HOST_COMPLETE    BIT(5)  /**< Ready to Tx/Rx (HostComplete)  */
-#define STATUS_WEP              BIT(7)  /**< use WEP */
-#define STATUS_ERROR            BIT(8)  /**< Error state.  Needs restart. */
+#define STATUS_ENABLED          BIT(3)  /* Card enabled -- can scan,Tx,Rx */
+#define STATUS_STOPPING         BIT(4)  /* Card is in shutdown phase */
 #define STATUS_ASSOCIATED       BIT(9)
 #define STATUS_INT_ENABLED      BIT(11)
 #define STATUS_RF_KILL_HW       BIT(12)
@@ -635,8 +647,13 @@ struct ipw2100_priv {
 	struct work_struct reset_work;
 	struct work_struct security_work;
 	struct work_struct wx_event_work;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	struct timer_list hang_check_timer;
+	struct timer_list rf_kill_timer;
+#else
 	struct work_struct hang_check;
 	struct work_struct rf_kill;
+#endif
 	
 	u32 interrupts;
 	int tx_interrupts;
@@ -1280,4 +1297,12 @@ int ipw2100_ucode_download(struct ipw210
 int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf, size_t max);
 int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf, size_t max);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static struct proc_dir_entry *ipw2100_proc = NULL;
+static int ipw2100_proc_init(void);
+static void ipw2100_proc_cleanup(void);
+static int ipw2100_proc_dev_init(struct ipw2100_priv *priv);
+static void ipw2100_proc_dev_cleanup(struct ipw2100_priv *priv);
+#endif
+
 #endif /* _IPW2100_H */
