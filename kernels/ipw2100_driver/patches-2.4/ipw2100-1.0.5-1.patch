diff -u -p -r -b ipw2100-1.0.5-0/Makefile ipw2100-1.0.5-1/Makefile
--- ipw2100-1.0.5-0/Makefile	2005-02-09 11:36:00.000000000 +0100
+++ ipw2100-1.0.5-1/Makefile	2005-02-09 11:35:42.000000000 +0100
@@ -202,6 +202,8 @@ modules:
 
 endif # End 2.4 / 2.6 specific
 
+ifeq ($(OLDMAKE),)
+
 install: modules
 	install -d $(KMISC)
 	install -m 644 -c $(addsuffix .ko,$(list-m)) $(KMISC)
@@ -214,6 +216,22 @@ uninstall:
 	rm -rf $(addprefix $(KMISC),$(addsuffix .ko,$(list-m)))
 	/sbin/depmod -a
 
+else
+
+install: modules
+	install -d $(KMISC)
+	install -m 644 -c $(addsuffix .o,$(list-m)) $(KMISC)
+	/sbin/depmod -a
+	@echo "Don't forget to copy firmware to /usr/lib/hotplug/firmware/ and have the "
+	@echo "hotplug tools in place."
+	@echo "See INSTALL for more information."
+
+uninstall:
+	rm -rf $(addprefix $(KMISC),$(addsuffix .o,$(list-m)))
+	/sbin/depmod -a
+
+endif
+
 endif # End of internal build
 
 
diff -u -p -r -b ipw2100-1.0.5-0/ieee80211.h ipw2100-1.0.5-1/ieee80211.h
--- ipw2100-1.0.5-0/ieee80211.h	2005-02-08 21:38:23.000000000 +0100
+++ ipw2100-1.0.5-1/ieee80211.h	2005-02-09 11:36:41.000000000 +0100
@@ -740,6 +740,9 @@ struct ieee80211_device {
 #define IEEE_G            BIT(2)
 #define IEEE_MODE_MASK    (IEEE_A|IEEE_B|IEEE_G)
 
+#ifndef HAVE_NETDEV_PRIV
+static inline void *netdev_priv(struct net_device *dev) { return dev->priv; }
+#endif
 extern inline void *ieee80211_priv(struct net_device *dev)
 {
 	return ((struct ieee80211_device *)netdev_priv(dev))->priv;
diff -u -p -r -b ipw2100-1.0.5-0/ieee80211_crypt.c ipw2100-1.0.5-1/ieee80211_crypt.c
--- ipw2100-1.0.5-0/ieee80211_crypt.c	2005-02-08 21:38:23.000000000 +0100
+++ ipw2100-1.0.5-1/ieee80211_crypt.c	2005-02-09 11:36:40.000000000 +0100
@@ -55,7 +55,11 @@ void ieee80211_crypt_deinit_entries(stru
 
 		if (entry->ops) {
 			entry->ops->deinit(entry->priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			if (entry->ops->owner) __MOD_DEC_USE_COUNT(entry->ops->owner);
+#else
 			module_put(entry->ops->owner);
+#endif
 		}
 		kfree(entry);
 	}
diff -u -p -r -b ipw2100-1.0.5-0/ieee80211_module.c ipw2100-1.0.5-1/ieee80211_module.c
--- ipw2100-1.0.5-0/ieee80211_module.c	2005-02-08 21:38:23.000000000 +0100
+++ ipw2100-1.0.5-1/ieee80211_module.c	2005-02-09 11:36:40.000000000 +0100
@@ -176,7 +176,11 @@ void free_ieee80211(struct net_device *d
 		if (crypt) {
 			if (crypt->ops) {
 				crypt->ops->deinit(crypt->priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+				if (crypt->ops->owner) __MOD_DEC_USE_COUNT(crypt->ops->owner);
+#else
 				module_put(crypt->ops->owner);
+#endif
 			}
 			kfree(crypt);
 			ieee->crypt[i] = NULL;
@@ -261,8 +265,13 @@ static void __exit ieee80211_exit(void)
 	}
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+MODULE_PARM(debug, "i");
+#else
 #include <linux/moduleparam.h>
 module_param(debug, int, 0444);
+#endif
+
 MODULE_PARM_DESC(debug, "debug output mask");
 
 
diff -u -p -r -b ipw2100-1.0.5-0/ieee80211_wx.c ipw2100-1.0.5-1/ieee80211_wx.c
--- ipw2100-1.0.5-0/ieee80211_wx.c	2005-02-08 21:38:23.000000000 +0100
+++ ipw2100-1.0.5-1/ieee80211_wx.c	2005-02-09 11:36:40.000000000 +0100
@@ -378,7 +378,11 @@ int ieee80211_wx_set_encode(struct ieee8
 			new_crypt->ops = ieee80211_get_crypto_ops("WEP");
 		}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		if (new_crypt->ops && new_crypt->ops->owner && __MOD_INC_USE_COUNT(new_crypt->ops->owner))
+#else
 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
+#endif
 			new_crypt->priv = new_crypt->ops->init(key);
 
 		if (!new_crypt->ops || !new_crypt->priv) {
diff -u -p -r -b ipw2100-1.0.5-0/ipw2100.c ipw2100-1.0.5-1/ipw2100.c
--- ipw2100-1.0.5-0/ipw2100.c	2005-02-08 21:38:23.000000000 +0100
+++ ipw2100-1.0.5-1/ipw2100.c	2005-02-09 11:36:41.000000000 +0100
@@ -161,12 +161,18 @@ that only one external action is invoked
 #include <linux/version.h>
 #include <linux/time.h>
 #include <linux/firmware.h>
+#ifdef CONFIG_ACPI
 #include <linux/acpi.h>
+#endif
 #include <linux/ctype.h>
 
 #include "ipw2100.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define IPW2100_VERSION "1.0.5-1"
+#else
 #define IPW2100_VERSION "1.0.5"
+#endif
 
 #define DRV_NAME	"ipw2100"
 #define DRV_VERSION	IPW2100_VERSION
@@ -180,7 +186,9 @@ that only one external action is invoked
 #endif
 
 MODULE_DESCRIPTION(DRV_DESCRIPTION);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 MODULE_VERSION(DRV_VERSION);
+#endif
 MODULE_AUTHOR(DRV_COPYRIGHT);
 MODULE_LICENSE("GPL");
 
@@ -193,12 +201,21 @@ static int disable = 0;
 static struct ipw2100_fw ipw2100_firmware;
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+MODULE_PARM(debug, "i");
+MODULE_PARM(ifname, "s");
+MODULE_PARM(mode, "i");
+MODULE_PARM(channel, "i");
+MODULE_PARM(associate, "i");
+MODULE_PARM(disable, "i");
+#else
 #include <linux/moduleparam.h>
 module_param(debug, int, 0444);
 module_param(mode, int, 0444);
 module_param(channel, int, 0444);
 module_param(associate, int, 0444);
 module_param(disable, int, 0444);
+#endif
 
 MODULE_PARM_DESC(debug, "debug level");
 MODULE_PARM_DESC(mode, "network mode (0=BSS,1=IBSS,2=Monitor)");
@@ -656,8 +673,12 @@ static inline void schedule_reset(struct
 		netif_stop_queue(priv->net_dev);
 		priv->status |= STATUS_RESET_PENDING;
 		if (priv->reset_backoff)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			queue_work(priv->workqueue, &priv->reset_work);
+#else
 			queue_delayed_work(priv->workqueue, &priv->reset_work,
 					   priv->reset_backoff * HZ);
+#endif
 		else
 			queue_work(priv->workqueue, &priv->reset_work);
 
@@ -746,9 +767,15 @@ static int ipw2100_hw_send_command(struc
 	 * then there is a problem.
 	 */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	err = interruptible_sleep_on_timeout(
+		&priv->wait_command_queue,
+		HOST_COMPLETE_TIMEOUT);
+#else
 	err = wait_event_interruptible_timeout(
 		priv->wait_command_queue, !(priv->status & STATUS_CMD_ACTIVE),
 		HOST_COMPLETE_TIMEOUT);
+#endif
 
 	if (err == 0) {
 		IPW_DEBUG_INFO("Command completion failed out after %dms.\n",
@@ -1430,7 +1457,12 @@ static int ipw2100_enable_adapter(struct
 
 	if (priv->stop_hang_check) {
 		priv->stop_hang_check = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		priv->hang_check_timer.expires = jiffies + HZ / 2;
+		add_timer(&priv->hang_check_timer);
+#else
 		queue_delayed_work(priv->workqueue, &priv->hang_check, HZ / 2);
+#endif
 	}
 
 fail_up:
@@ -1565,7 +1597,11 @@ static int ipw2100_disable_adapter(struc
 
 	if (!priv->stop_hang_check) {
 		priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->hang_check_timer);
+#else
 		cancel_delayed_work(&priv->hang_check);
+#endif
 	}
 
 	down(&priv->adapter_sem);
@@ -1730,7 +1766,12 @@ static int ipw2100_up(struct ipw2100_pri
 
 		if (priv->stop_rf_kill) {
 			priv->stop_rf_kill = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			priv->rf_kill_timer.expires = jiffies + HZ;
+			add_timer(&priv->rf_kill_timer);
+#else
 			queue_delayed_work(priv->workqueue, &priv->rf_kill, HZ);
+#endif
 		}
 
 		deferred = 1;
@@ -1789,18 +1830,28 @@ static void ipw2100_down(struct ipw2100_
 	/* Kill the RF switch timer */
 	if (!priv->stop_rf_kill) {
 		priv->stop_rf_kill = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->rf_kill_timer);
+#else
 		cancel_delayed_work(&priv->rf_kill);
+#endif
 	}
 
 	/* Kill the firmare hang check timer */
 	if (!priv->stop_hang_check) {
 		priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->hang_check_timer);
+#else
 		cancel_delayed_work(&priv->hang_check);
+#endif
 	}
 
 	/* Kill any pending resets */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	if (priv->status & STATUS_RESET_PENDING)
 		cancel_delayed_work(&priv->reset_work);
+#endif
 
 	/* Make sure the interrupt is on so that FW commands will be
 	 * processed correctly */
@@ -1846,6 +1897,12 @@ void ipw2100_reset_adapter(struct ipw210
 	};
 	int associated = priv->status & STATUS_ASSOCIATED;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (priv->reset_backoff) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(priv->reset_backoff * HZ);
+	}
+#endif
 	spin_lock_irqsave(&priv->low_lock, flags);
 	IPW_DEBUG_INFO(DRV_NAME ": %s: Restarting adapter.\n",
 		       priv->net_dev->name);
@@ -1855,14 +1912,20 @@ void ipw2100_reset_adapter(struct ipw210
 
 	/* Force a power cycle even if interface hasn't been opened
 	 * yet */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	cancel_delayed_work(&priv->reset_work);
+#endif
 	priv->status |= STATUS_RESET_PENDING;
 	spin_unlock_irqrestore(&priv->low_lock, flags);
 
 	down(&priv->action_sem);
 	/* stop timed checks so that they don't interfere with reset */
 	priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	del_timer_sync(&priv->hang_check_timer);
+#else
 	cancel_delayed_work(&priv->hang_check);
+#endif
 
 	/* We have to signal any supplicant if we are disassociating */
 	if (associated)
@@ -1962,7 +2025,11 @@ static void isr_indicate_associated(stru
 	priv->status |= STATUS_ASSOCIATING;
 	priv->connect_start = get_seconds();
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	queue_work(priv->workqueue, &priv->wx_event_work);
+#else
 	queue_delayed_work(priv->workqueue, &priv->wx_event_work, HZ / 10);
+#endif
 }
 
 
@@ -2065,8 +2132,12 @@ static void isr_indicate_rf_kill(struct 
 
 	/* Make sure the RF Kill check timer is running */
 	priv->stop_rf_kill = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	mod_timer(&priv->rf_kill_timer, jiffies + HZ);
+#else
 	cancel_delayed_work(&priv->rf_kill);
 	queue_delayed_work(priv->workqueue, &priv->rf_kill, HZ);
+#endif
 }
 
 static void isr_scan_complete(struct ipw2100_priv *priv, u32 status)
@@ -3383,9 +3454,20 @@ static void ipw2100_msg_free(struct ipw2
 	priv->msg_buffers = NULL;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_pci(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+	struct pci_dev *pci_dev = priv->pci_dev;
+	*eof = 1;
+#else
 static ssize_t show_pci(struct device *d, char *buf)
 {
 	struct pci_dev *pci_dev = container_of(d, struct pci_dev, dev);
+#endif
 	char *out = buf;
 	int i, j;
 	u32 val;
@@ -3401,28 +3483,66 @@ static ssize_t show_pci(struct device *d
 
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(pci, S_IRUGO, show_pci, NULL);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_cfg(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *p = ieee80211_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_cfg(struct device *d, char *buf)
 {
 	struct ipw2100_priv *p = (struct ipw2100_priv *)d->driver_data;
+#endif
 	return sprintf(buf, "0x%08x\n", (int)p->config);
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(cfg, S_IRUGO, show_cfg, NULL);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_status(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *p = ieee80211_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_status(struct device *d, char *buf)
 {
 	struct ipw2100_priv *p = (struct ipw2100_priv *)d->driver_data;
+#endif
 	return sprintf(buf, "0x%08x\n", (int)p->status);
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(status, S_IRUGO, show_status, NULL);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_capability(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *p = ieee80211_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_capability(struct device *d, char *buf)
 {
 	struct ipw2100_priv *p = (struct ipw2100_priv *)d->driver_data;
+#endif
 	return sprintf(buf, "0x%08x\n", (int)p->capability);
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(capability, S_IRUGO, show_capability, NULL);
+#endif
 
 
 #define IPW2100_REG(x) { IPW_ ##x, #x }
@@ -3602,10 +3722,21 @@ const struct {
 };
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_registers(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	int i;
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_registers(struct device *d, char *buf)
 {
 	int i;
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	char * out = buf;
 	u32 val = 0;
@@ -3620,12 +3751,24 @@ static ssize_t show_registers(struct dev
 
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(registers, S_IRUGO, show_registers, NULL);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_hardware(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_hardware(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	char * out = buf;
 	int i;
@@ -3660,12 +3803,23 @@ static ssize_t show_hardware(struct devi
 	}
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(hardware, S_IRUGO, show_hardware, NULL);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_memory(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+#else
 static ssize_t show_memory(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	static unsigned long loop = 0;
 	int len = 0;
@@ -3673,11 +3827,25 @@ static ssize_t show_memory(struct device
 	int i;
 	char line[81];
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (offset == 0)
+		loop = 0;
+
+	if (loop >= 0x30000) {
+		*start = NULL;
+		*eof = 1;
+		return 0;
+	}
+
+	/* Return around 2k per pass... */
+	while (count - len > 256 && len < 2048 && loop < 0x30000) {
+#else
 	if (loop >= 0x30000)
 		loop = 0;
 
 	/* sysfs provides us PAGE_SIZE buffer */
 	while (len < PAGE_SIZE - 128 && loop < 0x30000) {
+#endif
 
 		if (priv->snapshot[0]) for (i = 0; i < 4; i++)
 			buffer[i] = *(u32 *)SNAPSHOT_ADDR(loop + i * 4);
@@ -3713,12 +3881,35 @@ static ssize_t show_memory(struct device
 		loop += 16;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (len)
+		*start = (char*)len;
+	else
+		*eof = 1;
+#endif
 	return len;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_memory(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+	char buf[] = "00000";
+	unsigned long len =
+	    (sizeof(buf) - 1) > count ? count : sizeof(buf) - 1;
+
+	if (copy_from_user(buf, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+	buf[len] = 0;
+#else
 static ssize_t store_memory(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	const char *p = buf;
 
@@ -3749,23 +3940,49 @@ static ssize_t store_memory(struct devic
 
 	return count;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(memory, S_IWUSR|S_IRUGO, show_memory, store_memory);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_ordinals(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+#else
 static ssize_t show_ordinals(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	u32 val = 0;
 	int len = 0;
 	u32 val_len;
 	static int loop = 0;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (offset == 0)
+		loop = 0;
+
+	if (loop >= (sizeof(ord_data) / sizeof(*ord_data))) {
+		*start = NULL;
+		*eof = 1;
+		return 0;
+	}
+
+	/* Return around 2k per pass... */
+	while (count - len > 256 && len < 2048 &&
+	       loop < (sizeof(ord_data) / sizeof(*ord_data))) {
+#else
 	if (loop >= sizeof(ord_data) / sizeof(*ord_data))
 		loop = 0;
 
 	/* sysfs provides us PAGE_SIZE buffer */
 	while (len < PAGE_SIZE - 128 &&
 	       loop < (sizeof(ord_data) / sizeof(*ord_data))) {
+#endif
 
 		val_len = sizeof(u32);
 
@@ -3781,14 +3998,32 @@ static ssize_t show_ordinals(struct devi
 		loop++;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (len)
+		*start = (char*)len;
+	else
+		*eof = 1;
+#endif
 	return len;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(ordinals, S_IRUGO, show_ordinals, NULL);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_stats(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_stats(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char * out = buf;
 
 	out += sprintf(out, "interrupts: %d {tx: %d, rx: %d, other: %d}\n",
@@ -3803,7 +4038,9 @@ static ssize_t show_stats(struct device 
 
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(stats, S_IRUGO, show_stats, NULL);
+#endif
 
 
 int ipw2100_switch_mode(struct ipw2100_priv *priv, u32 mode)
@@ -3851,9 +4088,19 @@ int ipw2100_switch_mode(struct ipw2100_p
 	return 0;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_internals(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_internals(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	int len = 0;
 
 #define DUMP_VAR(x,y) len += sprintf(buf + len, # x ": %" # y "\n", priv-> x)
@@ -3899,12 +4146,24 @@ static ssize_t show_internals(struct dev
 
 	return len;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(internals, S_IRUGO, show_internals, NULL);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_bssinfo(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_bssinfo(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char essid[IW_ESSID_MAX_SIZE + 1];
 	u8 bssid[ETH_ALEN];
 	u32 chan = 0;
@@ -3942,20 +4201,44 @@ static ssize_t show_bssinfo(struct devic
 
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(bssinfo, S_IRUGO, show_bssinfo, NULL);
+#endif
 
 
 
 
 #ifdef CONFIG_IPW_DEBUG
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_debug_level(char *buf, char **start, off_t offset,
+			int count, int *eof, void *data)
+{
+	*eof = 1;
+#else
 static ssize_t show_debug_level(struct device_driver *d, char *buf)
 {
+#endif
 	return sprintf(buf, "0x%08X\n", ipw2100_debug_level);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_debug_level(struct file *file, const char *user_buffer,
+				unsigned long count, void *data)
+{
+	char buf[] = "0x00000000";
+	unsigned long len =
+	    (sizeof(buf) -1) > count ? count : sizeof(buf) - 1;
+
+	if (copy_from_user(buf, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+	buf[len] = 0;
+#else
 static ssize_t store_debug_level(struct device_driver *d, const char *buf,
 				 size_t count)
 {
+#endif
 	char *p = (char *)buf;
 	u32 val;
 
@@ -3972,16 +4255,31 @@ static ssize_t store_debug_level(struct 
 	else
 		ipw2100_debug_level = val;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return count;
+#else
 	return strnlen(buf, count);
+#endif
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DRIVER_ATTR(debug_level, S_IWUSR | S_IRUGO, show_debug_level,
 		   store_debug_level);
+#endif
 #endif /* CONFIG_IPW_DEBUG */
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_fatal_error(char *buf, char **start, off_t offset,
+			int count, int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_fatal_error(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char *out = buf;
 	int i;
 
@@ -4004,25 +4302,53 @@ static ssize_t show_fatal_error(struct d
 	return out - buf;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_fatal_error(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+#else
 static ssize_t store_fatal_error(struct device *d, const char *buf,
 				 size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	schedule_reset(priv);
 	return count;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(fatal_error, S_IWUSR|S_IRUGO, show_fatal_error, store_fatal_error);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_scan_age(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_scan_age(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	return sprintf(buf, "%d\n", priv->ieee->scan_age);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_scan_age(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+#else
 static ssize_t store_scan_age(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	char buffer[] = "00000000";
 	unsigned long len =
@@ -4032,7 +4358,14 @@ static ssize_t store_scan_age(struct dev
 
 	IPW_DEBUG_INFO("enter\n");
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (copy_from_user(buffer, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+#else
 	strncpy(buffer, buf, len);
+#endif
 	buffer[len] = 0;
 
 	if (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {
@@ -4051,11 +4384,26 @@ static ssize_t store_scan_age(struct dev
 	}
 
 	IPW_DEBUG_INFO("exit\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return count;
+#else
 	return len;
+#endif
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(scan_age, S_IWUSR | S_IRUGO, show_scan_age, store_scan_age);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_rf_kill(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_rf_kill(struct device *d, char *buf)
 {
 	/* 0 - RF kill not enabled
@@ -4063,6 +4411,7 @@ static ssize_t show_rf_kill(struct devic
 	   2 - HW based RF kill active
 	   3 - Both HW and SW baed RF kill active */
 	struct ipw2100_priv *priv = (struct ipw2100_priv *)d->driver_data;
+#endif
 	int val = ((priv->status & STATUS_RF_KILL_SW) ? 0x1 : 0x0) |
 		(rf_kill_active(priv) ? 0x2 : 0x0);
 	return sprintf(buf, "%i\n", val);
@@ -4089,9 +4438,13 @@ static int ipw_radio_kill_sw(struct ipw2
 					  "disabled by HW switch\n");
 			/* Make sure the RF_KILL check timer is running */
 			priv->stop_rf_kill = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			mod_timer(&priv->rf_kill_timer, jiffies + HZ);
+#else
 			cancel_delayed_work(&priv->rf_kill);
 			queue_delayed_work(priv->workqueue, &priv->rf_kill,
 					   HZ);
+#endif
 		} else
 			schedule_reset(priv);
 	}
@@ -4100,15 +4453,34 @@ static int ipw_radio_kill_sw(struct ipw2
 	return 1;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_rf_kill(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = ieee80211_priv(device);
+	char buf[] = "0";
+	unsigned long len =
+	    (sizeof(buf) - 1) > count ? count : sizeof(buf) - 1;
+
+	if (copy_from_user(buf, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+#else
 static ssize_t store_rf_kill(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	ipw_radio_kill_sw(priv, buf[0] == '1');
 	return count;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(rf_kill, S_IWUSR|S_IRUGO, show_rf_kill, store_rf_kill);
+#endif
 
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
 static struct attribute *ipw2100_sysfs_entries[] = {
 	&dev_attr_hardware.attr,
 	&dev_attr_registers.attr,
@@ -4130,6 +4502,7 @@ static struct attribute *ipw2100_sysfs_e
 static struct attribute_group ipw2100_attribute_group = {
 	.attrs = ipw2100_sysfs_entries,
 };
+#endif
 
 
 static int status_queue_allocate(struct ipw2100_priv *priv, int entries)
@@ -4227,12 +4600,18 @@ static void ipw2100_kill_workqueue(struc
 	if (priv->workqueue) {
 		priv->stop_rf_kill = 1;
 		priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->hang_check_timer);
+		del_timer_sync(&priv->rf_kill_timer);
+		flush_scheduled_work();
+#else
 		cancel_delayed_work(&priv->reset_work);
 		cancel_delayed_work(&priv->security_work);
 		cancel_delayed_work(&priv->wx_event_work);
 		cancel_delayed_work(&priv->hang_check);
 		cancel_delayed_work(&priv->rf_kill);
 		destroy_workqueue(priv->workqueue);
+#endif
 		priv->workqueue = NULL;
 	}
 }
@@ -6032,7 +6411,11 @@ static int ipw2100_wpa_set_encryption(st
 		}
 		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
 		new_crypt->ops = ops;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		if (new_crypt->ops && new_crypt->ops->owner && __MOD_INC_USE_COUNT(new_crypt->ops->owner))
+#else
 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
+#endif
 			new_crypt->priv = new_crypt->ops->init(param->u.crypt.idx);
 
 		if (new_crypt->priv == NULL) {
@@ -6205,9 +6588,15 @@ static struct ethtool_ops ipw2100_ethtoo
     .get_drvinfo     = ipw_ethtool_get_drvinfo,
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void ipw2100_hang_check(unsigned long arg)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv *)arg;
+#else
 static void ipw2100_hang_check(void *adapter)
 {
 	struct ipw2100_priv *priv = adapter;
+#endif
 	unsigned long flags;
 	u32 rtc = 0xa5a5a5a5;
 	u32 len = sizeof(rtc);
@@ -6242,15 +6631,25 @@ static void ipw2100_hang_check(void *ada
 	priv->last_rtc = rtc;
 
 	if (!priv->stop_hang_check)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		mod_timer(&priv->hang_check_timer, jiffies + HZ / 2);
+#else
 		queue_delayed_work(priv->workqueue, &priv->hang_check, HZ / 2);
+#endif
 
 	spin_unlock_irqrestore(&priv->low_lock, flags);
 }
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void ipw2100_rf_kill(unsigned long arg)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv *)arg;
+#else
 static void ipw2100_rf_kill(void *adapter)
 {
 	struct ipw2100_priv *priv = adapter;
+#endif
 	unsigned long flags;
 
 	spin_lock_irqsave(&priv->low_lock, flags);
@@ -6258,7 +6657,11 @@ static void ipw2100_rf_kill(void *adapte
 	if (rf_kill_active(priv)) {
 		IPW_DEBUG_RF_KILL("RF Kill active, rescheduling GPIO check\n");
 		if (!priv->stop_rf_kill)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			mod_timer(&priv->rf_kill_timer, jiffies + HZ);
+#else
 			queue_delayed_work(priv->workqueue, &priv->rf_kill, HZ);
+#endif
 		goto exit_unlock;
 	}
 
@@ -6401,19 +6804,32 @@ static struct net_device *ipw2100_alloc_
 	INIT_STAT(&priv->fw_pend_stat);
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	priv->workqueue = (void *)1;
+#else
 #ifdef CONFIG_SOFTWARE_SUSPEND2
 	priv->workqueue = create_workqueue(DRV_NAME, 0);
 #else
 	priv->workqueue = create_workqueue(DRV_NAME);
 #endif
+#endif
 	INIT_WORK(&priv->reset_work,
 		  (void (*)(void *))ipw2100_reset_adapter, priv);
 	INIT_WORK(&priv->security_work,
 		  (void (*)(void *))ipw2100_security_work, priv);
 	INIT_WORK(&priv->wx_event_work,
 		  (void (*)(void *))ipw2100_wx_event_work, priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	init_timer(&priv->rf_kill_timer);
+	priv->rf_kill_timer.data = (unsigned long)priv;
+	priv->rf_kill_timer.function = ipw2100_rf_kill;
+	init_timer(&priv->hang_check_timer);
+	priv->hang_check_timer.data = (unsigned long)priv;
+	priv->hang_check_timer.function = ipw2100_hang_check;
+#else
 	INIT_WORK(&priv->hang_check, ipw2100_hang_check, priv);
 	INIT_WORK(&priv->rf_kill, ipw2100_rf_kill, priv);
+#endif
 
 	tasklet_init(&priv->irq_tasklet, (void (*)(unsigned long))
 		     ipw2100_irq_tasklet, (unsigned long)priv);
@@ -6513,7 +6929,9 @@ static int ipw2100_pci_init_one(struct p
 		goto fail;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	SET_NETDEV_DEV(dev, &pci_dev->dev);
+#endif
 
 	/* Force interrupts to be shut off on the device */
 	priv->status |= STATUS_INT_ENABLED;
@@ -6568,7 +6986,17 @@ static int ipw2100_pci_init_one(struct p
 	IPW_DEBUG_INFO("%s: Bound to %s\n", dev->name, pci_name(pci_dev));
 
 	/* perform this after register_netdev so that dev->name is set */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	err = ipw2100_proc_dev_init(priv);
+	if (err) {
+		printk(KERN_ERR
+		       "%s: Failed to create /proc node\n", dev->name);
+		err = -EIO;
+		goto fail;
+	}
+#else
 	sysfs_create_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);
+#endif
 	netif_carrier_off(dev);
 
 	/* If the RF Kill switch is disabled, go ahead and complete the
@@ -6616,7 +7044,11 @@ static int ipw2100_pci_init_one(struct p
 
 		/* These are safe to call even if they weren't allocated */
 		ipw2100_queues_free(priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		ipw2100_proc_dev_cleanup(priv);
+#else
 		sysfs_remove_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);
+#endif
 
 		free_ieee80211(dev);
 		pci_set_drvdata(pci_dev, NULL);
@@ -6642,7 +7074,11 @@ static void __devexit ipw2100_pci_remove
 		priv->status &= ~STATUS_INITIALIZED;
 
 		dev = priv->net_dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		ipw2100_proc_dev_cleanup(priv);
+#else
 		sysfs_remove_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);
+#endif
 
 #ifdef CONFIG_PM
 		if (ipw2100_firmware.version)
@@ -6861,14 +7297,26 @@ static int __init ipw2100_init(void)
 	IPW_DEBUG_INFO(DRV_NAME ": Compiled with WEP disabled.\n");
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	ret = pci_module_init(&ipw2100_pci_driver);
+#endif
 
 #ifdef CONFIG_IPW_DEBUG
 	ipw2100_debug_level = debug;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	driver_create_file(&ipw2100_pci_driver.driver,
 			   &driver_attr_debug_level);
 #endif
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	ret = ipw2100_proc_init();
+	if (!ret) {
+		ret = pci_module_init(&ipw2100_pci_driver);
+		if (ret)
+			ipw2100_proc_cleanup();
+	}
+#endif
 	return ret;
 }
 
@@ -6880,10 +7328,15 @@ static void __exit ipw2100_exit(void)
 {
 	/* FIXME: IPG: check that we have no instances of the devices open */
 #ifdef CONFIG_IPW_DEBUG
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	driver_remove_file(&ipw2100_pci_driver.driver,
 			   &driver_attr_debug_level);
 #endif
+#endif
 	pci_unregister_driver(&ipw2100_pci_driver);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	ipw2100_proc_cleanup();
+#endif
 }
 
 module_init(ipw2100_init);
@@ -8290,6 +8743,12 @@ void ipw2100_wx_event_work(struct ipw210
 	union iwreq_data wrqu;
 	int len = ETH_ALEN;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (priv->status & STATUS_ASSOCIATING) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(HZ / 10);
+	}
+#endif
 	if (priv->status & STATUS_STOPPING)
 		return;
 
@@ -8423,7 +8882,11 @@ int ipw2100_get_firmware(struct ipw2100_
 		break;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	rc = request_firmware(&fw->fw_entry, fw_name, pci_name(priv->pci_dev));
+#else
 	rc = request_firmware(&fw->fw_entry, fw_name, &priv->pci_dev->dev);
+#endif
 
 	if (rc < 0) {
 		IPW_DEBUG_ERROR(
@@ -8647,3 +9110,265 @@ int ipw2100_ucode_download(struct ipw210
 
 	return 0;
 }
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+int ipw2100_proc_dev_init(struct ipw2100_priv *priv)
+{
+	struct proc_dir_entry *e;
+
+	IPW_DEBUG_INFO("enter %s\n", priv->net_dev->name);
+
+	priv->dir_dev = create_proc_entry(priv->net_dev->name,
+					  S_IFDIR | S_IRUGO | S_IXUGO,
+					  ipw2100_proc);
+	if (!priv->dir_dev) {
+		printk(KERN_ERR
+		       "Unable to initialize /proc/net/ipw2100/%s\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("hardware", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_hardware, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/hardware\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("registers", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_registers, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/registers\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("ordinals", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_ordinals, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/ordinals\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("pci", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_pci, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/pci\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("stats", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_stats, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/stats\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("internals", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_internals, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/internals\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("bssinfo", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_bssinfo, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/bssinfo\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("memory", S_IFREG | S_IRUGO | S_IWUSR,
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_memory;
+		e->write_proc = proc_set_memory;
+		e->data = priv->net_dev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/memory\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("scan_age", S_IFREG | S_IRUGO | S_IWUSR,
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_scan_age;
+		e->write_proc = proc_set_scan_age;
+		e->data = priv->net_dev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/scan_age\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("fatal_error", S_IFREG | S_IRUGO | S_IWUSR,
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_fatal_error;
+		e->write_proc = proc_set_fatal_error;
+		e->data = priv->net_dev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/fatal_error\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("rf_kill", S_IFREG | S_IRUGO | S_IWUSR,
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_rf_kill;
+		e->write_proc = proc_set_rf_kill;
+		e->data = priv->net_dev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/rf_kill\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("cfg", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_cfg, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/cfg\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("status", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_status, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/status\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("capability", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_capability, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/capability\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	IPW_DEBUG_INFO("exit %s\n", priv->net_dev->name);
+
+	return 0;
+
+ fail:
+	ipw2100_proc_dev_cleanup(priv);
+	IPW_DEBUG_INFO("exit on fail %s\n", priv->net_dev->name);
+
+	return -ENOMEM;
+}
+
+void ipw2100_proc_dev_cleanup(struct ipw2100_priv *priv)
+{
+	IPW_DEBUG_INFO("enter %s\n", priv->net_dev->name);
+
+	if (priv->dir_dev) {
+		remove_proc_entry("hardware", priv->dir_dev);
+		remove_proc_entry("registers", priv->dir_dev);
+		remove_proc_entry("ordinals", priv->dir_dev);
+		remove_proc_entry("pci", priv->dir_dev);
+		remove_proc_entry("stats", priv->dir_dev);
+		remove_proc_entry("internals", priv->dir_dev);
+		remove_proc_entry("bssinfo", priv->dir_dev);
+		remove_proc_entry("memory", priv->dir_dev);
+		remove_proc_entry("scan_age", priv->dir_dev);
+		remove_proc_entry("fatal_error", priv->dir_dev);
+		remove_proc_entry("rf_kill", priv->dir_dev);
+		remove_proc_entry("cfg", priv->dir_dev);
+		remove_proc_entry("status", priv->dir_dev);
+		remove_proc_entry("capability", priv->dir_dev);
+		remove_proc_entry(priv->net_dev->name, ipw2100_proc);
+		priv->dir_dev = NULL;
+	}
+
+	IPW_DEBUG_INFO("exit %s\n", priv->net_dev->name);
+}
+
+static int ipw2100_proc_init(void)
+{
+	struct proc_dir_entry *e;
+
+	IPW_DEBUG_INFO("enter\n");
+
+	ipw2100_proc = create_proc_entry(DRV_NAME, S_IFDIR, proc_net);
+	if (ipw2100_proc == NULL)
+		goto fail_ipw2100;
+
+#ifdef CONFIG_IPW_DEBUG
+	e = create_proc_entry("debug_level", S_IFREG | S_IRUGO | S_IWUSR,
+			      ipw2100_proc);
+	if (e == NULL)
+		goto fail_debug;
+	e->read_proc = proc_get_debug_level;
+	e->write_proc = proc_set_debug_level;
+	e->data = NULL;
+
+	IPW_DEBUG_INFO("exit\n");
+	return 0;
+
+fail_debug:
+	printk(KERN_ERR DRV_NAME ": Unable to initialize "
+	       "/proc/net/" DRV_NAME "/debug_level\n");
+	remove_proc_entry(DRV_NAME, proc_net);
+	ipw2100_proc = NULL;
+	goto fail;
+#endif
+
+fail_ipw2100:
+	printk(KERN_ERR DRV_NAME ": Unable to initialize "
+	      "/proc/net/" DRV_NAME "\n");
+
+fail:
+	IPW_DEBUG_INFO("exit on fail\n");
+	return -ENOMEM;
+}
+
+static void ipw2100_proc_cleanup(void)
+{
+	IPW_DEBUG_INFO("enter\n");
+
+#ifdef CONFIG_IPW_DEBUG
+	if (ipw2100_proc)
+		remove_proc_entry("debug_level", ipw2100_proc);
+#endif
+	remove_proc_entry(DRV_NAME, proc_net);
+	IPW_DEBUG_INFO("exit\n");
+}
+#endif
diff -u -p -r -b ipw2100-1.0.5-0/ipw2100.h ipw2100-1.0.5-1/ipw2100.h
--- ipw2100-1.0.5-0/ipw2100.h	2005-02-08 21:38:23.000000000 +0100
+++ ipw2100-1.0.5-1/ipw2100.h	2005-02-09 11:36:41.000000000 +0100
@@ -42,7 +42,17 @@
 
 #include "ieee80211.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int errno;
+#define get_seconds() CURRENT_TIME
+#include <linux/tqueue.h>
+#define work_struct tq_struct
+#define INIT_WORK INIT_TQUEUE
+#define queue_work(x,y) schedule_task(y)
+#define flush_scheduled_work() flush_scheduled_tasks()
+#else
 #include <linux/workqueue.h>
+#endif
 
 #ifndef IRQ_NONE
 typedef void irqreturn_t;
@@ -635,8 +645,13 @@ struct ipw2100_priv {
 	struct work_struct reset_work;
 	struct work_struct security_work;
 	struct work_struct wx_event_work;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	struct timer_list hang_check_timer;
+	struct timer_list rf_kill_timer;
+#else
 	struct work_struct hang_check;
 	struct work_struct rf_kill;
+#endif
 
 	u32 interrupts;
 	int tx_interrupts;
@@ -1275,4 +1290,12 @@ int ipw2100_ucode_download(struct ipw210
 int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf, size_t max);
 int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf, size_t max);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static struct proc_dir_entry *ipw2100_proc = NULL;
+static int ipw2100_proc_init(void);
+static void ipw2100_proc_cleanup(void);
+static int ipw2100_proc_dev_init(struct ipw2100_priv *priv);
+static void ipw2100_proc_dev_cleanup(struct ipw2100_priv *priv);
+#endif
+
 #endif /* _IPW2100_H */
