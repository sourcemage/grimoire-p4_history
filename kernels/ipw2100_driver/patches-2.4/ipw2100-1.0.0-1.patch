diff -u -p -r -b ipw2100-1.0.0-0/Makefile ipw2100-1.0.0-1/Makefile
--- ipw2100-1.0.0-0/Makefile	2004-11-15 19:24:41.000000000 +0100
+++ ipw2100-1.0.0-1/Makefile	2004-11-15 19:29:59.000000000 +0100
@@ -206,6 +206,8 @@ modules:
 
 endif # End 2.4 / 2.6 specific
 
+ifeq ($(OLDMAKE),)
+
 install: modules
 	install -d $(KMISC)
 	install -m 644 -c $(addsuffix .ko,$(list-m)) $(KMISC)
@@ -222,6 +224,25 @@ uninstall:
 	rm -rf $(addprefix $(KMISC),$(addsuffix .ko,$(list-m)))
 	/sbin/depmod -a
 
+else
+
+install: modules
+	install -d $(KMISC)
+	install -m 644 -c $(addsuffix .o,$(list-m)) $(KMISC)
+	/sbin/depmod -a
+ifdef CONFIG_IPW2100_LEGACY_FW_LOAD
+	@echo "Don't forget to copy firmware to /etc/firmware/."
+else
+	@echo "Don't forget to copy firmware to /usr/lib/hotplug/firmware/ "
+endif
+	@echo "See INSTALL for more information."
+
+uninstall:
+	rm -rf $(addprefix $(KMISC),$(addsuffix .o,$(list-m)))
+	/sbin/depmod -a
+
+endif
+
 endif # End of internal build
 
 
diff -u -p -r -b ipw2100-1.0.0-0/ieee80211_crypt.c ipw2100-1.0.0-1/ieee80211_crypt.c
--- ipw2100-1.0.0-0/ieee80211_crypt.c	2004-11-12 21:45:33.000000000 +0100
+++ ipw2100-1.0.0-1/ieee80211_crypt.c	2004-11-15 19:29:59.000000000 +0100
@@ -55,7 +55,11 @@ void ieee80211_crypt_deinit_entries(stru
 
 		if (entry->ops) {
 			entry->ops->deinit(entry->priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			if (entry->ops->owner) __MOD_DEC_USE_COUNT(entry->ops->owner);
+#else
 			module_put(entry->ops->owner);
+#endif
 		}
 		kfree(entry);
 	}
diff -u -p -r -b ipw2100-1.0.0-0/ieee80211_module.c ipw2100-1.0.0-1/ieee80211_module.c
--- ipw2100-1.0.0-0/ieee80211_module.c	2004-11-12 21:45:33.000000000 +0100
+++ ipw2100-1.0.0-1/ieee80211_module.c	2004-11-15 19:29:59.000000000 +0100
@@ -155,7 +155,11 @@ void ieee80211_free(struct ieee80211_dev
 		if (crypt) {
 			if (crypt->ops) {
 				crypt->ops->deinit(crypt->priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+				if (crypt->ops->owner) __MOD_DEC_USE_COUNT(crypt->ops->owner);
+#else
 				module_put(crypt->ops->owner);
+#endif
 			}
 			kfree(crypt);
 			ieee->crypt[i] = NULL;
@@ -239,8 +243,13 @@ static void __exit ieee80211_exit(void)
 	}
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+MODULE_PARM(debug, "i");
+#else
 #include <linux/moduleparam.h>
 module_param(debug, int, 0444);
+#endif
+
 MODULE_PARM_DESC(debug, "debug output mask");
 
 
diff -u -p -r -b ipw2100-1.0.0-0/ieee80211_wx.c ipw2100-1.0.0-1/ieee80211_wx.c
--- ipw2100-1.0.0-0/ieee80211_wx.c	2004-11-12 21:45:33.000000000 +0100
+++ ipw2100-1.0.0-1/ieee80211_wx.c	2004-11-15 19:29:59.000000000 +0100
@@ -369,7 +369,11 @@ int ieee80211_wx_set_encode(struct ieee8
 			new_crypt->ops = ieee80211_get_crypto_ops("WEP");
 		}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		if (new_crypt->ops && new_crypt->ops->owner && __MOD_INC_USE_COUNT(new_crypt->ops->owner))
+#else
 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner)) 
+#endif
 			new_crypt->priv = new_crypt->ops->init(key);
 
 		if (!new_crypt->ops || !new_crypt->priv) {
diff -u -p -r -b ipw2100-1.0.0-0/ipw2100.c ipw2100-1.0.0-1/ipw2100.c
--- ipw2100-1.0.0-0/ipw2100.c	2004-11-12 21:45:33.000000000 +0100
+++ ipw2100-1.0.0-1/ipw2100.c	2004-11-15 19:29:59.000000000 +0100
@@ -164,7 +164,11 @@ that protects the following:
 
 #include "ipw2100.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+#define IPW2100_VERSION "1.0.0-1"
+#else
 #define IPW2100_VERSION "1.0.0"
+#endif
 
 #define DRV_NAME	"ipw2100"
 #define DRV_VERSION	IPW2100_VERSION
@@ -191,6 +195,14 @@ static int disable = 0;
 static struct ipw2100_fw ipw2100_firmware;
 #endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+MODULE_PARM(debug, "i");
+MODULE_PARM(ifname, "s");
+MODULE_PARM(mode, "i");
+MODULE_PARM(channel, "i");
+MODULE_PARM(associate, "i");
+MODULE_PARM(disable, "i");
+#else
 #include <linux/moduleparam.h>
 module_param(debug, int, 0444);
 module_param(ifname, charp, 0444);
@@ -198,6 +210,7 @@ module_param(mode, int, 0444);
 module_param(channel, int, 0444);
 module_param(associate, int, 0444);
 module_param(disable, int, 0444);
+#endif
 
 MODULE_PARM_DESC(debug, "debug level");
 MODULE_PARM_DESC(ifname, "interface name (default 'eth%d')");
@@ -656,8 +669,12 @@ static inline void schedule_reset(struct
 		netif_stop_queue(priv->net_dev);
 		priv->status |= STATUS_RESET_PENDING;
 		if (priv->reset_backoff) 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			queue_work(priv->workqueue, &priv->reset_work);
+#else
 			queue_delayed_work(priv->workqueue, &priv->reset_work, 
 					   priv->reset_backoff * HZ);
+#endif
 		else 
 			queue_work(priv->workqueue, &priv->reset_work);
 
@@ -746,9 +763,15 @@ static int ipw2100_hw_send_command(struc
 	 * then there is a problem.
 	 */
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	err = interruptible_sleep_on_timeout(
+		&priv->wait_command_queue,
+		HOST_COMPLETE_TIMEOUT);
+#else
 	err = wait_event_interruptible_timeout(
 		priv->wait_command_queue, !(priv->status & STATUS_CMD_ACTIVE),
 		HOST_COMPLETE_TIMEOUT);
+#endif
 
 	if (err == 0) {
 		IPW_DEBUG_INFO("Command completion failed out after %dms.\n",
@@ -1422,7 +1445,12 @@ static int ipw2100_enable_adapter(struct
 
 	if (priv->stop_hang_check) {
 		priv->stop_hang_check = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		priv->hang_check_timer.expires = jiffies + 2 * HZ;
+		add_timer(&priv->hang_check_timer);
+#else
 		queue_delayed_work(priv->workqueue, &priv->hang_check, 2 * HZ);
+#endif
 	}
 
 	return 0;
@@ -1555,7 +1583,11 @@ static int ipw2100_disable_adapter(struc
 
 	if (!priv->stop_hang_check) {
 		priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->hang_check_timer);
+#else
 		cancel_delayed_work(&priv->hang_check);
+#endif
 	}
 
 	err = ipw2100_hw_send_command(priv, &cmd);
@@ -1714,7 +1746,12 @@ static int ipw2100_up(struct ipw2100_pri
 
 		if (priv->stop_rf_kill) {
 			priv->stop_rf_kill = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			priv->rf_kill_timer.expires = jiffies + HZ;
+			add_timer(&priv->rf_kill_timer);
+#else
 			queue_delayed_work(priv->workqueue, &priv->rf_kill, HZ);
+#endif
 		}
 
 		deferred = 1;
@@ -1767,18 +1804,28 @@ static void ipw2100_down(struct ipw2100_
 	/* Kill the RF switch timer */
 	if (!priv->stop_rf_kill) {
 		priv->stop_rf_kill = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->rf_kill_timer);
+#else
 		cancel_delayed_work(&priv->rf_kill);
+#endif
 	}
 	
 	/* Kill the firmare hang check timer */
 	if (!priv->stop_hang_check) {
 		priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->hang_check_timer);
+#else
 		cancel_delayed_work(&priv->hang_check);
+#endif
 	}
 
 	/* Kill any pending resets */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	if (priv->status & STATUS_RESET_PENDING)
 		cancel_delayed_work(&priv->reset_work);
+#endif
 
 	/* Make sure the interrupt is on so that FW commands will be 
 	 * processed correctly */
@@ -1813,6 +1860,12 @@ static void ipw2100_down(struct ipw2100_
 void ipw2100_reset_adapter(struct ipw2100_priv *priv)
 {
 	unsigned long flags;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (priv->reset_backoff) {
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(priv->reset_backoff * HZ);
+	}
+#endif
 	spin_lock_irqsave(&priv->low_lock, flags);
 	IPW_DEBUG_INFO(DRV_NAME ": %s: Restarting adapter.\n", 
 		       priv->net_dev->name);
@@ -1822,13 +1875,19 @@ void ipw2100_reset_adapter(struct ipw210
 	
 	/* Force a power cycle even if interface hasn't been opened
 	 * yet */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	cancel_delayed_work(&priv->reset_work);
+#endif
 	priv->status |= STATUS_RESET_PENDING;
 	spin_unlock_irqrestore(&priv->low_lock, flags);
 
 	/* stop timed checks so that they don't interfere with reset */
 	priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	del_timer_sync(&priv->hang_check_timer);
+#else
 	cancel_delayed_work(&priv->hang_check);
+#endif
 
 	ipw2100_up(priv, 0);
 
@@ -1932,7 +1991,11 @@ static void isr_indicate_associated(stru
 		netif_start_queue(priv->net_dev);
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	queue_work(priv->workqueue, &priv->wx_event_work);
+#else
 	queue_delayed_work(priv->workqueue, &priv->wx_event_work, HZ / 10);
+#endif
 }
 
 		
@@ -2037,7 +2100,12 @@ static void isr_indicate_rf_kill(struct 
 	 * the firmware if the switch is enabled */
 	if (priv->stop_rf_kill) {
 		priv->stop_rf_kill = 0;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		priv->rf_kill_timer.expires = jiffies + HZ;
+		add_timer(&priv->rf_kill_timer);
+#else
 		queue_delayed_work(priv->workqueue, &priv->rf_kill, HZ);
+#endif
 	}
 }
 
@@ -3337,9 +3405,20 @@ static void ipw2100_msg_free(struct ipw2
 	priv->msg_buffers = NULL;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_pci(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	struct pci_dev *pci_dev = priv->pci_dev;
+	*eof = 1;
+#else
 static ssize_t show_pci(struct device *d, char *buf)
 {
 	struct pci_dev *pci_dev = container_of(d, struct pci_dev, dev);
+#endif
 	char *out = buf;
 	int i, j;
 	u32 val;
@@ -3355,28 +3434,66 @@ static ssize_t show_pci(struct device *d
 
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(pci, S_IRUGO, show_pci, NULL);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_cfg(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *p = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_cfg(struct device *d, char *buf)
 {
 	struct ipw2100_priv *p = (struct ipw2100_priv *)d->driver_data;
+#endif
 	return sprintf(buf, "0x%08x\n", (int)p->config);
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(cfg, S_IRUGO, show_cfg, NULL);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_status(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *p = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_status(struct device *d, char *buf)
 {
 	struct ipw2100_priv *p = (struct ipw2100_priv *)d->driver_data;
+#endif
 	return sprintf(buf, "0x%08x\n", (int)p->status);
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(status, S_IRUGO, show_status, NULL);
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_capability(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *p = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_capability(struct device *d, char *buf)
 {
 	struct ipw2100_priv *p = (struct ipw2100_priv *)d->driver_data;
+#endif
 	return sprintf(buf, "0x%08x\n", (int)p->capability);
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(capability, S_IRUGO, show_capability, NULL);
+#endif
 
 
 #define IPW2100_REG(x) { IPW_ ##x, #x }
@@ -3556,10 +3673,21 @@ const struct {
 };
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_registers(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	int i;
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_registers(struct device *d, char *buf)
 {
 	int i;
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	char * out = buf;
 	u32 val = 0;
@@ -3574,12 +3702,24 @@ static ssize_t show_registers(struct dev
 
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(registers, S_IRUGO, show_registers, NULL);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_hardware(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_hardware(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	char * out = buf;
 	int i;
@@ -3614,12 +3754,23 @@ static ssize_t show_hardware(struct devi
 	}
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(hardware, S_IRUGO, show_hardware, NULL);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_memory(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t show_memory(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	static unsigned long loop = 0;
 	int len = 0;
@@ -3627,11 +3778,25 @@ static ssize_t show_memory(struct device
 	int i;
 	char line[81];
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (offset == 0)
+		loop = 0;
+
+	if (loop >= 0x30000) {
+		*start = NULL;
+		*eof = 1;
+		return 0;
+	}
+
+	/* Return around 2k per pass... */
+	while (count - len > 256 && len < 2048 && loop < 0x30000) {
+#else
 	if (loop >= 0x30000)
 		loop = 0;
 
 	/* sysfs provides us PAGE_SIZE buffer */
 	while (len < PAGE_SIZE - 128 && loop < 0x30000) {
+#endif
 
 		if (priv->snapshot[0]) for (i = 0; i < 4; i++) 
 			buffer[i] = *(u32 *)SNAPSHOT_ADDR(loop + i * 4);
@@ -3667,12 +3832,35 @@ static ssize_t show_memory(struct device
 		loop += 16;
 	}
 	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (len) 
+		*start = (char*)len; 
+	else
+		*eof = 1;
+#endif	
 	return len;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_memory(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	char buf[] = "00000";
+	unsigned long len =
+	    (sizeof(buf) - 1) > count ? count : sizeof(buf) - 1;
+
+	if (copy_from_user(buf, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+	buf[len] = 0;
+#else
 static ssize_t store_memory(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	const char *p = buf;
 
@@ -3703,23 +3891,49 @@ static ssize_t store_memory(struct devic
 
 	return count;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(memory, S_IWUSR|S_IRUGO, show_memory, store_memory);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_ordinals(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t show_ordinals(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	u32 val = 0;
 	int len = 0;
 	u32 val_len;
 	static int loop = 0;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (offset == 0)
+		loop = 0;
+
+	if (loop >= (sizeof(ord_data) / sizeof(*ord_data))) {
+		*start = NULL;
+		*eof = 1;
+		return 0;
+	}
+
+	/* Return around 2k per pass... */
+	while (count - len > 256 && len < 2048 &&
+	       loop < (sizeof(ord_data) / sizeof(*ord_data))) {
+#else
 	if (loop >= sizeof(ord_data) / sizeof(*ord_data))
 		loop = 0;
 
 	/* sysfs provides us PAGE_SIZE buffer */
 	while (len < PAGE_SIZE - 128 &&
 	       loop < (sizeof(ord_data) / sizeof(*ord_data))) {
+#endif
 		
 		val_len = sizeof(u32);
 
@@ -3735,14 +3949,32 @@ static ssize_t show_ordinals(struct devi
 		loop++;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (len)
+		*start = (char*)len;
+	else
+		*eof = 1;
+#endif
 	return len;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(ordinals, S_IRUGO, show_ordinals, NULL);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_stats(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_stats(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char * out = buf;
 
 	out += sprintf(out, "interrupts: %d {tx: %d, rx: %d, other: %d}\n",
@@ -3757,7 +3989,9 @@ static ssize_t show_stats(struct device 
 
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(stats, S_IRUGO, show_stats, NULL);
+#endif
 
 
 int ipw2100_switch_mode(struct ipw2100_priv *priv, u32 mode)
@@ -3803,9 +4037,19 @@ int ipw2100_switch_mode(struct ipw2100_p
 	return 0;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_internals(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_internals(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	int len = 0;
 
 #define DUMP_VAR(x,y) len += sprintf(buf + len, # x ": %" # y "\n", priv-> x)
@@ -3849,12 +4093,24 @@ static ssize_t show_internals(struct dev
 
 	return len;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(internals, S_IRUGO, show_internals, NULL);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_bssinfo(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_bssinfo(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char essid[IW_ESSID_MAX_SIZE + 1];
 	u8 bssid[ETH_ALEN];
 	u32 chan = 0;
@@ -3892,20 +4148,43 @@ static ssize_t show_bssinfo(struct devic
 
 	return out - buf;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(bssinfo, S_IRUGO, show_bssinfo, NULL);
+#endif
 
 
 
 
 #ifdef CONFIG_IPW_DEBUG
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_debug_level(char *buf, char **start, off_t offset,
+			int count, int *eof, void *data)
+{
+#else
 static ssize_t show_debug_level(struct device_driver *d, char *buf)
 {
+#endif
 	return sprintf(buf, "0x%08X\n", ipw2100_debug_level);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_debug_level(struct file *file, const char *user_buffer,
+				unsigned long count, void *data)
+{
+	char buf[] = "0x00000000";
+	unsigned long len =
+	    (sizeof(buf) -1) > count ? count : sizeof(buf) - 1;
+
+	if (copy_from_user(buf, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+	buf[len] = 0;
+#else
 static ssize_t store_debug_level(struct device_driver *d, const char *buf,
 				 size_t count)
 {
+#endif
 	char *p = (char *)buf;
 	u32 val;
 
@@ -3922,16 +4201,30 @@ static ssize_t store_debug_level(struct 
 	else
 		ipw2100_debug_level = val;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return count;
+#else
 	return strnlen(buf, count);
+#endif
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DRIVER_ATTR(debug_level, S_IWUSR | S_IRUGO, show_debug_level,
 		   store_debug_level);
+#endif
 #endif /* CONFIG_IPW_DEBUG */
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_fatal_error(char *buf, char **start, off_t offset,
+			int count, int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t show_fatal_error(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	char *out = buf;
 	int i;
 
@@ -3954,25 +4247,53 @@ static ssize_t show_fatal_error(struct d
 	return out - buf;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_fatal_error(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *dev = data;
+	struct ipw2100_priv *priv = netdev_priv(dev);
+#else
 static ssize_t store_fatal_error(struct device *d, const char *buf,
 				 size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	schedule_reset(priv);
 	return count;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(fatal_error, S_IWUSR|S_IRUGO, show_fatal_error, store_fatal_error);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_scan_age(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_scan_age(struct device *d, char *buf)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	return sprintf(buf, "%d\n", priv->ieee->scan_age);
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_scan_age(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+#else
 static ssize_t store_scan_age(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	struct net_device *dev = priv->net_dev;
 	char buffer[] = "00000000";
 	unsigned long len =
@@ -3982,7 +4303,14 @@ static ssize_t store_scan_age(struct dev
 
 	IPW_DEBUG_INFO("enter\n");
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) 
+	if (copy_from_user(buffer, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+#else
 	strncpy(buffer, buf, len);
+#endif
 	buffer[len] = 0;
 
 	if (p[1] == 'x' || p[1] == 'X' || p[0] == 'x' || p[0] == 'X') {
@@ -4001,11 +4329,26 @@ static ssize_t store_scan_age(struct dev
 	}
 	
 	IPW_DEBUG_INFO("exit\n");
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	return count;
+#else
 	return len;
+#endif
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(scan_age, S_IWUSR | S_IRUGO, show_scan_age, store_scan_age);
+#endif
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_get_rf_kill(char *buf, char **start,
+			off_t offset, int count,
+			int *eof, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	*eof = 1;
+#else
 static ssize_t show_rf_kill(struct device *d, char *buf)
 {
 	/* 0 - RF kill not enabled
@@ -4013,6 +4356,7 @@ static ssize_t show_rf_kill(struct devic
 	   2 - HW based RF kill active
 	   3 - Both HW and SW baed RF kill active */
 	struct ipw2100_priv *priv = (struct ipw2100_priv *)d->driver_data;
+#endif
 	int val = ((priv->status & STATUS_RF_KILL_SW) ? 0x1 : 0x0) |
 		(rf_kill_active(priv) ? 0x2 : 0x0);
 	return sprintf(buf, "%i\n", val);
@@ -4036,9 +4380,15 @@ static int ipw_radio_kill_sw(struct ipw2
 			IPW_DEBUG_RF_KILL("Can not turn radio back on - "
 					  "disabled by HW switch\n");
 			/* Make sure the RF_KILL check timer is running */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			del_timer_sync(&priv->rf_kill_timer);
+			priv->rf_kill_timer.expires = jiffies + HZ;
+			add_timer(&priv->rf_kill_timer);
+#else
 			cancel_delayed_work(&priv->rf_kill);
 			queue_delayed_work(priv->workqueue, &priv->rf_kill, 
 					   HZ);
+#endif
 		} else 
 			schedule_reset(priv);		
 	}
@@ -4046,15 +4396,34 @@ static int ipw_radio_kill_sw(struct ipw2
 	return 1;
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int proc_set_rf_kill(struct file *file, const char *user_buffer,
+			unsigned long count, void *data)
+{
+	struct net_device *device = data;
+	struct ipw2100_priv *priv = netdev_priv(device);
+	char buf[] = "0";
+	unsigned long len =
+	    (sizeof(buf) - 1) > count ? count : sizeof(buf) - 1;
+
+	if (copy_from_user(buf, user_buffer, len)) {
+		IPW_DEBUG_INFO("can't copy data from userspace\n");
+		return count;
+	}
+#else
 static ssize_t store_rf_kill(struct device *d, const char *buf, size_t count)
 {
 	struct ipw2100_priv *priv = dev_get_drvdata(d);
+#endif
 	ipw_radio_kill_sw(priv, buf[0] == '1');
 	return count;
 }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 static DEVICE_ATTR(rf_kill, S_IWUSR|S_IRUGO, show_rf_kill, store_rf_kill);
+#endif
 
 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
 static struct attribute *ipw2100_sysfs_entries[] = {
 	&dev_attr_hardware.attr,
 	&dev_attr_registers.attr,
@@ -4076,6 +4445,7 @@ static struct attribute *ipw2100_sysfs_e
 static struct attribute_group ipw2100_attribute_group = {
 	.attrs = ipw2100_sysfs_entries,
 };
+#endif
 
 
 static int status_queue_allocate(struct ipw2100_priv *priv, int entries)
@@ -4173,12 +4543,18 @@ static void ipw2100_kill_workqueue(struc
 	if (priv->workqueue) {
 		priv->stop_rf_kill = 1;
 		priv->stop_hang_check = 1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		del_timer_sync(&priv->hang_check_timer);
+		del_timer_sync(&priv->rf_kill_timer);
+		flush_scheduled_work();
+#else
 		cancel_delayed_work(&priv->reset_work);
 		cancel_delayed_work(&priv->security_work);
 		cancel_delayed_work(&priv->wx_event_work);
 		cancel_delayed_work(&priv->hang_check);
 		cancel_delayed_work(&priv->rf_kill);
 		destroy_workqueue(priv->workqueue);
+#endif
 		priv->workqueue = NULL;
 	}
 }
@@ -5972,7 +6348,11 @@ static int ipw2100_wpa_set_encryption(st
 		}
 		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
 		new_crypt->ops = ops;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		if (new_crypt->ops && new_crypt->ops->owner && __MOD_INC_USE_COUNT(new_crypt->ops->owner))
+#else
 		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
+#endif
 			new_crypt->priv = new_crypt->ops->init(param->u.crypt.idx);
 
 		if (new_crypt->priv == NULL) {
@@ -6145,9 +6525,15 @@ static struct ethtool_ops ipw2100_ethtoo
     .get_drvinfo     = ipw_ethtool_get_drvinfo,
 };
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void ipw2100_hang_check(unsigned long arg)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv *)arg;
+#else
 static void ipw2100_hang_check(void *adapter)
 {
 	struct ipw2100_priv *priv = adapter;
+#endif
 	unsigned long flags;
 	u32 rtc = 0xa5a5a5a5;
 	u32 len = sizeof(rtc);
@@ -6193,15 +6579,25 @@ static void ipw2100_hang_check(void *ada
 
 	/* Check again in two seconds */
 	if (!priv->stop_hang_check)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		mod_timer(&priv->hang_check_timer, jiffies + HZ);
+#else
 		queue_delayed_work(priv->workqueue, &priv->hang_check, HZ);
+#endif
 
 	spin_unlock_irqrestore(&priv->low_lock, flags);
 }
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static void ipw2100_rf_kill(unsigned long arg)
+{
+	struct ipw2100_priv *priv = (struct ipw2100_priv *)arg;
+#else
 static void ipw2100_rf_kill(void *adapter)
 {
 	struct ipw2100_priv *priv = adapter;
+#endif
 	unsigned long flags;
 	
 	spin_lock_irqsave(&priv->low_lock, flags);
@@ -6209,7 +6605,11 @@ static void ipw2100_rf_kill(void *adapte
 	if (rf_kill_active(priv)) {
 		IPW_DEBUG_RF_KILL("RF Kill active, rescheduling GPIO check\n");
 		if (!priv->stop_rf_kill) 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+			mod_timer(&priv->rf_kill_timer, jiffies + HZ);
+#else
 			queue_delayed_work(priv->workqueue, &priv->rf_kill, HZ);
+#endif
 		goto exit_unlock;
 	}
 
@@ -6362,19 +6762,32 @@ static struct net_device *ipw2100_alloc_
 	INIT_STAT(&priv->fw_pend_stat);
 	
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	priv->workqueue = (void *)1;
+#else
 #ifdef CONFIG_SOFTWARE_SUSPEND2
 	priv->workqueue = create_workqueue(DRV_NAME, 0);
 #else
 	priv->workqueue = create_workqueue(DRV_NAME);
 #endif	
+#endif
 	INIT_WORK(&priv->reset_work, 
 		  (void (*)(void *))ipw2100_reset_adapter, priv);
 	INIT_WORK(&priv->security_work, 
 		  (void (*)(void *))ipw2100_security_work, priv);
 	INIT_WORK(&priv->wx_event_work,
 		  (void (*)(void *))ipw2100_wx_event_work, priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	init_timer(&priv->rf_kill_timer);
+	priv->rf_kill_timer.data = (unsigned long)priv;
+	priv->rf_kill_timer.function = ipw2100_rf_kill;
+	init_timer(&priv->hang_check_timer);
+	priv->hang_check_timer.data = (unsigned long)priv;
+	priv->hang_check_timer.function = ipw2100_hang_check;
+#else
 	INIT_WORK(&priv->hang_check, ipw2100_hang_check, priv);
 	INIT_WORK(&priv->rf_kill, ipw2100_rf_kill, priv);
+#endif
 
 	tasklet_init(&priv->irq_tasklet, (void (*)(unsigned long))
 		     ipw2100_irq_tasklet, (unsigned long)priv);
@@ -6474,7 +6887,9 @@ static int ipw2100_pci_init_one(struct p
 		goto fail;
 	}
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	SET_NETDEV_DEV(dev, &pci_dev->dev);
+#endif
 
 	/* Force interrupts to be shut off on the device */
 	priv->status |= STATUS_INT_ENABLED;
@@ -6528,7 +6943,17 @@ static int ipw2100_pci_init_one(struct p
 	IPW_DEBUG_INFO("%s: Bound to %s\n", dev->name, pci_name(pci_dev));
 
 	/* perform this after register_netdev so that dev->name is set */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	err = ipw2100_proc_dev_init(priv);
+	if (err) {
+		printk(KERN_ERR
+		       "%s: Failed to create /proc node\n", dev->name);
+		err = -EIO;
+		goto fail;
+	}
+#else
 	sysfs_create_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);
+#endif
 	netif_carrier_off(dev);
 	
 	/* If the RF Kill switch is disabled, go ahead and complete the
@@ -6578,7 +7003,11 @@ static int ipw2100_pci_init_one(struct p
 
 		/* These are safe to call even if they weren't allocated */
 		ipw2100_queues_free(priv);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		ipw2100_proc_dev_cleanup(priv);
+#else
 		sysfs_remove_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);
+#endif
 
 		free_netdev(dev);
 		pci_set_drvdata(pci_dev, NULL);
@@ -6603,7 +7032,11 @@ static void __devexit ipw2100_pci_remove
 		priv->status &= ~STATUS_INITIALIZED;
 
 		dev = priv->net_dev;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		ipw2100_proc_dev_cleanup(priv);
+#else
 		sysfs_remove_group(&pci_dev->dev.kobj, &ipw2100_attribute_group);
+#endif
 
 #ifdef CONFIG_PM
 		if (ipw2100_firmware.version)
@@ -6802,14 +7235,26 @@ static int __init ipw2100_init(void)
 	IPW_DEBUG_INFO(DRV_NAME ": Compiled with LEGACY FW load.\n");
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	ret = pci_module_init(&ipw2100_pci_driver);
+#endif
 
 #ifdef CONFIG_IPW_DEBUG
 	ipw2100_debug_level = debug;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	driver_create_file(&ipw2100_pci_driver.driver,
 			   &driver_attr_debug_level);
 #endif
+#endif
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	ret = ipw2100_proc_init();
+	if (!ret) {
+		ret = pci_module_init(&ipw2100_pci_driver);
+		if (ret)
+			ipw2100_proc_cleanup();
+	}
+#endif
 	return ret;
 }
 
@@ -6821,10 +7266,15 @@ static void __exit ipw2100_exit(void)
 {
 	/* FIXME: IPG: check that we have no instances of the devices open */
 #ifdef CONFIG_IPW_DEBUG
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
 	driver_remove_file(&ipw2100_pci_driver.driver,
 			   &driver_attr_debug_level);
 #endif
+#endif
 	pci_unregister_driver(&ipw2100_pci_driver);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	ipw2100_proc_cleanup();
+#endif
 }
 
 module_init(ipw2100_init);
@@ -8079,6 +8529,12 @@ struct iw_statistics *ipw2100_wx_wireles
 	u32 rssi, quality, tx_retries, missed_beacons, tx_failures;
 	u32 ord_len = sizeof(u32);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+      if (priv->status & STATUS_ASSOCIATED) {
+	  set_current_state(TASK_UNINTERRUPTIBLE);
+	  schedule_timeout(HZ / 10);
+      }
+#endif
 	if (!priv)
 		return (struct iw_statistics *) NULL;
 
@@ -8252,8 +8708,12 @@ void ipw2100_wx_event_work(struct ipw210
 static char *firmware = NULL;
 
 /* Module paramter for path to the firmware*/
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+MODULE_PARM(firmware,"s");
+#else
 #include <linux/moduleparam.h>
 module_param(firmware, charp, 0);
+#endif
 
 MODULE_PARM_DESC(firmware, "complete path to firmware file");
 
@@ -8315,7 +8775,11 @@ static void ipw2100_fw_free(struct ipw21
 }
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int ipw2100_fw_load(int fd, struct ipw2100_fw_chunk_set *cs, long size)
+#else
 static int ipw2100_fw_load(struct file *filp, struct ipw2100_fw_chunk_set *cs, long size)
+#endif
 {
 	struct ipw2100_fw_chunk *c;
 	int i = 0;
@@ -8355,7 +8819,11 @@ static int ipw2100_fw_load(struct file *
 			goto fail;
 			
 		}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+		if (read(fd, c->buf, c->len) != c->len) {
+#else
 		if (vfs_read(filp, c->buf, c->len, &filp->f_pos) != c->len) {
+#endif
 			IPW_DEBUG_INFO("Failed to read chunk firmware "
 			       "chunk %d.\n", i);
 			goto fail;
@@ -8376,7 +8844,11 @@ static int ipw2100_fw_load(struct file *
 
 static int ipw2100_do_mod_firmware_load(const char *fn, struct ipw2100_fw *fw)
 {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	int fd;
+#else
 	struct file *filp;
+#endif
 	long l;
 	struct ipw2100_fw_header h;
 
@@ -8385,16 +8857,30 @@ static int ipw2100_do_mod_firmware_load(
 	INIT_LIST_HEAD(&fw->fw.chunk_list);
 	INIT_LIST_HEAD(&fw->uc.chunk_list);
 	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	fd = open(fn, 0, 0);
+	if (fd == -1) {
+#else	
 	filp = filp_open(fn, 0, 0);
 	if (IS_ERR(filp)) {
+#endif
 		IPW_DEBUG_INFO("Unable to load '%s'.\n", fn);
 		return 1;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	l = lseek(fd, 0L, 2);
+	lseek(fd, 0L, 0);
+#else
 	l = i_size_read(filp->f_dentry->d_inode);
+#endif
 	IPW_DEBUG_FW("Loading %ld bytes for firmware '%s'\n", l, fn);
 	
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (read(fd, (char *)&h, sizeof(h)) != sizeof(h)) {
+#else	
 	if (vfs_read(filp, (char *)&h, sizeof(h), &filp->f_pos) != sizeof(h)) {
+#endif
 		IPW_DEBUG_INFO("Failed to read '%s'.\n", fn);
 		goto fail;
 	}
@@ -8409,6 +8895,15 @@ static int ipw2100_do_mod_firmware_load(
 
 	fw->version = h.version;
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	if (ipw2100_fw_load(fd, &fw->fw, h.fw_size))
+		goto fail;
+
+	if (ipw2100_fw_load(fd, &fw->uc, h.uc_size))
+		goto fail;
+
+	close(fd);
+#else
 	if (ipw2100_fw_load(filp, &fw->fw, h.fw_size))
 		goto fail;
 
@@ -8416,11 +8911,16 @@ static int ipw2100_do_mod_firmware_load(
 		goto fail;
 
 	filp_close(filp, current->files);
+#endif
 	return 0;
 
  fail:
 	ipw2100_fw_free(fw);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	close(fd);
+#else
 	filp_close(filp, current->files);
+#endif
 	return 1;
 }
 
@@ -8566,7 +9066,11 @@ int ipw2100_get_firmware(struct ipw2100_
 		break;
 	}
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	rc = request_firmware(&fw->fw_entry, fw_name, pci_name(priv->pci_dev));
+#else
 	rc = request_firmware(&fw->fw_entry, fw_name, &priv->pci_dev->dev);
+#endif
 
 	if (rc < 0) {
 		IPW_DEBUG_ERROR(
@@ -8855,3 +9359,265 @@ int ipw2100_ucode_download(struct ipw210
 
 	return 0;
 }
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+int ipw2100_proc_dev_init(struct ipw2100_priv *priv)
+{
+	struct proc_dir_entry *e;
+
+	IPW_DEBUG_INFO("enter %s\n", priv->net_dev->name);
+
+	priv->dir_dev = create_proc_entry(priv->net_dev->name, 
+					  S_IFDIR | S_IRUGO | S_IXUGO, 
+					  ipw2100_proc);
+	if (!priv->dir_dev) {
+		printk(KERN_ERR
+		       "Unable to initialize /proc/net/ipw2100/%s\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("hardware", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_hardware, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/hardware\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("registers", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_registers, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/registers\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("ordinals", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_ordinals, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/ordinals\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("pci", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_pci, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/pci\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("stats", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_stats, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/stats\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("internals", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_internals, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/internals\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("bssinfo", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_bssinfo, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/bssinfo\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("memory", S_IFREG | S_IRUGO | S_IWUSR,
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_memory;
+		e->write_proc = proc_set_memory;
+		e->data = priv->net_dev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/memory\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("scan_age", S_IFREG | S_IRUGO | S_IWUSR, 
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_scan_age;
+		e->write_proc = proc_set_scan_age;
+		e->data = priv->net_dev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/scan_age\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("fatal_error", S_IFREG | S_IRUGO | S_IWUSR, 
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_fatal_error;
+		e->write_proc = proc_set_fatal_error;
+		e->data = priv->net_dev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/fatal_error\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_entry("rf_kill", S_IFREG | S_IRUGO | S_IWUSR,
+			      priv->dir_dev);
+	if (e) {
+		e->read_proc = proc_get_rf_kill;
+		e->write_proc = proc_set_rf_kill;
+		e->data = priv->net_dev;
+	} else {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/rf_kill\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("cfg", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_cfg, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/cfg\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("status", S_IFREG | S_IRUGO,
+				   priv->dir_dev, proc_get_status, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/status\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	e = create_proc_read_entry("capability", S_IFREG | S_IRUGO, 
+				   priv->dir_dev, proc_get_capability, priv->net_dev);
+	if (!e) {
+		printk(KERN_ERR
+		       "Unable to initialize "
+		       "/proc/net/ipw2100/%s/capability\n",
+		       priv->net_dev->name);
+		goto fail;
+	}
+
+	IPW_DEBUG_INFO("exit %s\n", priv->net_dev->name);
+
+	return 0;
+
+ fail:
+	ipw2100_proc_dev_cleanup(priv);
+	IPW_DEBUG_INFO("exit on fail %s\n", priv->net_dev->name);
+	
+	return -ENOMEM;
+}
+
+void ipw2100_proc_dev_cleanup(struct ipw2100_priv *priv)
+{
+	IPW_DEBUG_INFO("enter %s\n", priv->net_dev->name);
+
+	if (priv->dir_dev) {
+		remove_proc_entry("hardware", priv->dir_dev);
+		remove_proc_entry("registers", priv->dir_dev);
+		remove_proc_entry("ordinals", priv->dir_dev);
+		remove_proc_entry("pci", priv->dir_dev);
+		remove_proc_entry("stats", priv->dir_dev);
+		remove_proc_entry("internals", priv->dir_dev);
+		remove_proc_entry("bssinfo", priv->dir_dev);
+		remove_proc_entry("memory", priv->dir_dev);
+		remove_proc_entry("scan_age", priv->dir_dev);
+		remove_proc_entry("fatal_error", priv->dir_dev);
+		remove_proc_entry("rf_kill", priv->dir_dev);
+		remove_proc_entry("cfg", priv->dir_dev);
+		remove_proc_entry("status", priv->dir_dev);
+		remove_proc_entry("capability", priv->dir_dev);
+		remove_proc_entry(priv->net_dev->name, ipw2100_proc);
+		priv->dir_dev = NULL;
+	}
+
+	IPW_DEBUG_INFO("exit %s\n", priv->net_dev->name);
+}
+
+static int ipw2100_proc_init(void)
+{	
+	struct proc_dir_entry *e;
+	
+	IPW_DEBUG_INFO("enter\n");
+
+	ipw2100_proc = create_proc_entry(DRV_NAME, S_IFDIR, proc_net);
+	if (ipw2100_proc == NULL)
+		goto fail_ipw2100;
+
+#ifdef CONFIG_IPW_DEBUG
+	e = create_proc_entry("debug_level", S_IFREG | S_IRUGO | S_IWUSR, 
+			      ipw2100_proc);
+	if (e == NULL)
+		goto fail_debug;
+	e->read_proc = proc_get_debug_level;
+	e->write_proc = proc_set_debug_level;
+	e->data = NULL;
+
+	IPW_DEBUG_INFO("exit\n");
+	return 0;
+
+fail_debug:
+	printk(KERN_ERR DRV_NAME ": Unable to initialize "
+	       "/proc/net/" DRV_NAME "/debug_level\n");
+	remove_proc_entry(DRV_NAME, proc_net);
+	ipw2100_proc = NULL;
+	goto fail;
+#endif
+
+fail_ipw2100:
+	printk(KERN_ERR DRV_NAME ": Unable to initialize " 
+	      "/proc/net/" DRV_NAME "\n");
+
+fail:
+	IPW_DEBUG_INFO("exit on fail\n");	
+	return -ENOMEM;
+}
+
+static void ipw2100_proc_cleanup(void)
+{
+	IPW_DEBUG_INFO("enter\n");
+
+#ifdef CONFIG_IPW_DEBUG
+	if (ipw2100_proc)
+		remove_proc_entry("debug_level", ipw2100_proc);
+#endif
+	remove_proc_entry(DRV_NAME, proc_net);
+	IPW_DEBUG_INFO("exit\n");
+}
+#endif
diff -u -p -r -b ipw2100-1.0.0-0/ipw2100.h ipw2100-1.0.0-1/ipw2100.h
--- ipw2100-1.0.0-0/ipw2100.h	2004-11-12 21:45:33.000000000 +0100
+++ ipw2100-1.0.0-1/ipw2100.h	2004-11-15 19:29:59.000000000 +0100
@@ -42,7 +42,21 @@
 
 #include "ieee80211.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static int errno;
+#define get_seconds() CURRENT_TIME
+#include <linux/tqueue.h>
+#define work_struct tq_struct
+#define INIT_WORK INIT_TQUEUE
+#define queue_work(x,y) schedule_task(y)
+#define flush_scheduled_work() flush_scheduled_tasks()
+#else
 #include <linux/workqueue.h>
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,27)
+static inline void *netdev_priv(struct net_device *dev) { return dev->priv; }
+#endif
 
 #ifndef IRQ_NONE
 typedef void irqreturn_t;
@@ -634,8 +648,13 @@ struct ipw2100_priv {
 	struct work_struct reset_work;
 	struct work_struct security_work;
 	struct work_struct wx_event_work;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+	struct timer_list hang_check_timer;
+	struct timer_list rf_kill_timer;
+#else
 	struct work_struct hang_check;
 	struct work_struct rf_kill;
+#endif
 	
 	u32 interrupts;
 	int tx_interrupts;
@@ -1279,4 +1298,12 @@ int ipw2100_ucode_download(struct ipw210
 int ipw2100_get_fwversion(struct ipw2100_priv *priv, char *buf, size_t max);
 int ipw2100_get_ucodeversion(struct ipw2100_priv *priv, char *buf, size_t max);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0)
+static struct proc_dir_entry *ipw2100_proc = NULL;
+static int ipw2100_proc_init(void);
+static void ipw2100_proc_cleanup(void);
+static int ipw2100_proc_dev_init(struct ipw2100_priv *priv);
+static void ipw2100_proc_dev_cleanup(struct ipw2100_priv *priv);
+#endif
+
 #endif /* _IPW2100_H */
