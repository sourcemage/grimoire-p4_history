# how do I make those .gpg files that have the public keys?
# like this:
# gpg --no-default-keyring --keyring ./grsecurity.gpg --import
# (paste in public key) (hit ctrl-d to finish importing keys)

##### subs

unpack_override() {  

  FILENAME=`guess_filename $SOURCE_CACHE/$1` &&
  COMPRESSOR=`guess_compressor $FILENAME`
  uncompress $FILENAME $COMPRESSOR '' | \
  {

    # This section takes the uncompressed stream and turns it into the
    # fully unarchived form.
    case  $COMPRESSOR  in
            bzip2|gzip|compress*|tar)
                    tar   --owner=root  --group=root  -xf  /dev/stdin  ;;
              Zip)  cat /dev/stdin >/dev/null   #get rid of unused output
                    unzip  -q  $FILENAME                               ;;
              RPM)  cpio  -idm < /dev/stdin                            ;;
                *)  false                                              ;;
    esac  

  }
  rm /tmp/libgrimoire.uncompress.$$

}
gpgcheck() { # $1 sig $2 file $3 pubring

  # always trust and supply our own keyring.
  # We provide our own trust for the pubkey validity.

  GPGPROG="`which gpg 2> /dev/null`"
  if test -z "$GPGPROG" ; then

    message "It appears you do not have gpg (gnupg) in your PATH."
    message "${SPELL_COLOR}${SPELL}: ${QUERY_COLOR}For full kernel.org source verification, it is highly suggested that you abort and cast gnupg as soon as possible."
    if [ $MD5SUM_DL != "off" ] ; then
      message "Note: If you do not have any kernel headers installed, cast gnupg will fail, in which case you shouldn't abort now since the sources and headers have been wiped clean already."
    fi

    case $MD5SUM_DL in
                off)  message "${RED}Continuing!${DEFAULT_COLOR}"         ;;
ask_risky|ask_abort)  query "Abort?" "y"           && exit 1   || echo -n ;;
    ask_ignore|on|*)  query "Abort?" "n"           && exit 1   || echo -n ;;
          abort_all)  message "${RED}Aborting.  gnupg isn't installed and you've just wiped your kernel sources so gnupg won't build.  Try reducing your MD5SUM_DL (Download Integrity) in sorcery to skip the gnupg step and confirm the validity of the sources yourself.${DEFAULT_COLOR}" ; exit 1  ;;
    esac

  else
    gpg --no-default-keyring                    \
        --always-trust                          \
        --keyring $SCRIPT_DIRECTORY/$3           \
        --batch           \
        --verify          \
        $SOURCE_CACHE/$1  \
        $SOURCE_CACHE/$2 2> /dev/null ||
        return 1        # error out if verification fails.
  fi
  message "check passed.";  
  return 0
}

md5check() { # $1 md5 $2 file
  mMD5=$1
  mFILE=$SOURCE_CACHE/$2
  #message " testing $mMD5 == md5sum of uncompressed $mFILE"
  if [[ ${mFILE} == *.bz2 ]] ; then
    test "$mMD5" == "`bzcat $mFILE | md5sum | cut -d ' ' -f 1`" || return 1
  elif [[ ${mFILE} == *.gz ]] ; then
    test "$mMD5" == "`zcat $mFILE | md5sum | cut -d ' ' -f 1`" || return 1
  else
    test "$mMD5" == "`cat $mFILE | md5sum | cut -d ' ' -f 1`" || return 1
  fi
  message "check passed.";  
  return 0
}

check() {
  local  MTYPE=$1
  local TOCHCK=$2
  local WTHCHCK=$3
  local PUBKEYCHCK=$4  # for MTYPE=gpg
  message "$MTYPE checking $TOCHCK with $WTHCHCK."
  case $MTYPE in
    md5)  md5check $WTHCHCK $TOCHCK             && return 0 ;;
    gpg)  message "using public key ring file $PUBKEYCHCK."
          gpgcheck $WTHCHCK $TOCHCK $PUBKEYCHCK && return 0 ;;
  esac
  if [ -z "$PASSCH" ] ; then
    case $MTYPE in
      md5)  CTYPE="MD5 sum is different for uncompressed" ;;
      gpg)  CTYPE="GPG signature validation failed for" ;;
    esac
    message "${SPELL_COLOR}${SPELL}: ${QUERY_COLOR}${CTYPE} ${TOCHCK}."
    case $MD5SUM_DL in
                off)  message "${RED}Continuing!${DEFAULT_COLOR}"         ;;
         ask_ignore)  query "Abort?" "n"           && exit 1   || echo -n ;;
ask_risky|ask_abort)  query "Abort?" "y"           && exit 1   || echo -n ;;
     on|abort_all|*)  message "${RED}Aborting.${DEFAULT_COLOR}" ; exit 1  ;;
    esac
  fi
  message "check passed.";  
  return 0
}

#####


cd       ${INSTALL_ROOT}/usr/src

echo "check for existing tree"
if  [  -d linux-${VERSION}  ];  then
  echo "tree found"
  echo "if you don't want to do a whole rebuild from fresh sources you can reuse the existing ones. (no checks, no new patches)"
  if  query "reuse existing source tree?" "y"  == "yes"  ;then
    echo reuse
    ln -sf ${INSTALL_ROOT}/usr/src/linux-${VERSION} linux
    cd linux-${VERSION}
    return 0
  else
    echo "delete it"
    rm   -r  linux-${VERSION}
  fi
fi
message "building a new tree";


check  gpg  $SOURCE  $SOURCE2  kernel.gpg ||  exit 1

mkdir linux-${VERSION}
cd ${INSTALL_ROOT}/usr/src/linux-${VERSION}

message "extracting ${SOURCE}"
unpack_override  $SOURCE '' #we will ignore MD5 because of above check
EXTRACT_PATH=$(ls)
mv ${INSTALL_ROOT}/usr/src/linux-${VERSION}/${EXTRACT_PATH}/* ${INSTALL_ROOT}/usr/src/linux-${VERSION}/
rmdir ${INSTALL_ROOT}/usr/src/linux-${VERSION}/${EXTRACT_PATH}/
cd ${INSTALL_ROOT}/usr/src

chown  -R  root:root  ${INSTALL_ROOT}/usr/src/linux-${VERSION}


mkdir  -p  ../include

if [[ ! -d ../include/asm-generic ]]; then
  ln ../src/linux-${VERSION}/include/asm-generic ..//include/ -sf
fi

if [[ ! -d ../include/asm ]]; then
  ln ../src/linux-${VERSION}/include/asm        ..//include/ -sf
fi

if [[ ! -d ../include/linux ]]; then
  ln ../src/linux-${VERSION}/include/linux      ..//include/ -sf
fi

#reinstated so module-less kernels have an identifiable header tree
ln -sfn linux-${VERSION} ${INSTALL_ROOT}/usr/src/linux
cd  ${INSTALL_ROOT}/usr/src/linux-${VERSION}

# patch 2.6 make file, to allow use of xconfig
if [ -d scripts/kconfig ];then
  patch -p0 < ${SPELL_DIRECTORY}/mk.2.6.diff scripts/kconfig/Makefile
fi


if  [  -f  $CONFIG_CACHE/kernel.config  ]; then
  cp $CONFIG_CACHE/kernel.config .config
fi


local COUNTER
local VARS
local VARSS
for ((COUNTER=4; COUNTER <= 7 ; COUNTER++))
do
  VARS=SOURCE${COUNTER}
  COUNTER="$((( $COUNTER + 1)))"
  VARG=SOURCE${COUNTER}
  VARSS=${!VARS}
  VARGS=${!VARG}
  if [[ "${VARSS}" != " " ]]; then

    check gpg $VARSS $VARGS kernel.gpg || exit 1
    echo "applying ${VARSS}"

    if [[ ${VARSS} == *.bz2 ]] ; then
      bzcat $SOURCE_CACHE/${VARSS} | patch -s -N -p1
    elif [[ ${!VAR} == *.gz ]] ; then
      zcat $SOURCE_CACHE/${VARSS} | patch -s -N -p1
    else
      cat $SOURCE_CACHE/${VARSS} | patch -s -N -p1
    fi
  fi
done

local COUNTER
local VARS
local VARSS
local MD5V
for ((COUNTER=8; COUNTER <= 40 ; COUNTER++))
do
  VARS=SOURCE${COUNTER}
  VARSS="${!VARS}"
  if [[ "${VARSS}" != "" ]]; then

    MD5V=${MD5[$((( ${COUNTER} - 1)))]}
    if test ${MD5V} = "gpg" ; then
      COUNTER="$((( $COUNTER + 1)))"
      VARS2=SOURCE${COUNTER}
      VARSS2="${!VARS2}"
      check gpg ${VARSS} ${VARSS2} ${MD5[$(((${COUNTER} - 1)))]} || exit 1
    else
      check md5 ${VARSS} ${MD5V} || exit 1
    fi
    echo "applying ${VARSS}"

    if  echo  ${VARSS}  |  grep  -q  "kgdb";  then
      tar xjf  ${SOURCE_CACHE}/${VARSS}       &&
      for i in `ls ${VARSS/\.tar*/}/*.patch`;  do
        echo "applying $i from ${VARSS/\.tar*/}"   &&
        patch -s -N -p1  <  $i
      done
    elif [[ ${VARSS} == *.bz2 ]] ; then
      bzcat $SOURCE_CACHE/${VARSS} | patch -s -N -p1
    elif [[ ${VARSS} == *.gz ]] ; then
      zcat $SOURCE_CACHE/${VARSS} | patch -s -N -p1
    else
      cat $SOURCE_CACHE/${VARSS} | patch -s -N -p1
    fi
  fi
done


