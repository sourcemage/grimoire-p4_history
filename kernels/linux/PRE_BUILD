linux_new_uncompress()
{
	if [ "`file $1 | grep gzip`" != "" ]
	then
		gunzip $1
	elif [ "`file $1 | grep bzip`" != "" ]
	then
		bunzip2 $1
	elif [ "`file $1 | grep diff`" != "" ] || 
	     [ "`file $1 | grep ASCII`" != "" ]
	then
		message "${MESSAGE_COLOR}$1 doesn't need uncompressing${DEFAULT_COLOR}"
	else
		message "${PROBLEM_COLOR}$1 has some unknown/unimplemented compression type${DEFAULT_COLOR}"
		return 1
	fi
}


if [[ "$mode" == "oldktree" && -d ${LINUX_SOURCE_DIRECTORY} ]]
then
	message "${MESSAGE_COLOR}Okay ${LINUX_SOURCE_DIRECTORY} does exist${DEFAULT_COLOR}" 
elif [[ "$mode" == "oldktree" ]]
then
	message "${PROBLEM_COLOR}Ah, ${LINUX_SOURCE_DIRECTORY} doesn't exist\nGoing to newktree mode${DEFAULT_COLOR}" &&
	mode="newktree"
else
	message "${MESSAGE_COLOR}Using ${LINUX_SOURCE_DIRECTORY} for new build${DEFAULT_COLOR}"
fi &&

if [[ "$mode" == "newktree" ]]
then
	mk_source_dir $LINUX_SOURCE_DIRECTORY &&
	cd $LINUX_SOURCE_DIRECTORY &&
	unpack ${SOURCE} ${MD5[0]} &&
	mv ./*/* ./ &&
	
	. ${SCRIPT_DIRECTORY}/latest.defaults &&
	for patch in $patches
	do
		case "$patch" in
			LATEST*)
				patch=${!patch}
				;;
			*)
				;;
		esac &&
		pval=1 &&
		md5sum=""
		tmp=$(find ${SCRIPT_DIRECTORY}/info/patches/*/${patch})
		. $tmp
		. `dirname $tmp`/.info
		if [ "$md5sum" != "" ]
		then
			unpack ${source} ${md5sum}
		fi &&
		if [ "${source}" != "" ]
		then
			cp -v ${SOURCE_CACHE}/${source} ./ &&
			linux_new_uncompress ./${source} &&
			message "${MESSAGE_COLOR}Patching ${patch}${DEFAULT_COLOR}" &&
			patch -p${pval} <${patch} || return 1
			if [ "`echo $patch | grep 'kernel-source'`" != "" ]
			then
				override_version="$VERSION"
				home="$LINUX_SOURCE_DIRECTORY/debian/patches"
				export override_version &&
				export home &&
				sh debian/apply &&
				unset home &&
				unset override_version
			fi
		fi
	done &&
	make mrproper 
elif [[ "$mode" == "oldktree" ]]
then
	message "${MESSAGE_COLOR}mode is oldktree${DEFAULT_COLOR}" &&
	cd $LINUX_SOURCE_DIRECTORY
else
	message "${PROBLEM_COLOR}I don't know what $mode is${DEFAULT_COLOR}" &&
	return 1
fi &&

if [[ "$TXTMESSAGE" != "" ]]
then
        message $TXTMESSAGE &&
        sleep 5
fi &&
if [[ "$CONFIG_RESTORE" != "" ]]
then

	case "${CONFIG_RESTORE}" in
		"/proc/config.gz")
			if [ -f ${CONFIG_RESTORE} ]
			then
				zcat /proc/config.gz > .config
			fi
			;;
		"/boot/config-$VERSION")
			if [ -f ${CONFIG_RESTORE} ]
			then
				cp /boot/config-$VERSION .config
			fi
			;;
		"Custom")
			if [ -f ${CONFIG_RESTORE} ]
			then
				cp ${CONFIG_RESTORE} .config
			fi
			;;
	esac
fi
if [[ "$reconf" == "true" ]]
then
	if [[ "$MAKEMODE" == "menuconfig" ]]
	then
		MENUCONFIG_EXIT="n" &&
		while [[ "$MENUCONFIG_EXIT" == "n" ]]
		do
			ARCH=${kernel_arch} make $MAKEMODE &&
			if query "Do you really want to exit menuconfig?" y 
			then
				MENUCONFIG_EXIT="y" 
			else
				MENUCONFIG_EXIT="n"
			fi 
		done
	else
		ARCH=${kernel_arch} make $MAKEMODE
	fi
else
	# run oldconfig just to make sure it's got a correct config
	yes '' | make oldconfig
fi
