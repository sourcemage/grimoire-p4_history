linux_new_uncompress()
{
	if [ "`file $1 | grep gzip`" != "" ]
	then
		gunzip $1
	elif [ "`file $1 | grep bzip`" != "" ]
	then
		bunzip2 $1
	elif [ "`file $1 | grep diff`" != "" ] || 
	     [ "`file $1 | grep ASCII`" != "" ] ||
	     [ "`file $1 | grep text`" != "" ]
	then
		message "${MESSAGE_COLOR}$1 doesn't need uncompressing${DEFAULT_COLOR}"
	else
		message "${PROBLEM_COLOR}$1 has some unknown/unimplemented compression type${DEFAULT_COLOR}"
		return 1
	fi
}


if [[ "$mode" == "oldktree" && -d ${LINUX_SOURCE_DIRECTORY} ]]
then
	message "${MESSAGE_COLOR}Okay ${LINUX_SOURCE_DIRECTORY} does exist${DEFAULT_COLOR}" 
elif [[ "$mode" == "oldktree" ]]
then
	message "${PROBLEM_COLOR}Ah, ${LINUX_SOURCE_DIRECTORY} doesn't exist\nGoing to newktree mode${DEFAULT_COLOR}" &&
	mode="newktree"
else
	message "${MESSAGE_COLOR}Using ${LINUX_SOURCE_DIRECTORY} for new build${DEFAULT_COLOR}"
fi &&

if [[ "$mode" == "newktree" ]]
then
	mk_source_dir $LINUX_SOURCE_DIRECTORY &&
	cd $LINUX_SOURCE_DIRECTORY &&
	unpack_file '' &&
	mv ./*/* ./ &&
	. ${SPELL_DIRECTORY}/latest.defaults &&
	local count=3
	local source="SOURCE${count}"
	local source_check="SOURCE${count}_IGNORE"
	while [[ "${!source_check}" != "signature" && ! -z "${!source}" ]]
	do
		pval=1 &&
		patch="PATCH[${count}]"
		tmp=$(find ${SPELL_DIRECTORY} -name ${!patch} | head -n 1) &&
		. ${tmp} &&
		cd ${LINUX_SOURCE_DIRECTORY} &&
		unpack_file "$count" &&
		cp -v ${SOURCE_CACHE}/${source} ./ &&
		linux_new_uncompress ./${source} &&
		message "${MESSAGE_COLOR}Patching ${!patch}${DEFAULT_COLOR}" &&
		patch -p${pval} <${!patch} || return 1
		(( count++ ))
		source="SOURCE${count}"
		source_check="SOURCE${count}_IGNORE"
	done &&	
	make mrproper 
elif [[ "$mode" == "oldktree" ]]
then
	message "${MESSAGE_COLOR}mode is oldktree${DEFAULT_COLOR}" &&
	cd $LINUX_SOURCE_DIRECTORY
else
	message "${PROBLEM_COLOR}I don't know what $mode is${DEFAULT_COLOR}" &&
	return 1
fi &&

if [[ "$TXTMESSAGE" != "" ]]
then
        message $TXTMESSAGE &&
        sleep 5
fi &&
if [[ "$CONFIG_RESTORE" != "" ]]
then

	case "${CONFIG_RESTORE}" in
		"/proc/config.gz")
			if [ -f ${CONFIG_RESTORE} ]
			then
				zcat /proc/config.gz > .config
			fi
			;;
		*)
			if [ -f ${CONFIG_RESTORE} ]
			then
				cp -v ${CONFIG_RESTORE} .config
			fi
			;;
	esac
fi &&
if [[ "$reconf" == "true" ]] || [[ "$CONFIG_KERNEL" == "y" ]]
then
	case "$MAKEMODE" in
		menuconfig)
			MENUCONFIG_EXIT="n" &&
			while [[ "$MENUCONFIG_EXIT" == "n" ]]
			do
				ARCH=${kernel_arch} make $MAKEMODE &&
				if query "Do you really want to exit menuconfig?" y 
				then
					MENUCONFIG_EXIT="y" 
				else
					MENUCONFIG_EXIT="n"
				fi 
			done
		;;
		smgl-update-defaults)
			yes '' | make oldconfig
		;;
		*)
		ARCH=${kernel_arch} make $MAKEMODE
	esac
else
	case "$MAKEMODE" in
		defconfig|allyesconfig|allnoconfig|allmodconfig|randconfig)
			make $MAKEMODE
		;;
		*)
			# run oldconfig just to make sure it's got a correct config
			yes '' | make oldconfig
		;;
	esac
fi
