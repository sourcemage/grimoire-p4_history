diff -urp mutt.orig/Makefile.am mutt/Makefile.am
--- mutt.orig/Makefile.am	2004-09-04 13:31:21.000000000 +0200
+++ mutt/Makefile.am	2004-10-02 19:28:52.000000000 +0200
@@ -28,7 +28,8 @@ mutt_SOURCES = $(BUILT_SOURCES) \
 	score.c send.c sendlib.c signal.c sort.c \
 	status.c system.c thread.c charset.c history.c lib.c \
 	muttlib.c editmsg.c utf8.c mbyte.c wcwidth.c \
-	url.c ascii.c mutt_idna.c crypt-mod.c crypt-mod.h
+	url.c ascii.c mutt_idna.c crypt-mod.c crypt-mod.h \
+	sidebar.c
 
 mutt_LDADD = @MUTT_LIB_OBJECTS@ @LIBOBJS@ $(LIBIMAP) $(MUTTLIBS) \
 	$(INTLLIBS) $(LIBICONV) 
@@ -63,7 +64,7 @@ EXTRA_mutt_SOURCES = account.c md5c.c mu
 	pgplib.c sha1.c pgpmicalg.c gnupgparse.c resize.c dotlock.c remailer.c \
 	browser.h mbyte.h remailer.h url.h mutt_ssl_nss.c \
 	crypt-mod-pgp-classic.c crypt-mod-smime-classic.c \
-	pgppacket.c mutt_idna.h
+	pgppacket.c mutt_idna.h sidebar.h
 
 EXTRA_DIST = COPYRIGHT GPL OPS OPS.PGP OPS.CRYPT OPS.SMIME TODO \
 	configure acconfig.h account.h \
diff -urp mutt.orig/OPS mutt/OPS
--- mutt.orig/OPS	2003-07-04 19:07:22.000000000 +0200
+++ mutt/OPS	2004-10-02 19:26:39.000000000 +0200
@@ -174,3 +174,8 @@ OP_WHAT_KEY "display the keycode for a k
 OP_MAIN_SHOW_LIMIT "show currently active limit pattern"
 OP_MAIN_COLLAPSE_THREAD "collapse/uncollapse current thread"
 OP_MAIN_COLLAPSE_ALL "collapse/uncollapse all threads"
+OP_SCROLL_MBOX_UP "scroll the mailbox pane up 1 page"
+OP_SCROLL_MBOX_DOWN "scroll the mailbox pane down 1 page"
+OP_NEXT_MBOX "go down to next mailbox"
+OP_PREV_MBOX "go to previous mailbox"
+OP_OPEN_MBOX "open hilighted mailbox"
diff -urp mutt.orig/PATCHES mutt/PATCHES
--- mutt.orig/PATCHES	2002-12-09 18:44:54.000000000 +0100
+++ mutt/PATCHES	2004-10-02 19:26:39.000000000 +0200
@@ -0,0 +1 @@
+patch-1.5.6.jrh.sidebar.12
diff -urp mutt.orig/buffy.c mutt/buffy.c
--- mutt.orig/buffy.c	2004-02-13 16:08:31.000000000 +0100
+++ mutt/buffy.c	2004-10-02 19:26:39.000000000 +0200
@@ -263,7 +263,7 @@ int mutt_buffy_check (int force)
   char path[_POSIX_PATH_MAX];
   struct stat contex_sb;
   time_t t;
-
+  CONTEXT *ctx;
 #ifdef USE_IMAP
   /* update postponed count as well, on force */
   if (force)
@@ -296,6 +296,8 @@ int mutt_buffy_check (int force)
   
   for (tmp = Incoming; tmp; tmp = tmp->next)
   {
+	if ( tmp->new == 1 )
+		tmp->has_new = 1;
     tmp->new = 0;
 
 #ifdef USE_IMAP
@@ -349,10 +351,27 @@ int mutt_buffy_check (int force)
       case M_MBOX:
       case M_MMDF:
 
-	if (STAT_CHECK)
+    {
+	if (STAT_CHECK || tmp->msgcount == 0)
 	{
+	  BUFFY b = *tmp;
+	  int msgcount = 0;
+	  int msg_unread = 0;
 	  BuffyCount++;
-	  tmp->new = 1;
+	  /* parse the mailbox, to see how much mail there is */
+	  ctx = mx_open_mailbox( tmp->path, M_READONLY | M_QUIET | M_NOSORT,
+	    NULL);
+	  if(ctx)
+	  {
+	      msgcount = ctx->msgcount;
+	      msg_unread = ctx->unread;
+	      mx_close_mailbox(ctx, 0);
+	  }
+	  *tmp = b;
+	  tmp->msgcount = msgcount;
+	  tmp->msg_unread = msg_unread;
+	  if(STAT_CHECK)
+	      tmp->has_new = tmp->new = 1;
 	}
 #ifdef BUFFY_SIZE
 	else
@@ -364,7 +383,7 @@ int mutt_buffy_check (int force)
 	if (tmp->newly_created &&
 	    (sb.st_ctime != sb.st_mtime || sb.st_ctime != sb.st_atime))
 	  tmp->newly_created = 0;
-
+	}
 	break;
 
       case M_MAILDIR:
@@ -375,6 +394,28 @@ int mutt_buffy_check (int force)
 	  tmp->magic = 0;
 	  break;
 	}
+	tmp->msgcount = 0;
+	tmp->msg_unread = 0;
+	while ((de = readdir (dirp)) != NULL)
+	{
+	  char *p;
+	  if (*de->d_name != '.' && 
+	      (!(p = strstr (de->d_name, ":2,")) || !strchr (p + 3, 'T')))
+	  {
+	    /* one new and undeleted message is enough */
+	    BuffyCount++;
+	    tmp->has_new = tmp->new = 1;
+        tmp->msgcount++;
+		tmp->msg_unread++;
+	  }
+	}
+	closedir (dirp);
+	snprintf (path, sizeof (path), "%s/cur", tmp->path);
+	if ((dirp = opendir (path)) == NULL)
+	{
+	  tmp->magic = 0;
+	  break;
+	}
 	while ((de = readdir (dirp)) != NULL)
 	{
 	  char *p;
@@ -383,22 +424,41 @@ int mutt_buffy_check (int force)
 	  {
 	    /* one new and undeleted message is enough */
 	    BuffyCount++;
-	    tmp->new = 1;
-	    break;
+	    tmp->has_new = tmp->new = 1;
+        tmp->msgcount++;
 	  }
 	}
 	closedir (dirp);
 	break;
 
       case M_MH:
-	if ((tmp->new = mh_buffy (tmp->path)) > 0)
-	  BuffyCount++;
+	{
+      DIR *dp;
+      struct dirent *de;
+	  if ((tmp->new = mh_buffy (tmp->path)) > 0)
+	    BuffyCount++;
+  
+      if ((dp = opendir (path)) == NULL)
+        break;
+	  tmp->msgcount = 0;
+      while ((de = readdir (dp)))
+      {
+        if (mh_valid_message (de->d_name))
+        {
+		  tmp->msgcount++;
+		  tmp->has_new = tmp->new = 1;
+        }
+      }
+      closedir (dp);
+    }
 	break;
 	
 #ifdef USE_IMAP
       case M_IMAP:
-	if ((tmp->new = imap_mailbox_check (tmp->path, 1)) > 0)
+	  tmp->msgcount = imap_mailbox_check(tmp->path, 0);
+	if ((tmp->new = imap_mailbox_check (tmp->path, 1)) > 0) {
 	  BuffyCount++;
+	}
 	else
 	  tmp->new = 0;
 
diff -urp mutt.orig/buffy.h mutt/buffy.h
--- mutt.orig/buffy.h	2002-12-11 12:19:39.000000000 +0100
+++ mutt/buffy.h	2004-10-02 19:26:39.000000000 +0200
@@ -27,7 +27,11 @@ typedef struct buffy_t
   long size;
 #endif				/* BUFFY_SIZE */
   struct buffy_t *next;
+  struct buffy_t *prev;
   short new;			/* mailbox has new mail */
+  short has_new;		/* set it new if new and not read */
+  int msgcount;			/* total number of messages */
+  int msg_unread;		/* number of unread messages */
   short notified;		/* user has been notified */
   short magic;			/* mailbox type */
   short newly_created;		/* mbox or mmdf just popped into existence */
diff -urp mutt.orig/color.c mutt/color.c
--- mutt.orig/color.c	2003-09-19 15:03:25.000000000 +0200
+++ mutt/color.c	2004-10-02 19:26:39.000000000 +0200
@@ -89,6 +89,7 @@ static struct mapping_t Fields[] =
   { "bold",		MT_COLOR_BOLD },
   { "underline",	MT_COLOR_UNDERLINE },
   { "index",		MT_COLOR_INDEX },
+  { "sidebarnew",	MT_COLOR_NEW },
   { NULL,		0 }
 };
 
diff -urp mutt.orig/compose.c mutt/compose.c
--- mutt.orig/compose.c	2004-09-04 13:31:21.000000000 +0200
+++ mutt/compose.c	2004-10-02 19:29:30.000000000 +0200
@@ -68,7 +68,7 @@ enum
 
 #define HDR_XOFFSET 10
 #define TITLE_FMT "%10s" /* Used for Prompts, which are ASCII */
-#define W (COLS - HDR_XOFFSET)
+#define W (COLS - HDR_XOFFSET - SidebarWidth)
 
 static char *Prompts[] =
 {
@@ -111,16 +111,16 @@ static void redraw_crypt_lines (HEADER *
   if ((WithCrypto & APPLICATION_PGP) && (WithCrypto & APPLICATION_SMIME))
   {     
     if (!msg->security)
-      mvaddstr (HDR_CRYPT, 0,     "Security: ");
+      mvaddstr (HDR_CRYPT, SidebarWidth,     "Security: ");
     else if (msg->security & APPLICATION_SMIME)
-      mvaddstr (HDR_CRYPT, 0,     "  S/MIME: ");
+      mvaddstr (HDR_CRYPT, SidebarWidth,     "  S/MIME: ");
     else if (msg->security & APPLICATION_PGP)
-      mvaddstr (HDR_CRYPT, 0,     "     PGP: ");
+      mvaddstr (HDR_CRYPT, SidebarWidth,     "     PGP: ");
   }
   else if ((WithCrypto & APPLICATION_SMIME))
-    mvaddstr (HDR_CRYPT, 0,     "  S/MIME: ");
+    mvaddstr (HDR_CRYPT, SidebarWidth,     "  S/MIME: ");
   else if ((WithCrypto & APPLICATION_PGP))
-    mvaddstr (HDR_CRYPT, 0,     "     PGP: ");
+    mvaddstr (HDR_CRYPT, SidebarWidth,     "     PGP: ");
   else
     return;
 
@@ -144,7 +144,7 @@ static void redraw_crypt_lines (HEADER *
     }
   clrtoeol ();
 
-  move (HDR_CRYPTINFO, 0);
+  move (HDR_CRYPTINFO, SidebarWidth);
   clrtoeol ();
   if ((WithCrypto & APPLICATION_PGP)
       && msg->security & APPLICATION_PGP  && msg->security & SIGN)
@@ -160,7 +160,7 @@ static void redraw_crypt_lines (HEADER *
       && (msg->security & ENCRYPT)
       && SmimeCryptAlg
       && *SmimeCryptAlg) {
-      mvprintw (HDR_CRYPTINFO, 40, "%s%s", _("Encrypt with: "),
+      mvprintw (HDR_CRYPTINFO, SidebarWidth + 40, "%s%s", _("Encrypt with: "),
 		NONULL(SmimeCryptAlg));
       off = 20;
   }
@@ -174,7 +174,7 @@ static void redraw_mix_line (LIST *chain
   int c;
   char *t;
 
-  mvaddstr (HDR_MIX, 0,     "     Mix: ");
+  mvaddstr (HDR_MIX, SidebarWidth,     "     Mix: ");
 
   if (!chain)
   {
@@ -189,7 +189,7 @@ static void redraw_mix_line (LIST *chain
     if (t && t[0] == '0' && t[1] == '\0')
       t = "<random>";
     
-    if (c + mutt_strlen (t) + 2 >= COLS)
+    if (c + mutt_strlen (t) + 2 >= COLS - SidebarWidth)
       break;
 
     addstr (NONULL(t));
@@ -241,7 +241,7 @@ static void draw_envelope_addr (int line
 
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), addr, 1);
-  mvprintw (line, 0, TITLE_FMT, Prompts[line - 1]);
+  mvprintw (line, SidebarWidth, TITLE_FMT, Prompts[line - 1]);
   mutt_paddstr (W, buf);
 }
 
@@ -251,10 +251,10 @@ static void draw_envelope (HEADER *msg, 
   draw_envelope_addr (HDR_TO, msg->env->to);
   draw_envelope_addr (HDR_CC, msg->env->cc);
   draw_envelope_addr (HDR_BCC, msg->env->bcc);
-  mvprintw (HDR_SUBJECT, 0, TITLE_FMT, Prompts[HDR_SUBJECT - 1]);
+  mvprintw (HDR_SUBJECT, SidebarWidth, TITLE_FMT, Prompts[HDR_SUBJECT - 1]);
   mutt_paddstr (W, NONULL (msg->env->subject));
   draw_envelope_addr (HDR_REPLYTO, msg->env->reply_to);
-  mvprintw (HDR_FCC, 0, TITLE_FMT, Prompts[HDR_FCC - 1]);
+  mvprintw (HDR_FCC, SidebarWidth, TITLE_FMT, Prompts[HDR_FCC - 1]);
   mutt_paddstr (W, fcc);
 
   if (WithCrypto)
@@ -265,7 +265,7 @@ static void draw_envelope (HEADER *msg, 
 #endif
 
   SETCOLOR (MT_COLOR_STATUS);
-  mvaddstr (HDR_ATTACH - 1, 0, _("-- Attachments"));
+  mvaddstr (HDR_ATTACH - 1, SidebarWidth, _("-- Attachments"));
   BKGDSET (MT_COLOR_STATUS);
   clrtoeol ();
 
@@ -303,7 +303,7 @@ static int edit_address_list (int line, 
   /* redraw the expanded list so the user can see the result */
   buf[0] = 0;
   rfc822_write_address (buf, sizeof (buf), *addr, 1);
-  move (line, HDR_XOFFSET);
+  move (line, HDR_XOFFSET+SidebarWidth);
   mutt_paddstr (W, buf);
   
   return 0;
@@ -545,7 +545,7 @@ int mutt_compose_menu (HEADER *msg,   /*
 	if (mutt_get_field ("Subject: ", buf, sizeof (buf), 0) == 0)
 	{
 	  mutt_str_replace (&msg->env->subject, buf);
-	  move (HDR_SUBJECT, HDR_XOFFSET);
+	  move (HDR_SUBJECT, HDR_XOFFSET + SidebarWidth);
 	  clrtoeol ();
 	  if (msg->env->subject)
 	    mutt_paddstr (W, msg->env->subject);
@@ -560,7 +560,7 @@ int mutt_compose_menu (HEADER *msg,   /*
 	{
 	  strfcpy (fcc, buf, _POSIX_PATH_MAX);
 	  mutt_pretty_mailbox (fcc);
-	  move (HDR_FCC, HDR_XOFFSET);
+	  move (HDR_FCC, HDR_XOFFSET + SidebarWidth);
 	  mutt_paddstr (W, fcc);
 	  fccSet = 1;
 	}
diff -urp mutt.orig/curs_main.c mutt/curs_main.c
--- mutt.orig/curs_main.c	2004-04-12 23:51:07.000000000 +0200
+++ mutt/curs_main.c	2004-10-02 19:26:39.000000000 +0200
@@ -24,6 +24,7 @@
 #include "sort.h"
 #include "buffy.h"
 #include "mx.h"
+#include "sidebar.h"
 
 #ifdef USE_POP
 #include "pop.h"
@@ -534,6 +535,7 @@ int mutt_index_menu (void)
     if (menu->redraw & REDRAW_FULL)
     {
       menu_redraw_full (menu);
+      draw_sidebar(menu->menu);
       mutt_show_error ();
     }
 
@@ -556,7 +558,9 @@ int mutt_index_menu (void)
 
       if (menu->redraw & REDRAW_STATUS) 
       {
+	DrawFullLine = 1;
 	menu_status_line (buf, sizeof (buf), menu, NONULL (Status));
+	DrawFullLine = 0;
 	CLEARLINE (option (OPTSTATUSONTOP) ? 0 : LINES-2);
 	SETCOLOR (MT_COLOR_STATUS);
 	mutt_paddstr (COLS, buf);
@@ -1033,6 +1037,7 @@ CHECK_IMAP_ACL(IMAP_ACL_DELETE);
 	  menu->redraw = REDRAW_FULL;
 	break;
 
+      case OP_OPEN_MBOX:
       case OP_MAIN_CHANGE_FOLDER:
       
 	if (attach_msg)
@@ -1050,7 +1055,9 @@ CHECK_IMAP_ACL(IMAP_ACL_DELETE);
 	buf[0] = '\0';
 	mutt_buffy (buf, sizeof (buf));
 
-	if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
+	if ( op == OP_OPEN_MBOX )
+	  strncpy( buf, CurBuffy->path, sizeof(buf) );
+	else if (mutt_enter_fname (cp, buf, sizeof (buf), &menu->redraw, 1) == -1)
 	  break;
 	if (!buf[0])
 	{
@@ -1059,6 +1066,7 @@ CHECK_IMAP_ACL(IMAP_ACL_DELETE);
 	}
 
 	mutt_expand_path (buf, sizeof (buf));
+        set_curbuffy(buf);
 	if (mx_get_magic (buf) <= 0)
 	{
 	  mutt_error (_("%s is not a mailbox."), buf);
@@ -2073,6 +2081,12 @@ CHECK_IMAP_ACL(IMAP_ACL_DELETE);
 	mutt_what_key();
 	break;
 
+	  case OP_SCROLL_MBOX_UP:
+	  case OP_SCROLL_MBOX_DOWN:
+	  case OP_NEXT_MBOX:
+	  case OP_PREV_MBOX:
+	    scroll_sidebar(op, menu->menu);
+		break;
       default:
 	if (menu->menu == MENU_MAIN)
 	  km_error_key (MENU_MAIN);
diff -urp mutt.orig/flags.c mutt/flags.c
--- mutt.orig/flags.c	2003-01-31 00:48:36.000000000 +0100
+++ mutt/flags.c	2004-10-02 19:26:47.000000000 +0200
@@ -18,8 +18,10 @@
 
 #include "mutt.h"
 #include "mutt_curses.h"
+#include "mutt_menu.h"
 #include "sort.h"
 #include "mx.h"
+#include "sidebar.h"
 
 #ifdef USE_IMAP
 #include "imap_private.h"
@@ -270,6 +272,7 @@ void _mutt_set_flag (CONTEXT *ctx, HEADE
    */
   if (h->searched && (changed != h->changed || deleted != ctx->deleted || tagged != ctx->tagged))
     h->searched = 0;
+	draw_sidebar(0);
 }
 
 void mutt_tag_set_flag (int flag, int bf)
diff -urp mutt.orig/functions.h mutt/functions.h
--- mutt.orig/functions.h	2003-07-04 19:07:22.000000000 +0200
+++ mutt/functions.h	2004-10-02 19:26:47.000000000 +0200
@@ -149,6 +149,11 @@ struct binding_t OpMain[] = {
   { "decrypt-save",		OP_DECRYPT_SAVE,		NULL },
 
 
+  { "scroll-mbox-up",	OP_SCROLL_MBOX_UP, NULL },
+  { "scroll-mbox-down",	OP_SCROLL_MBOX_DOWN, NULL },
+  { "next-mbox",	OP_NEXT_MBOX, NULL },
+  { "previous-mbox",	OP_PREV_MBOX, NULL },
+  { "open-mbox", OP_OPEN_MBOX, NULL },
   { NULL,			0,				NULL }
 };
 
@@ -243,6 +248,11 @@ struct binding_t OpPager[] = {
   { "decrypt-save",    	OP_DECRYPT_SAVE,		NULL },
 
 
+  { "scroll-mbox-up",	OP_SCROLL_MBOX_UP, NULL },
+  { "scroll-mbox-down",	OP_SCROLL_MBOX_DOWN, NULL },
+  { "next-mbox",	OP_NEXT_MBOX, NULL },
+  { "previous-mbox",	OP_PREV_MBOX, NULL },
+  { "open-mbox", OP_OPEN_MBOX, NULL },
   { NULL,		0,				NULL }
 };
 
diff -urp mutt.orig/globals.h mutt/globals.h
--- mutt.orig/globals.h	2004-09-04 13:31:21.000000000 +0200
+++ mutt/globals.h	2004-10-02 19:26:47.000000000 +0200
@@ -163,6 +163,9 @@ WHERE short ScoreThresholdDelete;
 WHERE short ScoreThresholdRead;
 WHERE short ScoreThresholdFlag;
 
+WHERE struct buffy_t *CurBuffy INITVAL(0);
+WHERE short DrawFullLine INITVAL(0);
+WHERE short SidebarWidth;
 #ifdef USE_IMAP
 WHERE short ImapKeepalive;
 #endif
diff -urp mutt.orig/init.h mutt/init.h
--- mutt.orig/init.h	2004-09-04 13:31:21.000000000 +0200
+++ mutt/init.h	2004-10-02 19:26:47.000000000 +0200
@@ -1059,6 +1059,16 @@ struct option_t MuttVars[] = {
   ** This specifies the folder into which read mail in your ``$$spoolfile''
   ** folder will be appended.
   */
+  { "mbox_pane_show", DT_BOOL, R_BOTH, OPTMBOXPANE, 0 },
+  /*
+  ** .pp
+  ** This specifies whether or not to show the mailbox list pane.
+  */
+  { "mbox_pane_width", DT_NUM, R_BOTH, UL &SidebarWidth, 0 },
+  /*
+  ** .pp
+  ** The width of the mailbox list pane (left sidebar like in GUIs).
+  */
   { "mbox_type",	DT_MAGIC,R_NONE, UL &DefaultMagic, M_MBOX },
   /*
   ** .pp
diff -urp mutt.orig/menu.c mutt/menu.c
--- mutt.orig/menu.c	2004-09-04 13:31:21.000000000 +0200
+++ mutt/menu.c	2004-10-02 19:26:47.000000000 +0200
@@ -20,6 +20,7 @@
 #include "mutt_curses.h"
 #include "mutt_menu.h"
 #include "mbyte.h"
+#include "sidebar.h"
 
 #ifdef USE_IMAP
 #include "imap.h"
@@ -153,7 +154,7 @@ static void menu_make_entry (char *s, in
 void menu_pad_string (char *s, size_t n)
 {
   int shift = option (OPTARROWCURSOR) ? 3 : 0;
-  int cols = COLS - shift;
+  int cols = COLS - shift - SidebarWidth;
 
   mutt_format_string (s, n, cols, cols, 0, ' ', s, strlen (s), 1);
   s[n - 1] = 0;
@@ -203,6 +204,7 @@ void menu_redraw_index (MUTTMENU *menu)
   char buf[STRING];
   int i;
 
+  draw_sidebar(1);
   for (i = menu->top; i < menu->top + menu->pagelen; i++)
   {
     if (i < menu->max)
@@ -213,7 +215,7 @@ void menu_redraw_index (MUTTMENU *menu)
       if (option (OPTARROWCURSOR))
       {
         attrset (menu->color (i));
-	CLEARLINE (i - menu->top + menu->offset);
+	CLEARLINE_WIN (i - menu->top + menu->offset);
 
 	if (i == menu->current)
 	{
@@ -224,7 +226,7 @@ void menu_redraw_index (MUTTMENU *menu)
 	  addch (' ');
 	}
 	else
-	  move (i - menu->top + menu->offset, 3);
+	  move (i - menu->top + menu->offset, SidebarWidth + 3);
 
         print_enriched_string (menu->color(i), (unsigned char *) buf, 1);
         SETCOLOR (MT_COLOR_NORMAL);          
@@ -239,14 +241,14 @@ void menu_redraw_index (MUTTMENU *menu)
 	  BKGDSET (MT_COLOR_INDICATOR);
 	}
 
-	CLEARLINE (i - menu->top + menu->offset);
+	CLEARLINE_WIN (i - menu->top + menu->offset);
 	print_enriched_string (menu->color(i), (unsigned char *) buf, i != menu->current);
         SETCOLOR (MT_COLOR_NORMAL);
         BKGDSET (MT_COLOR_NORMAL);
       }
     }
     else
-      CLEARLINE (i - menu->top + menu->offset);
+      CLEARLINE_WIN (i - menu->top + menu->offset);
   }
   menu->redraw = 0;
 }
@@ -261,7 +263,7 @@ void menu_redraw_motion (MUTTMENU *menu)
     return;
   }
   
-  move (menu->oldcurrent + menu->offset - menu->top, 0);
+  move (menu->oldcurrent + menu->offset - menu->top, SidebarWidth);
   SETCOLOR (MT_COLOR_NORMAL);
   BKGDSET (MT_COLOR_NORMAL);
 
@@ -276,13 +278,13 @@ void menu_redraw_motion (MUTTMENU *menu)
       clrtoeol ();
       menu_make_entry (buf, sizeof (buf), menu, menu->oldcurrent);
       menu_pad_string (buf, sizeof (buf));
-      move (menu->oldcurrent + menu->offset - menu->top, 3);
+      move (menu->oldcurrent + menu->offset - menu->top, SidebarWidth + 3);
       print_enriched_string (menu->color(menu->oldcurrent), (unsigned char *) buf, 1);
       SETCOLOR (MT_COLOR_NORMAL);
     }
 
     /* now draw it in the new location */
-    move (menu->current + menu->offset - menu->top, 0);
+    move (menu->current + menu->offset - menu->top, SidebarWidth);
     attrset (menu->color (menu->current));
     ADDCOLOR (MT_COLOR_INDICATOR);
     addstr ("->");
@@ -303,7 +305,7 @@ void menu_redraw_motion (MUTTMENU *menu)
     attrset (menu->color (menu->current));
     ADDCOLOR (MT_COLOR_INDICATOR);
     BKGDSET (MT_COLOR_INDICATOR);
-    CLEARLINE (menu->current - menu->top + menu->offset);
+    CLEARLINE_WIN (menu->current - menu->top + menu->offset);
     print_enriched_string (menu->color(menu->current), (unsigned char *) buf, 0);
     SETCOLOR (MT_COLOR_NORMAL);
     BKGDSET (MT_COLOR_NORMAL);
@@ -315,7 +317,7 @@ void menu_redraw_current (MUTTMENU *menu
 {
   char buf[STRING];
   
-  move (menu->current + menu->offset - menu->top, 0);
+  move (menu->current + menu->offset - menu->top, SidebarWidth);
   menu_make_entry (buf, sizeof (buf), menu, menu->current);
   menu_pad_string (buf, sizeof (buf));
 
diff -urp mutt.orig/mutt.h mutt/mutt.h
--- mutt.orig/mutt.h	2004-07-21 13:33:02.000000000 +0200
+++ mutt/mutt.h	2004-10-02 19:26:47.000000000 +0200
@@ -384,6 +384,7 @@ enum
   OPTMAILDIRTRASH,
   OPTMARKERS,
   OPTMARKOLD,
+  OPTMBOXPANE,
   OPTMENUSCROLL,	/* scroll menu instead of implicit next-page */
   OPTMETAKEY,		/* interpret ALT-x as ESC-x */
   OPTMETOO,
diff -urp mutt.orig/mutt_curses.h mutt/mutt_curses.h
--- mutt.orig/mutt_curses.h	2004-06-18 17:24:22.000000000 +0200
+++ mutt/mutt_curses.h	2004-10-02 19:26:47.000000000 +0200
@@ -59,6 +59,7 @@
 #undef lines
 #endif /* lines */
 
+#define CLEARLINE_WIN(x) move(x,SidebarWidth), clrtoeol()
 #define CLEARLINE(x) move(x,0), clrtoeol()
 #define CENTERLINE(x,y) move(y, (COLS-strlen(x))/2), addstr(x)
 #define BEEP() do { if (option (OPTBEEP)) beep(); } while (0)
@@ -121,6 +122,7 @@ enum
   MT_COLOR_BOLD,
   MT_COLOR_UNDERLINE,
   MT_COLOR_INDEX,
+  MT_COLOR_NEW,
   MT_COLOR_MAX
 };
 
diff -urp mutt.orig/muttlib.c mutt/muttlib.c
--- mutt.orig/muttlib.c	2004-09-04 13:31:22.000000000 +0200
+++ mutt/muttlib.c	2004-10-02 19:26:47.000000000 +0200
@@ -1014,7 +1014,10 @@ void mutt_FormatString (char *dest,		/* 
 	ch = *src++; /* pad char */
 	/* calculate space left on line.  if we've already written more data
 	   than will fit on the line, ignore the rest of the line */
-	count = (COLS < destlen ? COLS : destlen);
+	if ( DrawFullLine )
+	  count = (COLS < destlen ? COLS : destlen);
+	else
+	  count = ((COLS-SidebarWidth) < destlen ? COLS - SidebarWidth : destlen);
 	if (count > wlen)
 	{
 	  count -= wlen; /* how many chars left on this line */
diff -urp mutt.orig/pager.c mutt/pager.c
--- mutt.orig/pager.c	2004-07-18 01:25:28.000000000 +0200
+++ mutt/pager.c	2004-10-02 19:26:47.000000000 +0200
@@ -26,6 +26,7 @@
 #include "pager.h"
 #include "attach.h"
 #include "mbyte.h"
+#include "sidebar.h"
 
 #include "mx.h"
 
@@ -1032,7 +1033,7 @@ static int format_line (struct line_t **
   wchar_t wc;
   mbstate_t mbstate;
 
-  int wrap_cols = COLS - WrapMargin;
+  int wrap_cols = COLS - WrapMargin - SidebarWidth;
   
   if (wrap_cols <= 0)
     wrap_cols = COLS;
@@ -1665,7 +1666,7 @@ mutt_pager (const char *banner, const ch
     if ((redraw & REDRAW_BODY) || topline != oldtopline)
     {
       do {
-	move (bodyoffset, 0);
+	move (bodyoffset, SidebarWidth);
 	curline = oldtopline = topline;
 	lines = 0;
 	force_redraw = 0;
@@ -1678,6 +1679,7 @@ mutt_pager (const char *banner, const ch
 			    &QuoteList, &q_level, &force_redraw, &SearchRE) > 0)
 	    lines++;
 	  curline++;
+		move(lines + bodyoffset, SidebarWidth);
 	}
 	last_offset = lineInfo[curline].offset;
       } while (force_redraw);
@@ -1691,6 +1693,7 @@ mutt_pager (const char *banner, const ch
 	  addch ('~');
 	addch ('\n');
 	lines++;
+	move(lines + bodyoffset, SidebarWidth);
       }
       /* We are going to update the pager status bar, so it isn't
        * necessary to reset to normal color now. */
@@ -1703,20 +1706,22 @@ mutt_pager (const char *banner, const ch
       /* print out the pager status bar */
       SETCOLOR (MT_COLOR_STATUS);
       BKGDSET (MT_COLOR_STATUS);
-      CLEARLINE (statusoffset);
+      CLEARLINE_WIN(statusoffset);
       if (IsHeader (extra))
       {
 	_mutt_make_string (buffer,
-			   COLS-9 < sizeof (buffer) ? COLS-9 : sizeof (buffer),
+			   COLS-9-SidebarWidth < sizeof (buffer) ?
+			   COLS-9-SidebarWidth : sizeof (buffer),
 			   NONULL (PagerFmt), Context, extra->hdr, M_FORMAT_MAKEPRINT);
       }
       else if (IsMsgAttach (extra))
       {
 	_mutt_make_string (buffer,
-			   COLS - 9 < sizeof (buffer) ? COLS - 9: sizeof (buffer),
+			   COLS - 9 - SidebarWidth < sizeof (buffer) ?
+			   COLS - 9 - SidebarWidth : sizeof (buffer),
 			   NONULL (PagerFmt), Context, extra->bdy->hdr, M_FORMAT_MAKEPRINT);
       }
-      mutt_paddstr (COLS-10, IsHeader (extra) || IsMsgAttach (extra) ?
+      mutt_paddstr (COLS-10-SidebarWidth, IsHeader (extra) || IsMsgAttach (extra) ?
 		    buffer : banner);
       addstr (" -- (");
       if (last_pos < sb.st_size - 1)
@@ -1732,15 +1737,18 @@ mutt_pager (const char *banner, const ch
       /* redraw the pager_index indicator, because the
        * flags for this message might have changed. */
       menu_redraw_current (index);
-
+	  draw_sidebar(MENU_PAGER);
       /* print out the index status bar */
       menu_status_line (buffer, sizeof (buffer), index, NONULL(Status));
- 
-      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)), 0);
+      move (indexoffset + (option (OPTSTATUSONTOP) ? 0 : (indexlen - 1)),
+		  SidebarWidth);
       SETCOLOR (MT_COLOR_STATUS);
-      mutt_paddstr (COLS, buffer);
+      mutt_paddstr (COLS-SidebarWidth, buffer);
       SETCOLOR (MT_COLOR_NORMAL);
     }
+	/* if we're not using the index, update every time */
+	if ( index == 0 )
+		draw_sidebar(MENU_PAGER);
 
     redraw = 0;
 
@@ -2618,6 +2626,13 @@ CHECK_IMAP_ACL(IMAP_ACL_DELETE);
         redraw = REDRAW_FULL;
         break;
 
+	  case OP_SCROLL_MBOX_UP:
+	  case OP_SCROLL_MBOX_DOWN:
+	  case OP_NEXT_MBOX:
+	  case OP_PREV_MBOX:
+	  case OP_OPEN_MBOX:
+	    scroll_sidebar(ch, MENU_PAGER);
+		break;
       default:
 	ch = -1;
 	break;
diff -urp mutt.orig/sidebar.c mutt/sidebar.c
--- mutt.orig/sidebar.c	2004-10-02 20:19:33.000000000 +0200
+++ mutt/sidebar.c	2004-10-02 19:37:36.000000000 +0200
@@ -0,0 +1,251 @@
+/*
+ * Copyright (C) ????-2004 Justin Hibbits <jrh29@po.cwru.edu>
+ * Copyright (C) 2004 Thomer M. Gil <mutt@thomer.com>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+ */ 
+
+
+
+#include "mutt.h"
+#include "mutt_menu.h"
+#include "mutt_curses.h"
+#include "sidebar.h"
+#include "buffy.h"
+#include <libgen.h>
+#include "keymap.h"
+#include <stdbool.h>
+
+/*BUFFY *CurBuffy = 0;*/
+static BUFFY *TopBuffy = 0;
+static BUFFY *BottomBuffy = 0;
+static int known_lines = 0;
+
+static int quick_log10(int n)
+{
+        char string[32];
+        sprintf(string, "%d", n);
+        return strlen(string);
+}
+
+void calc_boundaries (int menu)
+{
+	BUFFY *tmp = Incoming;
+
+	if ( known_lines != LINES ) {
+		TopBuffy = BottomBuffy = 0;
+		known_lines = LINES;
+	}
+	for ( ; tmp->next != 0; tmp = tmp->next )
+		tmp->next->prev = tmp;
+
+	if ( TopBuffy == 0 && BottomBuffy == 0 )
+		TopBuffy = Incoming;
+	if ( BottomBuffy == 0 ) {
+		int count = LINES - 2 - (menu != MENU_PAGER);
+		BottomBuffy = TopBuffy;
+		while ( --count && BottomBuffy->next )
+			BottomBuffy = BottomBuffy->next;
+	}
+	else if ( TopBuffy == CurBuffy->next ) {
+		int count = LINES - 2 - (menu != MENU_PAGER);
+		BottomBuffy = CurBuffy;
+		tmp = BottomBuffy;
+		while ( --count && tmp->prev)
+			tmp = tmp->prev;
+		TopBuffy = tmp;
+	}
+	else if ( BottomBuffy == CurBuffy->prev ) {
+		int count = LINES - 2 - (menu != MENU_PAGER);
+		TopBuffy = CurBuffy;
+		tmp = TopBuffy;
+		while ( --count && tmp->next )
+			tmp = tmp->next;
+		BottomBuffy = tmp;
+	}
+}
+
+char *make_sidebar_entry(char *box, int size, int new)
+{
+	static char *entry = 0;
+	char *c;
+	int i = 0;
+
+	c = realloc(entry, SidebarWidth + 1);
+	if ( c ) entry = c;
+	entry[SidebarWidth] = 0;
+	for (; i < SidebarWidth; entry[i++] = ' ' );
+	i = strlen(box);
+	strncpy( entry, box, i < SidebarWidth ? i :SidebarWidth );
+
+	if ( new ) 
+		sprintf(
+			entry + SidebarWidth - 5 - quick_log10(size) - quick_log10(new),
+			"% d(%d)", size, new);
+	else
+		sprintf( entry + SidebarWidth - 3 - quick_log10(size), "% d", size);
+	return entry;
+}
+
+void set_curbuffy(char buf[LONG_STRING])
+{
+  BUFFY* tmp = CurBuffy = Incoming;
+	if (!Incoming) return;
+  while(1) {
+    if(!strcmp(tmp->path, buf)) {
+      CurBuffy = tmp;
+      break;
+    }
+
+    if(tmp->next)
+      tmp = tmp->next;
+    else
+      break;
+  }
+}
+
+int draw_sidebar(int menu) {
+
+	int lines = option(OPTHELP) ? 1 : 0;
+	BUFFY *tmp;
+#ifndef USE_SLANG_CURSES
+        attr_t attrs;
+#endif
+        short color_pair;
+
+        static bool initialized = false;
+        static int prev_show_value;
+        static short saveSidebarWidth;
+
+        /* initialize first time */
+        if(!initialized) {
+                prev_show_value = option(OPTMBOXPANE);
+                saveSidebarWidth = SidebarWidth;
+                if(!option(OPTMBOXPANE)) SidebarWidth = 0;
+                initialized = true;
+        }
+
+        /* save or restore the value SidebarWidth */
+        if(prev_show_value != option(OPTMBOXPANE)) {
+                if(prev_show_value && !option(OPTMBOXPANE)) {
+                        saveSidebarWidth = SidebarWidth;
+                        SidebarWidth = 0;
+                } else if(!prev_show_value && option(OPTMBOXPANE)) {
+                        SidebarWidth = saveSidebarWidth;
+                }
+                prev_show_value = option(OPTMBOXPANE);
+        }
+
+
+	if ( SidebarWidth == 0 ) return 0;
+
+        /* get attributes for divider */
+	SETCOLOR(MT_COLOR_STATUS);
+#ifndef USE_SLANG_CURSES
+        attr_get(&attrs, &color_pair, 0);
+#else
+		color_pair = attr_get();
+#endif
+        SETCOLOR(MT_COLOR_NORMAL);
+
+	/* draw the divider */
+
+	for ( ; lines < LINES-1-(menu != MENU_PAGER); lines++ ) {
+		move(lines, SidebarWidth - 1);
+		addch('|');
+ #ifndef USE_SLANG_CURSES
+                mvchgat(lines, SidebarWidth - 1, 1, 0, color_pair, NULL);
+ #endif
+	}
+	if ( Incoming == 0 ) return 0;
+	lines = option(OPTHELP) ? 1 : 0; /* go back to the top */
+
+	if ( known_lines != LINES || TopBuffy == 0 || BottomBuffy == 0 ) 
+		calc_boundaries(menu);
+	if ( CurBuffy == 0 ) CurBuffy = Incoming;
+
+	tmp = TopBuffy;
+
+	SETCOLOR(MT_COLOR_NORMAL);
+
+	for ( ; tmp && lines < LINES-1 - (menu != MENU_PAGER); tmp = tmp->next ) {
+		if ( tmp == CurBuffy )
+			SETCOLOR(MT_COLOR_INDICATOR);
+		else if ( tmp->msg_unread > 0 )
+			SETCOLOR(MT_COLOR_NEW);
+		else
+			SETCOLOR(MT_COLOR_NORMAL);
+
+		move( lines, 0 );
+		if ( Context && !strcmp( tmp->path, Context->path ) ) {
+			printw( "%.*s", SidebarWidth,
+				make_sidebar_entry(basename(tmp->path), Context->msgcount,
+				Context->unread));
+			tmp->msg_unread = Context->unread;
+			tmp->msgcount = Context->msgcount;
+		}
+		else
+			printw( "%.*s", SidebarWidth,
+				make_sidebar_entry(basename(tmp->path), tmp->msgcount,
+				tmp->msg_unread));
+		lines++;
+	}
+	SETCOLOR(MT_COLOR_NORMAL);
+	for ( ; lines < LINES - 1 - (menu != MENU_PAGER); lines++ ) {
+		int i = 0;
+		move( lines, 0 );
+		for ( ; i < SidebarWidth - 1; i++ )
+			addch(' ');
+	}
+	return 0;
+}
+
+void scroll_sidebar(int op, int menu)
+{
+        if(!SidebarWidth) return;
+
+	switch (op) {
+		case OP_NEXT_MBOX:
+			if ( CurBuffy->next == NULL ) return;
+			CurBuffy = CurBuffy->next;
+			break;
+		case OP_PREV_MBOX:
+			if ( CurBuffy == Incoming ) return;
+			{
+				BUFFY *tmp = Incoming;
+				while ( tmp->next && strcmp(tmp->next->path, CurBuffy->path) ) tmp = tmp->next;
+				CurBuffy = tmp;
+			}
+			break;
+		case OP_SCROLL_MBOX_UP:
+			CurBuffy = TopBuffy;
+			if ( CurBuffy != Incoming ) {
+				calc_boundaries(menu);
+				CurBuffy = CurBuffy->prev;
+			}
+			break;
+		case OP_SCROLL_MBOX_DOWN:
+			CurBuffy = BottomBuffy;
+			if ( CurBuffy->next ) {
+				calc_boundaries(menu);
+				CurBuffy = CurBuffy->next;
+			}
+			break;
+		default:
+			return;
+	}
+	calc_boundaries(menu);
+	draw_sidebar(menu);
+}
diff -urp mutt.orig/sidebar.h mutt/sidebar.h
--- mutt.orig/sidebar.h	2004-10-02 20:19:30.000000000 +0200
+++ mutt/sidebar.h	2004-10-02 19:37:36.000000000 +0200
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) ????-2004 Justin Hibbits <jrh29@po.cwru.edu>
+ * Copyright (C) 2004 Thomer M. Gil <mutt@thomer.com>
+ * 
+ *     This program is free software; you can redistribute it and/or modify
+ *     it under the terms of the GNU General Public License as published by
+ *     the Free Software Foundation; either version 2 of the License, or
+ *     (at your option) any later version.
+ * 
+ *     This program is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ * 
+ *     You should have received a copy of the GNU General Public License
+ *     along with this program; if not, write to the Free Software
+ *     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111, USA.
+ */ 
+
+#ifndef SIDEBAR_H
+#define SIDEBAR_H
+
+struct MBOX_LIST {
+	char *path;
+	int msgcount;
+	int new;
+} MBLIST;
+
+/* parameter is whether or not to go to the status line */
+/* used for omitting the last | that covers up the status bar in the index */
+int draw_sidebar(int);
+void scroll_sidebar(int, int);
+void set_curbuffy(char*);
+
+#endif /* SIDEBAR_H */
