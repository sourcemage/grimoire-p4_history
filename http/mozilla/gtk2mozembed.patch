Index: Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/Makefile.in,v
retrieving revision 1.200
diff -u -r1.200 Makefile.in
--- Makefile.in	9 Nov 2002 19:38:26 -0000	1.200
+++ Makefile.in	16 Nov 2002 01:26:56 -0000
@@ -260,6 +260,10 @@
 tier_99_dirs	+= embedding/browser/gtk/tests
 endif
 
+ifdef MOZ_ENABLE_GTK2
+tier_99_dirs	+= embedding/browser/gtk/tests
+endif
+
 else
 
 # Standalone build
Index: embedding/browser/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/embedding/browser/Makefile.in,v
retrieving revision 1.10
diff -u -r1.10 Makefile.in
--- embedding/browser/Makefile.in	18 Dec 2001 09:10:33 -0000	1.10
+++ embedding/browser/Makefile.in	16 Nov 2002 01:26:56 -0000
@@ -31,6 +31,10 @@
 DIRS += gtk
 endif
 
+ifdef MOZ_ENABLE_GTK2
+DIRS += gtk
+endif
+
 ifdef MOZ_ENABLE_PHOTON
 DIRS += photon
 endif
Index: embedding/browser/gtk/src/EmbedProgress.cpp
===================================================================
RCS file: /cvsroot/mozilla/embedding/browser/gtk/src/EmbedProgress.cpp,v
retrieving revision 1.10
diff -u -r1.10 EmbedProgress.cpp
--- embedding/browser/gtk/src/EmbedProgress.cpp	7 Sep 2002 17:09:12 -0000	1.10
+++ embedding/browser/gtk/src/EmbedProgress.cpp	16 Nov 2002 01:26:56 -0000
@@ -80,8 +80,8 @@
   }
   gtk_signal_emit(GTK_OBJECT(mOwner->mOwningWidget),
 		  moz_embed_signals[NET_STATE_ALL],
-		  (const char *)uriString, aStateFlags, aStatus);
-
+		  (gpointer)(const char *)uriString,
+		  (gint)aStateFlags, (gint)aStatus);
   // and for stop, too
   if ((aStateFlags & GTK_MOZ_EMBED_FLAG_IS_NETWORK) && 
       (aStateFlags & GTK_MOZ_EMBED_FLAG_STOP))
Index: embedding/browser/gtk/src/EmbedWindow.cpp
===================================================================
RCS file: /cvsroot/mozilla/embedding/browser/gtk/src/EmbedWindow.cpp,v
retrieving revision 1.26
diff -u -r1.26 EmbedWindow.cpp
--- embedding/browser/gtk/src/EmbedWindow.cpp	7 Sep 2002 17:09:12 -0000	1.26
+++ embedding/browser/gtk/src/EmbedWindow.cpp	16 Nov 2002 01:26:56 -0000
@@ -224,22 +224,48 @@
 NS_IMETHODIMP
 EmbedWindow::FocusNextElement()
 {
+#ifdef MOZ_WIDGET_GTK
   GtkWidget* parent = GTK_WIDGET(mOwner->mOwningWidget)->parent;
 
   if (GTK_IS_CONTAINER(parent))
     gtk_container_focus(GTK_CONTAINER(parent),
                         GTK_DIR_TAB_FORWARD);
+#endif
+
+#ifdef MOZ_WIDGET_GTK2
+  GtkWidget *toplevel;
+  toplevel = gtk_widget_get_toplevel(GTK_WIDGET(mOwner->mOwningWidget));
+  if (!GTK_WIDGET_TOPLEVEL(toplevel))
+    return NS_OK;
+
+  g_signal_emit_by_name(G_OBJECT(toplevel), "move_focus",
+			GTK_DIR_TAB_FORWARD);
+#endif
+
   return NS_OK;
 }
 
 NS_IMETHODIMP
 EmbedWindow::FocusPrevElement()
 {
+#ifdef MOZ_WIDGET_GTK
   GtkWidget* parent = GTK_WIDGET(mOwner->mOwningWidget)->parent;
 
   if (GTK_IS_CONTAINER(parent))
     gtk_container_focus(GTK_CONTAINER(parent),
                         GTK_DIR_TAB_BACKWARD);
+#endif
+
+#ifdef MOZ_WIDGET_GTK2
+  GtkWidget *toplevel;
+  toplevel = gtk_widget_get_toplevel(GTK_WIDGET(mOwner->mOwningWidget));
+  if (!GTK_WIDGET_TOPLEVEL(toplevel))
+    return NS_OK;
+
+  g_signal_emit_by_name(G_OBJECT(toplevel), "move_focus",
+			GTK_DIR_TAB_BACKWARD);
+#endif
+
   return NS_OK;
 }
 
@@ -345,9 +371,15 @@
 EmbedWindow::OnShowTooltip(PRInt32 aXCoords, PRInt32 aYCoords,
 			   const PRUnichar *aTipText)
 {
-  
   nsAutoString tipText ( aTipText );
+
+#ifdef MOZ_WIDGET_GTK
   const char* tipString = ToNewCString(tipText);
+#endif
+
+#ifdef MOZ_WIDGET_GTK2
+  const char* tipString = ToNewUTF8String(tipText);
+#endif
 
   if (sTipWindow)
     gtk_widget_destroy(sTipWindow);
@@ -405,7 +437,9 @@
            0, 0,
            sTipWindow->allocation.width, sTipWindow->allocation.height);
 
+#ifdef MOZ_WIDGET_GTK
   gtk_widget_popup(sTipWindow, aXCoords + root_x, aYCoords + root_y);
+#endif /* MOZ_WIDGET_GTK */
   
   nsMemory::Free( (void*)tipString );
 
Index: embedding/browser/gtk/src/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/embedding/browser/gtk/src/Makefile.in,v
retrieving revision 1.37
diff -u -r1.37 Makefile.in
--- embedding/browser/gtk/src/Makefile.in	9 Nov 2002 19:38:31 -0000	1.37
+++ embedding/browser/gtk/src/Makefile.in	16 Nov 2002 01:26:58 -0000
@@ -56,6 +56,11 @@
 		EmbedWindowCreator.cpp \
 		EmbedStream.cpp
 
+ifdef MOZ_ENABLE_GTK2
+CSRCS           = \
+		gtkmozembedmarshal.c
+endif
+
 ifdef BUILD_STATIC_LIBS
 # Static build stuff
 DEFINES         += -D_BUILD_STATIC_BIN=1
@@ -88,13 +93,21 @@
 		gtkmozembed.h \
 		gtkmozembed_internal.h
 
+ifdef MOZ_ENABLE_GTK
 EXTRA_DSO_LDOPTS = \
 		$(MOZ_COMPONENT_LIBS) \
 		$(XPCOM_GLUE_LIBS) \
 		-lgtksuperwin \
 		$(NULL)
+endif
+
+ifdef MOZ_ENABLE_GTK2
+EXTRA_DSO_LDOPTS = \
+		$(MOZ_COMPONENT_LIBS) \
+		$(NULL)
+endif
 
-EXTRA_DSO_LDOPTS += $(MOZ_GTK_LDFLAGS)
+EXTRA_DSO_LDOPTS += $(MOZ_GTK_LDFLAGS) $(MOZ_GTK2_LIBS)
 
 include $(topsrcdir)/config/rules.mk
 
@@ -109,7 +122,8 @@
 endif
 endif
 
-CXXFLAGS        += $(MOZ_GTK_CFLAGS)
+CXXFLAGS        += $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
+CFLAGS          += $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
 
 ifdef BUILD_STATIC_LIBS
 
Index: embedding/browser/gtk/src/gtkmozembed2.cpp
===================================================================
RCS file: /cvsroot/mozilla/embedding/browser/gtk/src/gtkmozembed2.cpp,v
retrieving revision 1.23
diff -u -r1.23 gtkmozembed2.cpp
--- embedding/browser/gtk/src/gtkmozembed2.cpp	12 Jan 2002 05:04:57 -0000	1.23
+++ embedding/browser/gtk/src/gtkmozembed2.cpp	16 Nov 2002 01:26:58 -0000
@@ -36,10 +36,32 @@
 #include <nsXPIDLString.h>
 #include <nsReadableUtils.h>
 
+#ifdef MOZ_WIDGET_GTK2
+
+#include "gtkmozembedmarshal.h"
+
+#define NEW_TOOLKIT_STRING(x) ToNewUTF8String(x)
+#define GET_OBJECT_CLASS_TYPE(x) G_OBJECT_CLASS_TYPE(x)
+
+#endif /* MOZ_WIDGET_GTK2 */
+
+#ifdef MOZ_WIDGET_GTK
+
 // so we can get callbacks from the mozarea
 #include <gtkmozarea.h>
 
-class nsIDirectoryServiceProvider;
+// so we get the right marshaler for gtk 1.2
+#define gtkmozembed_VOID__INT_UINT \
+  gtk_marshal_NONE__INT_INT
+#define gtkmozembed_VOID__POINTER_INT_INT \
+  gtk_marshal_NONE__POINTER_INT_INT
+#define gtkmozembed_VOID__POINTER_INT_UINT \
+  gtk_marshal_NONE__POINTER_INT_INT
+#define gtkmozembed_VOID__POINTER_INT_POINTER \
+  gtk_marshal_NONE__POINTER_INT_POINTER
+
+#define NEW_TOOLKIT_STRING(x) ToNewCString(x)
+#define GET_OBJECT_CLASS_TYPE(x) (GTK_OBJECT_CLASS(x)->type)
 
 // Some "massaged" enum information for the GTK Type System
 static GtkFlagValue gtk_moz_embed_progress_flags_values[] = {
@@ -138,7 +160,9 @@
   { 0,
     NULL, NULL }
 };
+#endif /* MOZ_WIDGET_GTK */
 
+class nsIDirectoryServiceProvider;
 
 // class and instance initialization
 
@@ -180,8 +204,9 @@
 		       GdkEventFocus *aGdkFocusEvent,
 		       GtkMozEmbed   *aEmbed);
 
-// signal handlers for tracking the focus and and focus out events on
-// the toplevel window.
+#ifdef MOZ_WIDGET_GTK
+// signal handlers for tracking the focus in and and focus out events
+// on the toplevel window.
 
 static void
 handle_toplevel_focus_in (GtkMozArea    *aArea,
@@ -189,6 +214,21 @@
 static void
 handle_toplevel_focus_out(GtkMozArea    *aArea,
 			  GtkMozEmbed   *aEmbed);
+#endif /* MOZ_WIDGET_GTK */
+
+#ifdef MOZ_WIDGET_GTK2
+// signal handlers for tracking the focus in and focus out events on
+// the toplevel window.
+
+static gint
+handle_toplevel_focus_in(GtkWidget     *aWidget,
+			 GdkEventFocus *aEvent,
+			 EmbedPrivate  *aPrivate);
+static gint
+handle_toplevel_focus_out(GtkWidget     *aWidget,
+			  GdkEventFocus *aEvent,
+			  EmbedPrivate  *aPrivate);
+#endif /* MOZ_WIDGET_GTK2 */
 
 // globals for this type of widget
 
@@ -249,191 +289,193 @@
   moz_embed_signals[LINK_MESSAGE] = 
     gtk_signal_new ("link_message",
 		    GTK_RUN_FIRST,
-		    object_class->type,
+		    GET_OBJECT_CLASS_TYPE(klass),
 		    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, link_message),
 		    gtk_marshal_NONE__NONE,
 		    GTK_TYPE_NONE, 0);
   moz_embed_signals[JS_STATUS] =
     gtk_signal_new ("js_status",
 		    GTK_RUN_FIRST,
-		    object_class->type,
+		    GET_OBJECT_CLASS_TYPE(klass),
 		    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, js_status),
 		    gtk_marshal_NONE__NONE,
 		    GTK_TYPE_NONE, 0);
   moz_embed_signals[LOCATION] =
     gtk_signal_new ("location",
 		    GTK_RUN_FIRST,
-		    object_class->type,
+		    GET_OBJECT_CLASS_TYPE(klass),
 		    GTK_SIGNAL_OFFSET(GtkMozEmbedClass, location),
 		    gtk_marshal_NONE__NONE,
 		    GTK_TYPE_NONE, 0);
   moz_embed_signals[TITLE] = 
     gtk_signal_new("title",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, title),
 		   gtk_marshal_NONE__NONE,
 		   GTK_TYPE_NONE, 0);
   moz_embed_signals[PROGRESS] =
     gtk_signal_new("progress",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, progress),
 		   gtk_marshal_NONE__INT_INT,
 		   GTK_TYPE_NONE, 2, GTK_TYPE_INT, GTK_TYPE_INT);
   moz_embed_signals[PROGRESS_ALL] = 
     gtk_signal_new("progress_all",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, progress_all),
-		   gtk_marshal_NONE__POINTER_INT_INT,
+		   gtkmozembed_VOID__POINTER_INT_INT,
 		   GTK_TYPE_NONE, 3, GTK_TYPE_STRING,
 		   GTK_TYPE_INT, GTK_TYPE_INT);
   moz_embed_signals[NET_STATE] =
     gtk_signal_new("net_state",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, net_state),
-		   gtk_marshal_NONE__INT_INT,
+		   gtkmozembed_VOID__INT_UINT,
 		   GTK_TYPE_NONE, 2, GTK_TYPE_INT, GTK_TYPE_UINT);
   moz_embed_signals[NET_STATE_ALL] =
     gtk_signal_new("net_state_all",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, net_state_all),
-		   gtk_marshal_NONE__POINTER_INT_INT,
+		   gtkmozembed_VOID__POINTER_INT_UINT,
 		   GTK_TYPE_NONE, 3, GTK_TYPE_STRING,
 		   GTK_TYPE_INT, GTK_TYPE_UINT);
   moz_embed_signals[NET_START] =
     gtk_signal_new("net_start",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, net_start),
 		   gtk_marshal_NONE__NONE,
 		   GTK_TYPE_NONE, 0);
   moz_embed_signals[NET_STOP] =
     gtk_signal_new("net_stop",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, net_stop),
 		   gtk_marshal_NONE__NONE,
 		   GTK_TYPE_NONE, 0);
   moz_embed_signals[NEW_WINDOW] =
     gtk_signal_new("new_window",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, new_window),
 		   gtk_marshal_NONE__POINTER_UINT,
 		   GTK_TYPE_NONE, 2, GTK_TYPE_POINTER, GTK_TYPE_UINT);
   moz_embed_signals[VISIBILITY] =
     gtk_signal_new("visibility",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, visibility),
 		   gtk_marshal_NONE__BOOL,
 		   GTK_TYPE_NONE, 1, GTK_TYPE_BOOL);
   moz_embed_signals[DESTROY_BROWSER] =
     gtk_signal_new("destroy_browser",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, destroy_brsr),
 		   gtk_marshal_NONE__NONE,
 		   GTK_TYPE_NONE, 0);
   moz_embed_signals[OPEN_URI] = 
     gtk_signal_new("open_uri",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, open_uri),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_STRING);
   moz_embed_signals[SIZE_TO] =
     gtk_signal_new("size_to",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, size_to),
 		   gtk_marshal_NONE__INT_INT,
 		   GTK_TYPE_NONE, 2, GTK_TYPE_INT, GTK_TYPE_INT);
   moz_embed_signals[DOM_KEY_DOWN] =
     gtk_signal_new("dom_key_down",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_key_down),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_KEY_PRESS] =
     gtk_signal_new("dom_key_press",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_key_press),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_KEY_UP] =
     gtk_signal_new("dom_key_up",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_key_up),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_MOUSE_DOWN] =
     gtk_signal_new("dom_mouse_down",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_mouse_down),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_MOUSE_UP] =
     gtk_signal_new("dom_mouse_up",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_mouse_up),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_MOUSE_CLICK] =
     gtk_signal_new("dom_mouse_click",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_mouse_click),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_MOUSE_DBL_CLICK] =
     gtk_signal_new("dom_mouse_dbl_click",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_mouse_dbl_click),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_MOUSE_OVER] =
     gtk_signal_new("dom_mouse_over",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_mouse_over),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[DOM_MOUSE_OUT] =
     gtk_signal_new("dom_mouse_out",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, dom_mouse_out),
 		   gtk_marshal_BOOL__POINTER,
 		   GTK_TYPE_BOOL, 1, GTK_TYPE_POINTER);
   moz_embed_signals[SECURITY_CHANGE] =
     gtk_signal_new("security_change",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, security_change),
 		   gtk_marshal_NONE__POINTER_UINT,
 		   GTK_TYPE_NONE, 2, GTK_TYPE_POINTER, GTK_TYPE_UINT);
   moz_embed_signals[STATUS_CHANGE] =
     gtk_signal_new("status_change",
 		   GTK_RUN_LAST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedClass, status_change),
-		   gtk_marshal_NONE__POINTER_INT_POINTER,
+		   gtkmozembed_VOID__POINTER_INT_POINTER,
 		   GTK_TYPE_NONE, 3,
 		   GTK_TYPE_POINTER, GTK_TYPE_INT, GTK_TYPE_POINTER);
 
+#ifdef MOZ_WIDGET_GTK
   gtk_object_class_add_signals(object_class, moz_embed_signals,
 			       EMBED_LAST_SIGNAL);
+#endif /* MOZ_WIDGET_GTK */
 
 }
 
@@ -443,6 +485,8 @@
   EmbedPrivate *priv = new EmbedPrivate();
   embed->data = priv;
   gtk_widget_set_name(GTK_WIDGET(embed), "gtkmozembed");
+
+  GTK_WIDGET_UNSET_FLAGS(GTK_WIDGET(embed), GTK_NO_WINDOW);
 }
 
 GtkWidget *
@@ -538,6 +582,7 @@
 				 embed,
 				 GTK_OBJECT(child_widget));
 
+#ifdef MOZ_WIDGET_GTK
   // connect to the toplevel focus out events for the child
   GtkMozArea *mozarea = GTK_MOZAREA(child_widget);
   gtk_signal_connect_while_alive(GTK_OBJECT(mozarea),
@@ -551,6 +596,21 @@
 				 GTK_SIGNAL_FUNC(handle_toplevel_focus_out),
 				 embed,
 				 GTK_OBJECT(mozarea));
+#endif /* MOZ_WIDGET_GTK */
+
+#ifdef MOZ_WIDGET_GTK2
+  GtkWidget *toplevel = gtk_widget_get_toplevel(child_widget);
+  gtk_signal_connect_while_alive(GTK_OBJECT(toplevel),
+				 "focus_in_event",
+				 GTK_SIGNAL_FUNC(handle_toplevel_focus_in),
+				 embed,
+				 GTK_OBJECT(child_widget));
+  gtk_signal_connect_while_alive(GTK_OBJECT(toplevel),
+				 "focus_out_event",
+				 GTK_SIGNAL_FUNC(handle_toplevel_focus_out),
+				 embed,
+				 GTK_OBJECT(child_widget));
+#endif /* MOZ_WIDGET_GTK2 */
 }
 
 static void
@@ -663,7 +723,8 @@
   return FALSE;
 }
 
-static void
+#ifdef MOZ_WIDGET_GTK
+void
 handle_toplevel_focus_in (GtkMozArea    *aArea,
 			  GtkMozEmbed   *aEmbed)
 {
@@ -673,7 +734,7 @@
   embedPrivate->TopLevelFocusIn();
 }
 
-static void
+void
 handle_toplevel_focus_out(GtkMozArea    *aArea,
 			  GtkMozEmbed   *aEmbed)
 {
@@ -682,6 +743,31 @@
 
   embedPrivate->TopLevelFocusOut();
 }
+#endif /* MOZ_WIDGET_GTK */
+
+#ifdef MOZ_WIDGET_GTK2
+/* static */
+gint
+handle_toplevel_focus_in(GtkWidget     *aWidget,
+			 GdkEventFocus *aEvent,
+			 EmbedPrivate  *aPrivate)
+{
+  aPrivate->TopLevelFocusIn();
+
+  return FALSE;
+}
+
+/* static */
+gint
+handle_toplevel_focus_out(GtkWidget     *aWidget,
+			  GdkEventFocus *aEvent,
+			  EmbedPrivate  *aPrivate)
+{
+  aPrivate->TopLevelFocusOut();
+
+  return FALSE;
+}
+#endif /* MOZ_WIDGET_GTK2 */
 
 // Widget methods
 
@@ -878,7 +964,7 @@
 
   if (embedPrivate->mWindow) {
     *getter_Copies(embedString) =
-      ToNewCString(embedPrivate->mWindow->mLinkMessage);
+      NEW_TOOLKIT_STRING(embedPrivate->mWindow->mLinkMessage);
     retval = strdup(embedString);
   }
 
@@ -899,7 +985,7 @@
 
   if (embedPrivate->mWindow) {
     *getter_Copies(embedString) =
-      ToNewCString(embedPrivate->mWindow->mJSStatus);
+      NEW_TOOLKIT_STRING(embedPrivate->mWindow->mJSStatus);
     retval = strdup(embedString);
   }
 
@@ -919,7 +1005,8 @@
   embedPrivate = (EmbedPrivate *)embed->data;
 
   if (embedPrivate->mWindow) {
-    *getter_Copies(embedString) = ToNewCString(embedPrivate->mWindow->mTitle);
+    *getter_Copies(embedString) = 
+      NEW_TOOLKIT_STRING(embedPrivate->mWindow->mTitle);
     retval = strdup(embedString);
   }
 
@@ -939,7 +1026,7 @@
   embedPrivate = (EmbedPrivate *)embed->data;
   
   if (embedPrivate->mURI.Length()) {
-    *getter_Copies(embedString) = ToNewCString(embedPrivate->mURI);
+    *getter_Copies(embedString) = NEW_TOOLKIT_STRING(embedPrivate->mURI);
     retval = strdup(embedString);
   }
 
@@ -1011,6 +1098,8 @@
   return embedPrivate->mChromeMask;
 }
 
+#ifdef MOZ_WIDGET_GTK
+
 GtkType
 gtk_moz_embed_progress_flags_get_type(void)
 {
@@ -1059,6 +1148,8 @@
   return chrome_flags_type;
 }
 
+#endif /* MOZ_WIDGET_GTK */
+
 void
 gtk_moz_embed_get_nsIWebBrowser  (GtkMozEmbed *embed, nsIWebBrowser **retval)
 {
@@ -1183,14 +1274,16 @@
   moz_embed_single_signals[NEW_WINDOW_ORPHAN] =
     gtk_signal_new("new_window_orphan",
 		   GTK_RUN_FIRST,
-		   object_class->type,
+		   GET_OBJECT_CLASS_TYPE(klass),
 		   GTK_SIGNAL_OFFSET(GtkMozEmbedSingleClass,
 				     new_window_orphan),
 		   gtk_marshal_NONE__POINTER_UINT,
 		   GTK_TYPE_NONE, 2, GTK_TYPE_POINTER, GTK_TYPE_UINT);
   
+#ifdef MOZ_WIDGET_GTK
   gtk_object_class_add_signals(object_class, moz_embed_single_signals,
 			       SINGLE_LAST_SIGNAL);
+#endif /* MOZ_WIDGET_GTK */
 }
 
 static void
Index: embedding/browser/gtk/src/gtkmozembedmarshal.c
===================================================================
RCS file: embedding/browser/gtk/src/gtkmozembedmarshal.c
diff -N embedding/browser/gtk/src/gtkmozembedmarshal.c
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ embedding/browser/gtk/src/gtkmozembedmarshal.c	16 Nov 2002 01:26:58 -0000
@@ -0,0 +1,203 @@
+
+#include	<glib-object.h>
+
+
+#ifdef G_ENABLE_DEBUG
+#define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
+#define g_marshal_value_peek_char(v)     g_value_get_char (v)
+#define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
+#define g_marshal_value_peek_int(v)      g_value_get_int (v)
+#define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
+#define g_marshal_value_peek_long(v)     g_value_get_long (v)
+#define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
+#define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
+#define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
+#define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
+#define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
+#define g_marshal_value_peek_float(v)    g_value_get_float (v)
+#define g_marshal_value_peek_double(v)   g_value_get_double (v)
+#define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
+#define g_marshal_value_peek_param(v)    g_value_get_param (v)
+#define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
+#define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
+#define g_marshal_value_peek_object(v)   g_value_get_object (v)
+#else /* !G_ENABLE_DEBUG */
+/* WARNING: This code accesses GValues directly, which is UNSUPPORTED API.
+ *          Do not access GValues directly in your code. Instead, use the
+ *          g_value_get_*() functions
+ */
+#define g_marshal_value_peek_boolean(v)  (v)->data[0].v_int
+#define g_marshal_value_peek_char(v)     (v)->data[0].v_int
+#define g_marshal_value_peek_uchar(v)    (v)->data[0].v_uint
+#define g_marshal_value_peek_int(v)      (v)->data[0].v_int
+#define g_marshal_value_peek_uint(v)     (v)->data[0].v_uint
+#define g_marshal_value_peek_long(v)     (v)->data[0].v_long
+#define g_marshal_value_peek_ulong(v)    (v)->data[0].v_ulong
+#define g_marshal_value_peek_int64(v)    (v)->data[0].v_int64
+#define g_marshal_value_peek_uint64(v)   (v)->data[0].v_uint64
+#define g_marshal_value_peek_enum(v)     (v)->data[0].v_int
+#define g_marshal_value_peek_flags(v)    (v)->data[0].v_uint
+#define g_marshal_value_peek_float(v)    (v)->data[0].v_float
+#define g_marshal_value_peek_double(v)   (v)->data[0].v_double
+#define g_marshal_value_peek_string(v)   (v)->data[0].v_pointer
+#define g_marshal_value_peek_param(v)    (v)->data[0].v_pointer
+#define g_marshal_value_peek_boxed(v)    (v)->data[0].v_pointer
+#define g_marshal_value_peek_pointer(v)  (v)->data[0].v_pointer
+#define g_marshal_value_peek_object(v)   (v)->data[0].v_pointer
+#endif /* !G_ENABLE_DEBUG */
+
+
+/* NONE:POINTER,INT,INT (/dev/stdin:1) */
+void
+gtkmozembed_VOID__POINTER_INT_INT (GClosure     *closure,
+                                   GValue       *return_value,
+                                   guint         n_param_values,
+                                   const GValue *param_values,
+                                   gpointer      invocation_hint,
+                                   gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__POINTER_INT_INT) (gpointer     data1,
+                                                      gpointer     arg_1,
+                                                      gint         arg_2,
+                                                      gint         arg_3,
+                                                      gpointer     data2);
+  register GMarshalFunc_VOID__POINTER_INT_INT callback;
+  register GCClosure *cc = (GCClosure*) closure;
+  register gpointer data1, data2;
+
+  g_return_if_fail (n_param_values == 4);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__POINTER_INT_INT) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_pointer (param_values + 1),
+            g_marshal_value_peek_int (param_values + 2),
+            g_marshal_value_peek_int (param_values + 3),
+            data2);
+}
+
+/* NONE:INT,UINT (/dev/stdin:2) */
+void
+gtkmozembed_VOID__INT_UINT (GClosure     *closure,
+                            GValue       *return_value,
+                            guint         n_param_values,
+                            const GValue *param_values,
+                            gpointer      invocation_hint,
+                            gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__INT_UINT) (gpointer     data1,
+                                               gint         arg_1,
+                                               guint        arg_2,
+                                               gpointer     data2);
+  register GMarshalFunc_VOID__INT_UINT callback;
+  register GCClosure *cc = (GCClosure*) closure;
+  register gpointer data1, data2;
+
+  g_return_if_fail (n_param_values == 3);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__INT_UINT) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_int (param_values + 1),
+            g_marshal_value_peek_uint (param_values + 2),
+            data2);
+}
+
+/* NONE:POINTER,INT,UINT (/dev/stdin:3) */
+void
+gtkmozembed_VOID__POINTER_INT_UINT (GClosure     *closure,
+                                    GValue       *return_value,
+                                    guint         n_param_values,
+                                    const GValue *param_values,
+                                    gpointer      invocation_hint,
+                                    gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__POINTER_INT_UINT) (gpointer     data1,
+                                                       gpointer     arg_1,
+                                                       gint         arg_2,
+                                                       guint        arg_3,
+                                                       gpointer     data2);
+  register GMarshalFunc_VOID__POINTER_INT_UINT callback;
+  register GCClosure *cc = (GCClosure*) closure;
+  register gpointer data1, data2;
+
+  g_return_if_fail (n_param_values == 4);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__POINTER_INT_UINT) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_pointer (param_values + 1),
+            g_marshal_value_peek_int (param_values + 2),
+            g_marshal_value_peek_uint (param_values + 3),
+            data2);
+}
+
+/* NONE:POINTER,INT,POINTER (/dev/stdin:4) */
+void
+gtkmozembed_VOID__POINTER_INT_POINTER (GClosure     *closure,
+                                       GValue       *return_value,
+                                       guint         n_param_values,
+                                       const GValue *param_values,
+                                       gpointer      invocation_hint,
+                                       gpointer      marshal_data)
+{
+  typedef void (*GMarshalFunc_VOID__POINTER_INT_POINTER) (gpointer     data1,
+                                                          gpointer     arg_1,
+                                                          gint         arg_2,
+                                                          gpointer     arg_3,
+                                                          gpointer     data2);
+  register GMarshalFunc_VOID__POINTER_INT_POINTER callback;
+  register GCClosure *cc = (GCClosure*) closure;
+  register gpointer data1, data2;
+
+  g_return_if_fail (n_param_values == 4);
+
+  if (G_CCLOSURE_SWAP_DATA (closure))
+    {
+      data1 = closure->data;
+      data2 = g_value_peek_pointer (param_values + 0);
+    }
+  else
+    {
+      data1 = g_value_peek_pointer (param_values + 0);
+      data2 = closure->data;
+    }
+  callback = (GMarshalFunc_VOID__POINTER_INT_POINTER) (marshal_data ? marshal_data : cc->callback);
+
+  callback (data1,
+            g_marshal_value_peek_pointer (param_values + 1),
+            g_marshal_value_peek_int (param_values + 2),
+            g_marshal_value_peek_pointer (param_values + 3),
+            data2);
+}
+
Index: embedding/browser/gtk/src/gtkmozembedmarshal.h
===================================================================
RCS file: embedding/browser/gtk/src/gtkmozembedmarshal.h
diff -N embedding/browser/gtk/src/gtkmozembedmarshal.h
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ embedding/browser/gtk/src/gtkmozembedmarshal.h	16 Nov 2002 01:26:58 -0000
@@ -0,0 +1,48 @@
+
+#ifndef __gtkmozembed_MARSHAL_H__
+#define __gtkmozembed_MARSHAL_H__
+
+#include	<glib-object.h>
+
+G_BEGIN_DECLS
+
+/* NONE:POINTER,INT,INT (/dev/stdin:1) */
+extern void gtkmozembed_VOID__POINTER_INT_INT (GClosure     *closure,
+                                               GValue       *return_value,
+                                               guint         n_param_values,
+                                               const GValue *param_values,
+                                               gpointer      invocation_hint,
+                                               gpointer      marshal_data);
+#define gtkmozembed_NONE__POINTER_INT_INT	gtkmozembed_VOID__POINTER_INT_INT
+
+/* NONE:INT,UINT (/dev/stdin:2) */
+extern void gtkmozembed_VOID__INT_UINT (GClosure     *closure,
+                                        GValue       *return_value,
+                                        guint         n_param_values,
+                                        const GValue *param_values,
+                                        gpointer      invocation_hint,
+                                        gpointer      marshal_data);
+#define gtkmozembed_NONE__INT_UINT	gtkmozembed_VOID__INT_UINT
+
+/* NONE:POINTER,INT,UINT (/dev/stdin:3) */
+extern void gtkmozembed_VOID__POINTER_INT_UINT (GClosure     *closure,
+                                                GValue       *return_value,
+                                                guint         n_param_values,
+                                                const GValue *param_values,
+                                                gpointer      invocation_hint,
+                                                gpointer      marshal_data);
+#define gtkmozembed_NONE__POINTER_INT_UINT	gtkmozembed_VOID__POINTER_INT_UINT
+
+/* NONE:POINTER,INT,POINTER (/dev/stdin:4) */
+extern void gtkmozembed_VOID__POINTER_INT_POINTER (GClosure     *closure,
+                                                   GValue       *return_value,
+                                                   guint         n_param_values,
+                                                   const GValue *param_values,
+                                                   gpointer      invocation_hint,
+                                                   gpointer      marshal_data);
+#define gtkmozembed_NONE__POINTER_INT_POINTER	gtkmozembed_VOID__POINTER_INT_POINTER
+
+G_END_DECLS
+
+#endif /* __gtkmozembed_MARSHAL_H__ */
+
Index: embedding/browser/gtk/src/types.txt
===================================================================
RCS file: embedding/browser/gtk/src/types.txt
diff -N embedding/browser/gtk/src/types.txt
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ embedding/browser/gtk/src/types.txt	16 Nov 2002 01:26:58 -0000
@@ -0,0 +1,4 @@
+NONE:POINTER,INT,INT
+NONE:INT,UINT
+NONE:POINTER,INT,UINT
+NONE:POINTER,INT,POINTER
Index: embedding/browser/gtk/tests/Makefile.in
===================================================================
RCS file: /cvsroot/mozilla/embedding/browser/gtk/tests/Makefile.in,v
retrieving revision 1.22
diff -u -r1.22 Makefile.in
--- embedding/browser/gtk/tests/Makefile.in	24 Sep 2002 01:56:35 -0000	1.22
+++ embedding/browser/gtk/tests/Makefile.in	16 Nov 2002 01:26:58 -0000
@@ -45,10 +45,17 @@
 CPPSRCS	       += TestGtkEmbedMDI.cpp
 endif
 
+ifdef MOZ_ENABLE_GTK
 LIBS		+= \
 		-lgtkembedmoz \
 		-lgtksuperwin \
 		$(NULL)
+endif
+
+ifdef MOZ_ENABLE_GTK2
+LIBS		+= \
+		-lgtkembedmoz
+endif
 
 include $(topsrcdir)/config/config.mk
 
@@ -72,7 +79,7 @@
 
 include $(topsrcdir)/config/rules.mk
 
-CXXFLAGS	+= $(MOZ_GTK_CFLAGS)
+CXXFLAGS	+= $(MOZ_GTK_CFLAGS) $(MOZ_GTK2_CFLAGS)
 
 ifdef ENABLE_GNOME
 CXXFLAGS	+= `gnome-config --cflags gnomeui`
Index: embedding/browser/gtk/tests/TestGtkEmbed.cpp
===================================================================
RCS file: /cvsroot/mozilla/embedding/browser/gtk/tests/TestGtkEmbed.cpp,v
retrieving revision 1.32
diff -u -r1.32 TestGtkEmbed.cpp
--- embedding/browser/gtk/tests/TestGtkEmbed.cpp	24 Sep 2002 01:56:34 -0000	1.32
+++ embedding/browser/gtk/tests/TestGtkEmbed.cpp	16 Nov 2002 01:26:58 -0000
@@ -304,8 +304,19 @@
 		     FALSE, // fill
 		     0);    // padding
   // new horiz toolbar with buttons + icons
+#ifdef MOZ_WIDGET_GTK
   browser->toolbar = gtk_toolbar_new(GTK_ORIENTATION_HORIZONTAL,
 				     GTK_TOOLBAR_BOTH);
+#endif /* MOZ_WIDGET_GTK */
+
+#ifdef MOZ_WIDGET_GTK2
+  browser->toolbar = gtk_toolbar_new();
+  gtk_toolbar_set_orientation(GTK_TOOLBAR(browser->toolbar),
+			      GTK_ORIENTATION_HORIZONTAL);
+  gtk_toolbar_set_style(GTK_TOOLBAR(browser->toolbar),
+			GTK_TOOLBAR_BOTH);
+#endif /* MOZ_WIDGET_GTK2 */
+
   // add it to the hbox
   gtk_box_pack_start(GTK_BOX(browser->toolbarHBox), browser->toolbar,
 		   FALSE, // expand
