BUG(148): Fix ices effect plugin

---
commit b43f876bcf4bfb9ecd7545936311cd52c6164d82
tree e20e9697735b38de0fde17590710731f74786bef
parent 3e871cb917819caf0b732868ee59db619983b694
author Daniel Chokola <dan@chokola.com> Fri, 24 Mar 2006 12:23:47 -0500
committer Daniel Chokola <dan@chokola.com> Fri, 24 Mar 2006 12:23:47 -0500

 src/plugins/ices/Plugin   |   10 +
 src/plugins/ices/buffer.c |  197 +++++++++++++++++++++++++++
 src/plugins/ices/buffer.h |   51 +++++++
 src/plugins/ices/encode.c |   10 +
 src/plugins/ices/ices.c   |  333 ++++++++++++++++++++++++++++++---------------
 5 files changed, 480 insertions(+), 121 deletions(-)

diff --git a/src/plugins/ices/Plugin b/src/plugins/ices/Plugin
index d45c501..b0efe9b 100644
--- a/src/plugins/ices/Plugin
+++ b/src/plugins/ices/Plugin
@@ -1,5 +1,11 @@
 target="ices"
-source=["ices.c", "encode.c"]
+source=["ices.c", "encode.c", "buffer.c"]
 
 def config(env):
-	raise ConfigError("Plugin disabled")
+	env.checkheader("vorbis/codec.h")
+	env.checkheader("shout/shout.h")
+	env.checkheader("ogg/ogg.h")
+	env.checklib("vorbis", "vorbis_info_init")
+	env.checklib("vorbisenc", "vorbis_encode_init")
+	env.checklib("shout", "shout_init")
+	env.checklib("ogg", "ogg_stream_init")
diff --git a/src/plugins/ices/buffer.c b/src/plugins/ices/buffer.c
new file mode 100644
index 0000000..51c0661
--- /dev/null
+++ b/src/plugins/ices/buffer.c
@@ -0,0 +1,197 @@
+/* buffer.c
+ *
+ * Simple ringbuffer.
+ * Copyright (c) 2006 Daniel Chokola
+ */
+
+#include <stdlib.h>
+#include <glib.h>
+#include <string.h>
+
+#include "buffer.h"
+
+ringbuf_t *ringbuf_new(gulong size) {
+	ringbuf_t *buf;
+
+	g_return_val_if_fail(size, NULL);
+
+	buf = g_new0(ringbuf_t, 1);
+
+	buf->mutex = g_mutex_new();
+	buf->wait_mutex = g_mutex_new();
+
+	buf->begin = g_malloc(size);
+	buf->end = buf->begin + size;
+	buf->write_loc = buf->begin;
+	buf->read_loc = buf->begin;
+	buf->full_loc = NULL;
+
+	buf->overrun = FALSE;
+
+	return buf;
+}
+
+gboolean ringbuf_read(ringbuf_t *buf, gchar *data, gulong size) {
+	gpointer full_loc;
+	gulong i;
+
+	g_return_val_if_fail(buf, FALSE);
+	g_return_val_if_fail(size, FALSE);
+
+	g_mutex_lock(buf->mutex);
+
+	/* Check for possible underruns before we start copying. */
+	if(buf->end - buf->read_loc >= size) {
+		full_loc = buf->read_loc + size;
+
+		if(buf->read_loc < buf->write_loc && full_loc >= buf->write_loc) {
+			g_mutex_unlock(buf->mutex);
+			return FALSE;
+		}
+	} else {
+		full_loc = buf->begin + (size - (buf->end - buf->read_loc));
+
+		if((buf->read_loc < buf->write_loc && buf->end >= buf->write_loc) ||
+			(buf->begin <= buf->write_loc && full_loc >= buf->write_loc)) {
+			g_mutex_unlock(buf->mutex);
+			return FALSE;
+		}
+	}
+
+	if(buf->overrun) {
+		buf->overrun = FALSE;
+	}
+
+	for(i = 0; i < size; i++) {
+		data[i] = *(gchar*)buf->read_loc;
+
+		if(buf->read_loc == buf->end) {
+			buf->read_loc = buf->begin;
+		} else {
+			buf->read_loc++;
+		}
+	}
+
+	g_mutex_unlock(buf->mutex);
+
+	return TRUE;
+}
+
+gboolean ringbuf_write(ringbuf_t *buf, gconstpointer data, gulong size) {
+	gpointer full_loc;
+	gulong i;
+
+	g_return_val_if_fail(buf, FALSE);
+	g_return_val_if_fail(size, FALSE);
+
+	g_mutex_lock(buf->mutex);
+
+	if(buf->overrun) {
+		g_mutex_unlock(buf->mutex);
+		return FALSE;
+	}
+
+	/* Check for possible overruns before we start copying. */
+	if(buf->end - buf->write_loc >= size) {
+		full_loc = buf->write_loc + size;
+
+		if(buf->write_loc < buf->read_loc && full_loc >= buf->read_loc) {
+			buf->overrun = TRUE;
+			g_mutex_unlock(buf->mutex);
+			g_mutex_unlock(buf->wait_mutex);
+			return FALSE;
+		}
+	} else {
+		full_loc = buf->begin + (size - (buf->end - buf->write_loc));
+
+		if((buf->write_loc < buf->read_loc && buf->end >= buf->read_loc) ||
+			(buf->begin <= buf->read_loc && full_loc >= buf->read_loc)) {
+			buf->overrun = TRUE;
+			g_mutex_unlock(buf->mutex);
+			g_mutex_unlock(buf->wait_mutex);
+			return FALSE;
+		}
+	}
+
+	for(i = 0; i < size; i++) {
+		g_memmove(buf->write_loc, data, 1);
+
+		if(buf->write_loc + 1 == buf->full_loc) {
+			g_mutex_unlock(buf->wait_mutex);
+		}
+
+		if(buf->write_loc == buf->end) {
+			buf->write_loc = buf->begin;
+		} else {
+			buf->write_loc++;
+		}
+
+		data++;
+	}
+
+	g_mutex_unlock(buf->mutex);
+
+	return TRUE;
+}
+
+void ringbuf_wait_fill(ringbuf_t *buf, gulong size) {
+	gpointer last_loc;
+
+	g_return_if_fail(buf);
+	g_return_if_fail(size);
+
+	last_loc = buf->write_loc;
+
+	g_mutex_lock(buf->wait_mutex);
+
+	if(buf->end - last_loc >= size) {
+		buf->full_loc = last_loc + size;
+	} else {
+		buf->full_loc = buf->begin + (size - (buf->end - last_loc));
+	}
+
+	g_mutex_lock(buf->wait_mutex);
+	buf->full_loc = NULL;
+	g_mutex_unlock(buf->wait_mutex);
+}
+
+gulong ringbuf_filled_size(ringbuf_t *buf) {
+	gulong size;
+
+	g_return_val_if_fail(buf, 0);
+
+	g_mutex_lock(buf->mutex);
+
+	if(buf->read_loc <= buf->write_loc) {
+		size = (gulong)(buf->write_loc - buf->read_loc);
+	} else {
+		size = (gulong)((buf->write_loc - buf->begin) +
+		       (buf->end - buf->read_loc));
+	}
+
+	g_mutex_unlock(buf->mutex);
+
+	return size;
+}
+
+void ringbuf_cancel_wait(ringbuf_t *buf) {
+	g_return_if_fail(buf);
+
+	g_mutex_unlock(buf->wait_mutex);
+}
+
+void ringbuf_destroy(ringbuf_t *buf) {
+	g_return_if_fail(buf);
+
+	g_mutex_lock(buf->mutex);
+	g_mutex_unlock(buf->mutex);
+	g_mutex_free(buf->mutex);
+
+	g_mutex_lock(buf->wait_mutex);
+	g_mutex_unlock(buf->wait_mutex);
+	g_mutex_free(buf->wait_mutex);
+
+	g_free(buf->begin);
+
+	g_free(buf);
+}
diff --git a/src/plugins/ices/buffer.h b/src/plugins/ices/buffer.h
new file mode 100644
index 0000000..cbdb461
--- /dev/null
+++ b/src/plugins/ices/buffer.h
@@ -0,0 +1,51 @@
+/* buffer.h
+ * Simple ringbuffer functions.
+ * Copyright (c) 2006 Daniel Chokola
+ */
+
+#ifndef __BUFFER_H
+#define __BUFFER_H
+
+#include <glib.h>
+
+typedef struct {
+	GMutex *mutex;
+	GMutex *wait_mutex;
+	gpointer write_loc;
+	gpointer read_loc;
+	gpointer begin;
+	gpointer end;
+	gpointer full_loc;
+	gboolean overrun;
+} ringbuf_t;
+
+/* Allocates a new ringbuffer of size _size_. */
+ringbuf_t *ringbuf_new(gulong size);
+
+/* Reads a chunk from the ringbuffer of size _size_ and copies it into _data_.
+ * Returns TRUE if the full copy was successful, otherwise FALSE and _data_ is
+ * unmodified. FALSE is returned if _size_ exceeds the amount of data in the
+ * ringbuffer. */
+gboolean ringbuf_read(ringbuf_t *buf, gchar *data, gulong size);
+
+/* Copies the contents of _data_ into the ringbuffer. Returns TRUE if the full
+ * copy was successful, otherwise FALSE and no data is written to the
+ * ringbuffer. Returns FALSE if _size_ exceeds the amount of free space in the
+ * buffer. */
+gboolean ringbuf_write(ringbuf_t *buf, gconstpointer data, gulong size);
+
+/* Returns after additional data of length _size_ is written to the ringbuffer.
+ * This function may also return if the next call to ringbuf_write() fails due
+ * to its _size_ exceeding the free space in the buffer. */
+void ringbuf_wait_fill(ringbuf_t *buf, gulong size);
+
+/* Returns the number of bytes of the ringbuf containing unread data. */
+gulong ringbuf_filled_size(ringbuf_t *buf);
+
+/* Causes any ringbuf_wait_fill() calls to return. */
+void ringbuf_cancel_wait(ringbuf_t *buf);
+
+/* Frees all resources associated with the ringbuffer. */
+void ringbuf_destroy(ringbuf_t *buf);
+
+#endif /* __BUFFER_H */
diff --git a/src/plugins/ices/encode.c b/src/plugins/ices/encode.c
index 2b202be..e3cd217 100644
--- a/src/plugins/ices/encode.c
+++ b/src/plugins/ices/encode.c
@@ -1,13 +1,13 @@
 /*  XMMS2 - X Music Multiplexer System
- *  Copyright (C) 2003-2006 Peter Alm, Tobias Rundström, Anders Gustafsson
- * 
+ *  Copyright (C) 2003-2006 XMMS2 Team
+ *
  *  PLUGINS ARE NOT CONSIDERED TO BE DERIVED WORK !!!
- * 
+ *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Lesser General Public
  *  License as published by the Free Software Foundation; either
  *  version 2.1 of the License, or (at your option) any later version.
- *                   
+ *
  *  This library is distributed in the hope that it will be useful,
  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@@ -43,7 +43,7 @@
 #include <vorbis/vorbisenc.h>
 
 #include "encode.h"
-#include "xmms/util.h"
+#include "xmms/xmms_log.h"
 
 #define MODULE "encode/"
 
diff --git a/src/plugins/ices/ices.c b/src/plugins/ices/ices.c
index 128a17a..3a77fbb 100644
--- a/src/plugins/ices/ices.c
+++ b/src/plugins/ices/ices.c
@@ -1,5 +1,5 @@
 /*  XMMS2 - X Music Multiplexer System
- *  Copyright (C) 2003-2006 Peter Alm, Tobias Rundström, Anders Gustafsson
+ *  Copyright (C) 2003-2006 XMMS2 Team
  *
  *  PLUGINS ARE NOT CONSIDERED TO BE DERIVED WORK !!!
  *
@@ -14,70 +14,74 @@
  *  Lesser General Public License for more details.
  */
 
-
-
-
 /**
  * @file
  * ICES2 based effect
  */
 
-#include "xmms/xmms.h"
-#include "xmms/plugin.h"
-#include "xmms/effect.h"
-#include "xmms/util.h"
-#include "xmms/config.h"
-#include "xmms/object.h"
-#include "xmms/ringbuf.h"
-#include "xmms/playlist.h"
-#include "xmms/medialib.h"
-#include "xmms/signal_xmms.h"
-#include "internal/output_int.h"
+#include "xmms/xmms_effectplugin.h"
+#include "xmms/xmms_defs.h"
+#include "xmms/xmms_log.h"
 
 #include <math.h>
 #include <glib.h>
 #include <stdlib.h>
-
-#include <shout/shout.h>
+#include <string.h>
 
 #include <ogg/ogg.h>
+#include <shout/shout.h>
 #include <vorbis/codec.h>
 
 #include "encode.h"
+#include "buffer.h"
+
+#define DECODE_CHUNK 4096
 
 typedef struct xmms_ices_data_St {
 	shout_t *shout;
-	xmms_medialib_entry *entry;
 	vorbis_comment vc;
 	encoder_state *enc;
 	gint serial;
 
-	xmms_ringbuf_t *buf;
-	gint buf_size;
+	ringbuf_t *buf;
+	gulong buf_size;
+
+	guint sample_size;
+	guint sample_rate;
+	guint channels;
 	gboolean write_buf;
 	GThread *thread;
+	gboolean connected;
+	gboolean end_thread;
 } xmms_ices_data_t;
 
-static void xmms_ices_new (xmms_effect_t *effect, xmms_output_t *output);
+static void xmms_ices_new (xmms_effect_t *effect);
 static void xmms_ices_destroy (xmms_effect_t *effect);
-static void xmms_ices_samplerate_set (xmms_effect_t *effect, guint rate);
-static void xmms_ices_process (xmms_effect_t *effect, gchar *buf, guint len);
-static void on_playlist_entry_changed (xmms_output_t *output,
-                                       const xmms_object_cmd_arg_t *arg,
-                                       xmms_ices_data_t *data);
+static void xmms_ices_thread (xmms_effect_t *effect);
+static void xmms_ices_thread_destroy (xmms_ices_data_t *data);
+static gboolean xmms_ices_reconnect (xmms_ices_data_t *data);
+static gboolean xmms_ices_format_set (xmms_effect_t *effect,
+                                      xmms_audio_format_t *fmt);
+static void xmms_ices_process (xmms_effect_t *effect, xmms_sample_t *buf,
+                               guint len);
+static void xmms_ices_entry_changed (xmms_effect_t *effect,
+                                     xmms_medialib_entry_t entry);
+static void xmms_ices_configval_changed (xmms_object_t *obj,
+                                         gconstpointer value, gpointer udata);
 
 xmms_plugin_t *
 xmms_plugin_get (void)
 {
 	xmms_plugin_t *plugin;
 
-	plugin = xmms_plugin_new (XMMS_PLUGIN_TYPE_EFFECT, "ices",
-	                          "Icecast2 Shoutplugin " XMMS_VERSION,
-	                          "Icecast2 Shoutplugin");
+	plugin = xmms_plugin_new (XMMS_PLUGIN_TYPE_EFFECT,
+	                          XMMS_EFFECT_PLUGIN_API_VERSION,
+	                          "ices",
+	                          "Shoutcast Effect",
+	                          XMMS_VERSION,
+	                          "Shoutcast source effect plugin");
 
-	if (!plugin) {
-		return NULL;
-	}
+	g_return_val_if_fail (plugin, NULL);
 
 	xmms_plugin_info_add (plugin, "URL", "http://www.xmms.org/");
 	xmms_plugin_info_add (plugin, "INFO", "http://www.icecast.org/");
@@ -85,11 +89,16 @@ xmms_plugin_get (void)
 	xmms_plugin_info_add (plugin, "License", "GPL");
 
 	xmms_plugin_method_add (plugin, XMMS_PLUGIN_METHOD_NEW, xmms_ices_new);
-	xmms_plugin_method_add (plugin, XMMS_PLUGIN_METHOD_DESTROY, xmms_ices_destroy);
-	xmms_plugin_method_add (plugin, XMMS_PLUGIN_METHOD_SAMPLERATE_SET, xmms_ices_samplerate_set);
-	xmms_plugin_method_add (plugin, XMMS_PLUGIN_METHOD_PROCESS, xmms_ices_process);
+	xmms_plugin_method_add (plugin, XMMS_PLUGIN_METHOD_DESTROY,
+	                        xmms_ices_destroy);
+	xmms_plugin_method_add (plugin, XMMS_PLUGIN_METHOD_FORMAT_SET,
+	                        xmms_ices_format_set);
+	xmms_plugin_method_add (plugin, XMMS_PLUGIN_METHOD_PROCESS,
+	                        xmms_ices_process);
+	xmms_plugin_method_add (plugin, XMMS_PLUGIN_METHOD_CURRENT_MEDIALIB_ENTRY,
+	                        xmms_ices_entry_changed);
 
-	xmms_plugin_config_property_register (plugin, "encodingnombr", "64000",
+	xmms_plugin_config_property_register (plugin, "encodingnombr", "128000",
 	                                      NULL, NULL);
 	xmms_plugin_config_property_register (plugin, "host", "localhost",
 	                                      NULL, NULL);
@@ -106,7 +115,8 @@ xmms_plugin_get (void)
 	xmms_plugin_config_property_register (plugin, "streamgenre", "",
 	                                      NULL, NULL);
 	xmms_plugin_config_property_register (plugin, "streamurl", "", NULL, NULL);
-	xmms_plugin_config_property_register (plugin, "buffersize", "65536",
+	/* Ices NEEDS a large ringbuffer size! Large samples can cause overruns. */
+	xmms_plugin_config_property_register (plugin, "buffersize", "655360",
 	                                      NULL, NULL);
 
 	return plugin;
@@ -115,89 +125,102 @@ xmms_plugin_get (void)
 static gboolean
 xmms_ices_reconnect (xmms_ices_data_t *data)
 {
+	if (shout_get_connected (data->shout) == SHOUTERR_CONNECTED) {
+		shout_close (data->shout);
+	}
+
 	if (shout_open (data->shout) == SHOUTERR_SUCCESS) {
-		XMMS_DBG ("Connected to %s:%d/%s",
+		XMMS_DBG ("Connected to %s:%d%s",
 		          shout_get_host (data->shout),
 		          shout_get_port (data->shout),
 		          shout_get_mount (data->shout));
+		data->connected = TRUE;
+	} else if (!data->connected) {
+		data->end_thread = TRUE;
+		return FALSE;
 	} else {
 		xmms_log_error ("Couldn't connect to shoutserver");
+		data->connected = FALSE;
 		return FALSE;
 	}
 
 	return TRUE;
 }
 
-static gpointer
+static void
 xmms_ices_thread (xmms_effect_t *effect)
 {
 	xmms_ices_data_t *data;
-	GMutex *mutex;
 
-	g_return_val_if_fail (effect, NULL);
+	g_return_if_fail (effect);
 	data = xmms_effect_private_data_get (effect);
-	g_return_val_if_fail (data, NULL);
-
-	mutex = g_mutex_new ();
+	g_return_if_fail (data);
 
 	data->write_buf = TRUE;
 
-	xmms_ringbuf_wait_used (data->buf, data->buf_size - 4096, mutex);
-
-	XMMS_DBG ("Buffering done, starting to encode");
+	/* Be careful adjusting the fill value! */
+	ringbuf_wait_fill (data->buf, DECODE_CHUNK);
 
 	if (!xmms_ices_reconnect (data)) {
-		data->write_buf = FALSE;
-		return NULL;
+		xmms_ices_thread_destroy (data);
 	}
 
 	while (42) {
-		gchar buf[4096];
+		gchar buf[DECODE_CHUNK];
 		ogg_page og;
-		gint ret;
 
-		ret = xmms_ringbuf_read (data->buf, buf, sizeof (buf));
-		if (!ret) {
-			xmms_ringbuf_wait_used (data->buf,
-			                        data->buf_size - sizeof (buf),
-			                        mutex);
+		if (data->end_thread) {
+			xmms_ices_thread_destroy (data);
+		}
+
+		if (!ringbuf_read (data->buf, buf, DECODE_CHUNK)) {
+			ringbuf_wait_fill (data->buf, DECODE_CHUNK);
 			continue;
 		}
 
 		if (!data->enc) {
-			data->write_buf = FALSE;
-			data->thread = NULL;
-			return NULL;
+			xmms_ices_thread_destroy (data);
 		}
 
-		encode_data (data->enc, buf, ret, 0);
+		encode_data (data->enc, buf, DECODE_CHUNK,
+		             G_BYTE_ORDER == G_LITTLE_ENDIAN ? 0 : 1);
 
 		while (encode_dataout (data->enc, &og) > 0) {
 			if (shout_send_raw (data->shout, og.header, og.header_len) < 0) {
 				if (!xmms_ices_reconnect (data)) {
-					data->write_buf = FALSE;
-					return NULL;
+					xmms_ices_thread_destroy (data);
 				}
 			} else if (shout_send_raw (data->shout, og.body, og.body_len) < 0) {
 				if (!xmms_ices_reconnect (data)) {
-					data->write_buf = FALSE;
-					return NULL;
+					xmms_ices_thread_destroy (data);
 				}
 			}
 		}
-
 	}
 
-	return NULL;
+	xmms_ices_thread_destroy (data);
+}
+
+static void
+xmms_ices_thread_destroy (xmms_ices_data_t *data)
+{
+	XMMS_DBG ("Destroying encoder thread.");
+
+	data->write_buf = FALSE;
+
+	ringbuf_destroy (data->buf);
+	data->buf = NULL;
+	encode_clear (data->enc);
+
+	g_thread_exit (NULL);
 }
 
 static void
-xmms_ices_new (xmms_effect_t *effect, xmms_output_t *output)
+xmms_ices_new (xmms_effect_t *effect)
 {
 	xmms_ices_data_t *data;
 	xmms_plugin_t *plugin = xmms_effect_plugin_get (effect);
 	xmms_config_property_t *val;
-	xmms_error_t error;
 
 	shout_init ();
 
@@ -209,55 +232,65 @@ xmms_ices_new (xmms_effect_t *effect, xm
 
 	val = xmms_plugin_config_lookup (plugin, "host");
 	shout_set_host (data->shout, xmms_config_property_get_string (val));
+	xmms_config_property_callback_set (val, xmms_ices_configval_changed,
+	                                   (gpointer) effect);
 
 	val = xmms_plugin_config_lookup (plugin, "port");
 	shout_set_port (data->shout, xmms_config_property_get_int (val));
+	xmms_config_property_callback_set (val, xmms_ices_configval_changed,
+	                                   (gpointer) effect);
 
 	val = xmms_plugin_config_lookup (plugin, "password");
 	shout_set_password (data->shout, xmms_config_property_get_string (val));
+	xmms_config_property_callback_set (val, xmms_ices_configval_changed,
+	                                   (gpointer) effect);
 
 	val = xmms_plugin_config_lookup (plugin, "user");
 	shout_set_user (data->shout, xmms_config_property_get_string (val));
+	xmms_config_property_callback_set (val, xmms_ices_configval_changed,
+	                                   (gpointer) effect);
 
-	shout_set_agent (data->shout, "XMMS/" XMMS_VERSION);
+	shout_set_agent (data->shout, "XMMS2/" XMMS_VERSION);
 
 	val = xmms_plugin_config_lookup (plugin, "mount");
 	shout_set_mount (data->shout, xmms_config_property_get_string (val));
+	xmms_config_property_callback_set (val, xmms_ices_configval_changed,
+	                                   (gpointer) effect);
 
 	val = xmms_plugin_config_lookup (plugin, "public");
 	shout_set_public (data->shout, xmms_config_property_get_int (val));
+	xmms_config_property_callback_set (val, xmms_ices_configval_changed,
+	                                   (gpointer) effect);
 
 	val = xmms_plugin_config_lookup (plugin, "streamname");
 	shout_set_name (data->shout, xmms_config_property_get_string (val));
+	xmms_config_property_callback_set (val, xmms_ices_configval_changed,
+	                                   (gpointer) effect);
 
 	val = xmms_plugin_config_lookup (plugin, "streamdescription");
 	shout_set_description (data->shout, xmms_config_property_get_string (val));
+	xmms_config_property_callback_set (val, xmms_ices_configval_changed,
+	                                   (gpointer) effect);
 
 	val = xmms_plugin_config_lookup (plugin, "streamgenre");
 	shout_set_genre (data->shout, xmms_config_property_get_string (val));
+	xmms_config_property_callback_set (val, xmms_ices_configval_changed,
+	                                   (gpointer) effect);
 
 	val = xmms_plugin_config_lookup (plugin, "streamurl");
 	shout_set_url (data->shout, xmms_config_property_get_string (val));
+	xmms_config_property_callback_set (val, xmms_ices_configval_changed,
+	                                   (gpointer) effect);
 
 	data->write_buf = FALSE;
 	val = xmms_plugin_config_lookup (plugin, "buffersize");
-	data->buf_size = xmms_config_property_get_int (val);
-	data->buf = xmms_ringbuf_new (data->buf_size);
+	xmms_config_property_callback_set (val, xmms_ices_configval_changed,
+	                                   (gpointer) effect);
+	data->buf_size = (gulong) xmms_config_property_get_int (val);
 
 	data->serial = 1;
 
-	xmms_error_reset (&error);
-	data->entry = xmms_output_playing_entry_get (output, &error);
-
-	xmms_object_connect (XMMS_OBJECT (output),
-	                     XMMS_IPC_SIGNAL_OUTPUT_CURRENTID,
-	                     (xmms_object_handler_t ) on_playlist_entry_changed,
-	                     data);
-
 	xmms_effect_private_data_set (effect, data);
-
-	data->thread = g_thread_create ((GThreadFunc) xmms_ices_thread,
-	                                (gpointer) effect, TRUE, NULL);
 }
 
 static void
@@ -270,19 +303,63 @@ xmms_ices_destroy (xmms_effect_t *effect
 	data = xmms_effect_private_data_get (effect);
 	g_return_if_fail (data);
 
-	if (data->entry) {
-		xmms_object_unref (data->entry);
-	}
+	data->end_thread = TRUE;
+
+	if (data->buf)
+		ringbuf_cancel_wait (data->buf);
 
-	shout_close (data->shout);
+	if (data->connected)
+		shout_close (data->shout);
 	shout_free (data->shout);
 	shout_shutdown ();
 }
 
+static gboolean
+xmms_ices_format_set (xmms_effect_t *effect, xmms_audio_format_t *fmt)
+{
+	xmms_ices_data_t *data;
+
+	g_return_val_if_fail (effect, FALSE);
+
+	data = xmms_effect_private_data_get (effect);
+	g_return_val_if_fail (data, FALSE);
+
+	data->sample_size = xmms_sample_size_get (fmt->format);
+	data->sample_rate = fmt->samplerate;
+	data->channels = fmt->channels;
+
+	return TRUE;
+}
+
+static void
+xmms_ices_process (xmms_effect_t *effect, xmms_sample_t *buf, guint len)
+{
+	xmms_ices_data_t *data;
+
+	g_return_if_fail (effect);
+
+	data = xmms_effect_private_data_get (effect);
+	g_return_if_fail (data);
+
+	if (!data->buf && data->connected) {
+		data->write_buf = FALSE;
+		data->buf = ringbuf_new (data->buf_size);
+		data->end_thread = FALSE;
+		data->thread = g_thread_create ((GThreadFunc) xmms_ices_thread,
+		                                (gpointer) effect, TRUE, NULL);
+	}
+	if (data->write_buf) {
+		if(!ringbuf_write (data->buf, (gconstpointer) buf, (gulong) len)) {
+			xmms_log_error ("Ringbuffer overrun.");
+		}
+	}
+}
+
 static void
-xmms_ices_samplerate_set (xmms_effect_t *effect, guint rate)
+xmms_ices_entry_changed (xmms_effect_t *effect, xmms_medialib_entry_t entry)
 {
 	xmms_ices_data_t *data;
+	xmms_medialib_session_t *session;
 	xmms_config_property_t *val;
 	gint nombr;
 	static struct {
@@ -298,56 +375,84 @@ xmms_ices_samplerate_set (xmms_effect_t 
 	g_return_if_fail (effect);
 
 	data = xmms_effect_private_data_get (effect);
+
 	g_return_if_fail (data);
 
-	val = xmms_plugin_config_lookup (xmms_effect_plugin_get (effect), "encodingnombr");
+	val = xmms_plugin_config_lookup (xmms_effect_plugin_get (effect),
+	                                 "encodingnombr");
 	nombr = xmms_config_property_get_int (val);
-	XMMS_DBG ("Inited a encoder with rate %d nombr %d", rate, nombr);
+	XMMS_DBG ("Initing an encoder with rate %d nombr %d", data->sample_rate,
+	          nombr);
 
 	vorbis_comment_clear (&data->vc);
 	vorbis_comment_init (&data->vc);
 
+	session = xmms_medialib_begin ();
 	for (pptr = props; pptr && pptr->prop; pptr++) {
 		const gchar *tmp;
 
-		tmp = xmms_medialib_entry_property_get (data->entry,
-		                                        pptr->prop);
+		tmp = xmms_medialib_entry_property_get_str (session, entry, pptr->prop);
 		if (tmp) {
-			vorbis_comment_add_tag (&data->vc,
-			                        pptr->key, (gchar *) tmp);
+			vorbis_comment_add_tag (&data->vc, pptr->key, (gchar *) tmp);
 		}
 	}
+	xmms_medialib_end (session);
 
-	data->enc = encode_initialise (2, rate, 1, -1, nombr, -1,
-	                               3, data->serial++, &data->vc);
+	data->enc = encode_initialise (data->channels, data->sample_rate, 1, -1,
+	                               nombr, -1, 3, data->serial++, &data->vc);
+
+	if (!data->buf) {
+		data->write_buf = FALSE;
+		data->buf = ringbuf_new (data->buf_size);
+		data->end_thread = FALSE;
+		data->thread = g_thread_create ((GThreadFunc) xmms_ices_thread,
+		                                (gpointer) effect, TRUE, NULL);
+	}
 }
 
-static void
-xmms_ices_process (xmms_effect_t *effect, gchar *buf, guint len)
+static void xmms_ices_configval_changed (xmms_object_t *obj,
+                                         gconstpointer value, gpointer udata)
 {
+	xmms_config_property_t *prop = (xmms_config_property_t *) obj;
 	xmms_ices_data_t *data;
+	xmms_effect_t *effect = udata;
+	xmms_plugin_t *plugin;
+	const gchar *propname = xmms_config_property_get_name (prop);
 
 	g_return_if_fail (effect);
 
+	plugin = xmms_effect_plugin_get (effect);
+	g_return_if_fail (plugin);
+
 	data = xmms_effect_private_data_get (effect);
 	g_return_if_fail (data);
 
-	if (data->write_buf) {
-		xmms_ringbuf_write (data->buf, buf, len);
+	if (strcasecmp (propname, "effect.ices.buffersize")) {
+		data->buf_size = (gulong) xmms_config_property_get_int (prop);
+	} else if (strcasecmp (propname, "effect.ices.encodingnombr")) {
+		data->enc = encode_initialise (data->channels, data->sample_rate, 1, -1,
+	                                   xmms_config_property_get_int (xmms_plugin_config_lookup (plugin,
+	                                                                                            "encodingnombr")),
+						               -1, 3, data->serial++, &data->vc);
+	} else if (strcasecmp (propname, "effect.ices.host")) {
+		shout_set_host (data->shout, xmms_config_property_get_string (prop));
+	} else if (strcasecmp (propname, "effect.ices.mount")) {
+		shout_set_mount (data->shout, xmms_config_property_get_string (prop));
+	} else if (strcasecmp (propname, "effect.ices.password")) {
+		shout_set_password (data->shout, xmms_config_property_get_string (prop));
+	} else if (strcasecmp (propname, "effect.ices.port")) {
+		shout_set_port (data->shout, xmms_config_property_get_int (prop));
+	} else if (strcasecmp (propname, "effect.ices.public")) {
+		shout_set_public (data->shout, !!xmms_config_property_get_int (prop));
+	} else if (strcasecmp (propname, "effect.ices.streamdescription")) {
+		shout_set_description (data->shout, xmms_config_property_get_string (prop));
+	} else if (strcasecmp (propname, "effect.ices.streamgenre")) {
+		shout_set_genre (data->shout, xmms_config_property_get_string (prop));
+	} else if (strcasecmp (propname, "effect.ices.streamname")) {
+		shout_set_name (data->shout, xmms_config_property_get_string (prop));
+	} else if (strcasecmp (propname, "effect.ices.streamurl")) {
+		shout_set_host (data->shout, xmms_config_property_get_string (prop));
+	} else if (strcasecmp (propname, "effect.ices.user")) {
+		shout_set_user (data->shout, xmms_config_property_get_string (prop));
 	}
 }
-
-static void
-on_playlist_entry_changed (xmms_output_t *output,
-                           const xmms_object_cmd_arg_t *arg,
-                           xmms_ices_data_t *data)
-{
-	xmms_error_t error;
-
-	if (data->entry) {
-		xmms_object_unref (data->entry);
-	}
-
-	xmms_error_reset (&error);
-	data->entry = xmms_output_playing_entry_get (output, &error);
-}
