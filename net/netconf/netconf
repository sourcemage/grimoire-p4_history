#!/bin/bash
#
# netconf
#    A bash/dialog based network configuration tool for the
#    SourceMage GNU/Linux distribution: http://www.sourcemage.org
#
# Copyright (c) 2002-2003 Casey Harkins <charkins@pobox.com>
#
# --------------------------- License ------------------------------- #
# This is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this software; if not, write to the Free
# Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# ------------------------- ChangeLog ------------------------------- #
# 2003-06-20  charkins <charkins@pobox.com>
#     - added mangle_hosts() function to update the /etc/hosts file
#       when the hostname is changed, all entries for 127.0.0.1 are
#       removed and the localhost and hostname entries are then added
#       back in
#     - mangle_hosts() will also create the /etc/hosts file if it
#       does not exist including the comment section describing the
#       file
#     - renamed change_hostname() to cfg_hostname() to be more
#       consistent with other function names
#     - added option to configure DNS on main menu, the dns menu
#       is implemented in cfg_dns() which uses cfg_ns() to set an
#       individual nameserver, supports up to three nameservers
#       (as per the resolv.conf man page), search/domain/options
#       cannot be specified through netconf, though only nameserver
#       lines will be modified in /etc/resolv.conf
#     - version 0.9
#
# 2003-06-19  charkins <charkins@pobox.com>
#     - change_hostname now creates the hostname file automatically
#       with the hostname='sourcemage' if it doesn't exist, this
#       should gauruntee its existence whether the user likes it or
#       not :-)
#     - added some command line options for performing some basic
#       tasks, only one may be specified at a time and it will
#       exit immediately after the task is finished
#          --check_hostname: checks if the hostname file exists, 
#                            and prompts the user for a hostname if
#                            it doesn't exist
#          --check_devdir:   checks if the network device directory
#                            exists and prompts the user to create it
#                            if it doesn't exist
#          --check_lo:       checks if the loopback device exists
#                            and prompts the user to create it if
#                            it doesn't exist
#     - version 0.8
#
# 2003-06-19  charkins <charkins@pobox.com>
#     - changing hostname, ip, broadcast, netmask, gateway
#       or module will default to current value
#     - added option to change hostname from main menu
#     - pressing ESC or entering a blank hostname will now
#       use 'sourcemage' as the hostname
#     - added --aspect parameter (currently set to 25) to DIALOG
#       to improve the general appearance of some dialogs
#     - version 0.7
#
# 2003-06-19  charkins <charkins@pobox.com>
#     - added check_hostname and check_lo to check on startup
#       for existence of hostname file and loopback network device
#     - changed the 'su' call to not set any environment variables
#     - integrated ChangeLog into script for easier management
#     - version 0.6
# 
# 2002-11-05  charkins <charkins@pobox.com>
#     - corrected integer comparisons to use -eq instead of ==
#     - added special handling of loopback device in remove_device()
#       and getnetdevs()
#     - version 0.5
# 
# 2002-11-04  charkins <charkins@pobox.com>
#     - realized that 'true' returns an exit status (duh), removed
#       zeroreturn() in favor of 'true'
#     - added check_devdir() to check on startup for the existence 
#       and correct permissions of NETDEVDIR, will prompt user to 
#       create the directory if it does not exist
# 
# 2002-11-03  charkins <charkins@pobox.com>
#     - applied Neal's changes to save_device() to use cat instead
#       of echoing data into the device file
# 
# 2002-10-30  charkins <charkins@pobox.com>
#     - moved testing of GOTNETDEVS and GOTNETMODS flags into
#       their respective functions, getnetdevs() and getnetmods()
#       will return without performing any work if the flag
#       variable is non-null
#     - added GOTNETDEVS flag to prevent unnecessary calls
#       to getnetdevs()
#     - fixed more bugs related to new filenaming
#     - other small clean-ups
#     - version 0.4
# 
# 2002-10-28  charkins <charkins@pobox.com>
#     - fixed bug in getnetdevs() which used old filenaming scheme
#     - version 0.3
# 
# 2002-10-28  charkins <charkins@pobox.com>
#     - switched to <devicename>.dev filenaming scheme
#     - version 0.2
# 
# 2002-10-28  charkins <charkins@pobox.com>
#     - initial implementation
#     - version 0.1
#
# ----------------------- Testing Tips ------------------------------ #
# To test this script without being logged in as root (or being prompted
# for the root password) and without mucking with your real hostname
# and network settings, uncomment the second ROOTCHECK, NETDEVDIR, HOSTSFN
# and HOSTNAMEFN variables below. This will not check if you are root,
# use the ./network/ as the network device directory and ./hostname
# as the hostname file. Feel free to change these to other locations
# as needed.
#
# ----------------------- Configuration ----------------------------- #
# version
NETCONFVERSION='0.9'

# ROOTCHECK - if set to 1, check if UID is 0, if not su to root first
ROOTCHECK=1
#ROOTCHECK=0

# NETDEVDIR - specifies the directory for network device files
NETDEVDIR=/etc/sysconfig/network
#NETDEVDIR=network

# HOSTNAMEFN - specifies file where the hostname is stored
HOSTNAMEFN=/etc/hostname
#HOSTNAMEFN=hostname

# HOSTSFN - specifies file where the hosts are stored
HOSTSFN=/etc/hosts
#HOSTSFN=hosts

# RESOLVFN - specified file where name servers are listed
RESOLVFN=/etc/resolv.conf
#RESOLVFN=resolv.conf

# DIALOG - dialog program used, could be taken from /etc/sorcery/config
DIALOG="dialog --aspect 25"

# button labels
BTN_ACCEPT='Accept'
BTN_SELECT='Select'
BTN_CANCEL='Cancel'
BTN_EXIT='Exit'
BTN_BACK='Back'

# BACKTITLE - shown at the top of the screen
BACKTITLE="SourceMage Network Configuration Tool - version ${NETCONFVERSION}"



# ------------------------- Functions ------------------------------- #
# getnetmods()
#
# Parses output of 'modprobe -l |grep net' and
# constructs two arrays of available network modules.
#
# POST-CONDITIONS:
# 	NETMODS     - array of network device files
# 	NETMODSMENU - array of "id" "network device file" pairs
#
getnetmods() {
	# only run once
	if [ -n "$GOTNETMODS" ]; then
		return 0;
	fi

	unset NETMODSMENU NETMODS
	id=0
	for i in `modprobe -l |grep net`; do
		modname=`basename $i .o`
		NETMODSMENU[$id]="${id} ${modname}"
		NETMODS[$id]="${modname}"
		id=$((id+1))
	done
	unset id
	GOTNETMODS=1
}

# getnetdevs()
#
# Checks NETDEVDIR for network device files and
# constructs two arrays of these files.
#
# POST-CONDITIONS:
# 	NETDEVS     - array of network device files
# 	NETDEVSMENU - array of "id" "network device file" pairs
#
getnetdevs() {
	# only run if necessary (on start, add or remove)
	if [ -n "$GOTNETDEVS" ]; then
		return 0;
	fi
	unset NETDEVSMENU NETDEVS
	id=0
	for i in `ls $NETDEVDIR/*.dev`; do
		NETDEVSMENU[$id]="${id} `basename $i .dev`"
		NETDEVS[$id]="${i}"
		id=$((id+1))
	done
	unset id
	GOTNETDEVS=1
}

# cfg_ns()
#
# Prompts the user for a name server ip address
#
# PARAMETERS: nameserver number to configure (1-3)
#
# POST-CONDITIONS:
#   Corresponding ns variable set to users input, or
#   left unchanged if the user cancelled.
cfg_ns() {
	if [ -z "$1" ]; then
		echo "Error: cfg_ns() called with no parameter"
		exit 1
	fi

	unset ns
	case $1 in 
		'1') ns=$ns1 ;;
		'2') ns=$ns2 ;;
		'3') ns=$ns3 ;;
		'*') ns=""   ;;
	esac

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure Nameserver $1"                         \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the IP address of nameserver $1:"                  \
	                  0 0 $ns`

	if [ $? -eq 0 ]; then
		case $1 in 
			'1') ns1=$COMMAND ;;
			'2') ns2=$COMMAND ;;
			'3') ns3=$COMMAND ;;
		esac
	fi

	unset ns
}



# cfg_dns()
#
# Presents user with menu to configure dns settings.
#
#
cfg_dns() {

	if [ ! -f "$RESOLVFN" ]; then
		touch $RESOLVFN
	fi

	# find the current nameservers
	unset ns1 ns2 ns3
	for i in `grep ^nameserver $RESOLVFN | sed 's/^nameserver //'`; do
		if [ -z $ns1 ]; then
			ns1=$i
		elif [ -z $ns2 ]; then
			ns2=$i
		elif [ -z $ns3 ]; then
			ns3=$i
		else
			break;
		fi
	done

	while [ true ]; do

		COMMAND=`$DIALOG --backtitle "$BACKTITLE"            \
		                 --stdout                            \
		                 --title "Configure DNS"             \
		                 --ok-label       "$BTN_SELECT"      \
		                 --cancel-label   "$BTN_CANCEL"      \
		                 --menu                              \
		                 "Choose a name server to modify:"   \
		                 0 0 0                               \
		                 "1" "$ns1"                          \
		                 "2" "$ns2"                          \
		                 "3" "$ns3"                          \
		                 "Save" "Save changes to $RESOLVFN and return to main menu"`

		if [ $? != 0 ]; then
			unset ns1 ns2 ns3
			return 0
		fi

		case $COMMAND in
			'1') cfg_ns "1" ;;
			'2') cfg_ns "2" ;;
			'3') cfg_ns "3" ;;

			'Save')
				mv $RESOLVFN /tmp/resolv.conf.$$
				grep -v ^nameserver /tmp/resolv.conf.$$ > $RESOLVFN
				if [ ${#ns1} -gt 0 ]; then
					echo "nameserver $ns1" >> $RESOLVFN
				fi
				if [ ${#ns2} -gt 0 ]; then
					echo "nameserver $ns2" >> $RESOLVFN
				fi
				if [ ${#ns3} -gt 0 ]; then
					echo "nameserver $ns3" >> $RESOLVFN
				fi
				rm /tmp/resolv.conf.$$
				unset ns1 ns2 ns3
				return 0
				;;
		esac

	done

}



# check_hostname()
#
# Calls cfg_hostname if no hostname is currently
# specified.
#
check_hostname() {

	# check if HOSTNAMEFN exists
	if [ ! -f "$HOSTNAMEFN" ]; then
		cfg_hostname
	fi

}

# cfg_hostname()
#
# Prompts the user for the hostname for this machine.
# It defaults to the current hostname, or 'sourcemage'
# if no hostname is currently specified.
#
# POST-CONDITIONS:
#   hostname is set in HOSTNAMEFN, if user cancels
#   or enters a blank hostname, 'sourcemage' will be
#   used.
cfg_hostname() {

	if [ -f "$HOSTNAMEFN" ]; then
		curhostname=`cat $HOSTNAMEFN`
	else
		echo "sourcemage" > $HOSTNAMEFN
		curhostname="sourcemage"
		mangle_hosts
	fi

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure Hostname"                              \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --nocancel                                                \
	                 --inputbox                                                \
	                 "What should this computer be called?"                    \
	                  0 0 $curhostname`

	if [ $? -eq 0 ] && [ ${#COMMAND} -gt 0 ]; then
		curhostname="$COMMAND"
	else
		curhostname="sourcemage"
	fi

	echo "$curhostname" > $HOSTNAMEFN
	mangle_hosts
	unset curhostname
}

# mangle_hosts()
#
# Mangles the /etc/hosts file to include entries
# for localhost and the specified hostname. First
# all 127.0.0.1 lines are removed, then two lines
# are added:
#    127.0.0.1       localhost
#    127.0.0.1       hostname
# 
mangle_hosts() {

	if [ ! -f "$HOSTSFN" ]; then
		cat > $HOSTSFN << EOF
#
# hosts         This file describes a number of hostname-to-address
#               mappings for the TCP/IP subsystem.  It is mostly
#               used at boot time, when no name servers are running.
#               On small systems, this file can be used instead of a
#               "named" name server.  Just add the names, addresses
#               and any aliases to this file...
#
EOF
	fi

	mv $HOSTSFN /tmp/hosts.$$
	grep -v ^127.0.0.1 /tmp/hosts.$$    >> $HOSTSFN
	echo "127.0.0.1       localhost"    >> $HOSTSFN
    echo "127.0.0.1       $curhostname" >> $HOSTSFN
	rm -f /tmp/hosts.$$
}

# check_devdir()
#
# Checks to see if NETDEVDIR exists, is a directory and
# is writeable. User will be prompted to create directory
# if it does not exist.
#
# POST-CONDITIONS:
#	NETDEVDIR exists, is a directory and is writeable
#
check_devdir() {

	# check if NETDEVDIR exists
	if [ ! -e $NETDEVDIR ]; then
		COMMAND=`$DIALOG --backtitle "$BACKTITLE"                              \
	                 --stdout                                                  \
	                 --title "Create Directory"                                \
	                 --yesno                                                   \
	                 "The network configuration directory (${NETDEVDIR}) does not exist, create it now?" \
	                 0 0`

		if [ $? != 0 ]; then
			echo "Error: Directory '${NETDEVDIR}' does not exist"
			exit 1
		fi

		mkdir -p $NETDEVDIR

		if [ $? != 0 ]; then
			echo "Error: Could not create directory '${NETDEVDIR}'"
			exit 1
		fi
		
		return 0
	fi

	# check if NETDEVDIR is a directory
	if [ ! -d $NETDEVDIR ]; then
		echo "Error: '${NETDEVDIR}' exists, but is not a directory"
		exit 1
	fi

	# check if NETDEVDIR is writable
	if [ ! -w $NETDEVDIR ]; then
		echo "Error: '${NETDEVDIR}' is not writeable"
		exit 1
	fi

}

# check_lo()
#
# Checks to see if the loopback device exists and prompts
# the user to create it if it does not exist.
#
check_lo() {

	# check if lo.dev exists
	if [ ! -f "$NETDEVDIR/lo.dev" ]; then
		COMMAND=`$DIALOG --backtitle "$BACKTITLE"                              \
	                 --stdout                                                  \
	                 --title "Create Loopback Device"                          \
	                 --yesno                                                   \
	                 "The loopback network device is not configured, do you want to create it now?"  \
	                 0 0`

		if [ $? -eq 0 ]; then
			loadnetdev "$NETDEVDIR/lo.dev"
			devname="lo.dev"
			real_save "$NETDEVDIR/lo.dev"
			unset devname
		fi
	fi

}

# loadnetdev()
#
# Unsets network device variables then loads the
# network device file.
#
# PARAMETERS: absolute path to network device file
#
# POST-CONDITIONS:
#	MODULE     - kernel module to load, or blank for static driver
#	MODE       - 'dynamic' for dhcp, or 'static' for static
#	IP         - IP address
# 	BROADCAST  - broadcast address
#	NETMASK    - netmask
#	GATEWAY    - gateway address
#
loadnetdev() {
	if [ -z "$1" ]; then
		echo "Error: loadnetdev() called with no parameter"
		exit 1
	fi

	unset MODULE MODE IP BROADCAST NETMASK GATEWAY

	devname=`basename $1 .dev`

	if [ -e $1 ]; then
		# file exists, load it
		source $1
	elif [ "$devname" == "lo" ]; then
		# new loopback device, set defaults
		MODULE=''
		MODE='static'
		IP='127.0.0.1'
		BROADCAST='127.255.255.255'
		NETMASK='255.0.0.0'
		GATEWAY=''
	else
		# new non-loopback device, set defaults
		MODE='dynamic'
	fi

	unset devname
}

# cfg_module_enter()
#
# Prompts user to enter the kernel module name (without the .o)
#
# POST-CONDITIONS:
#	MODULE - kernel module to load
#
cfg_module_enter() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MODULE"                                \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the name of the kernel module which your device uses, without the trailing .o" \
	                 0 0 $MODULE`

	if [ $? -eq 0 ]; then
		MODULE=$COMMAND
	fi
	return 0
}

# cfg_module_choose()
#
# Prompts user to select the kernel module from a list
# of available network drivers (uses modprobe -l | grep net)
#
# POST-CONDITIONS:
#	MODULE - kernel module to load
#
cfg_module_choose() {
	getnetmods

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MODULE"                                \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --menu                                                    \
	                 "Select the network module from the following list, or choose 'Enter' if the module is not shown." \
	                 0 0 0                                                     \
	                 ${NETMODSMENU[*]}                                         \
	                 "Enter"  "Enter a module name"`


	if [ $? != 0 ]; then
		return 0
	fi

	case $COMMAND in
		'Enter') cfg_module_enter              ;;
		*)       MODULE=${NETMODS[${COMMAND}]} ;;
	esac
	return 0
}

# cfg_module()
#
# Prompts user for MODULE setting. Three options are presented:
# 	1) Enter module name
#	2) Select from list (modprobe -l |grep net)
#	3) None (use static driver)
#
# POST-CONDITIONS:
#	MODULE - kernel module to load, or blank for static driver
#
cfg_module() {
	if [ -z "$MODULE" ]; then
		dmodule="None (use static driver)"
	else
		dmodule=$MODULE
	fi

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MODULE"                                \
	                 --ok-label       "$BTN_SELECT"                            \
	                 --cancel-label   "$BTN_BACK"                              \
	                 --menu                                                    \
	                 "Choose how to select the kernel module, select 'None' if the driver is compiled into the kernel, or select '$BTN_BACK' to keep the current setting (${dmodule})" \
	                 0 0 0                                                     \
	                 "Enter"  "Enter a module name"                            \
	                 "Choose" "Choose from a list of available network modules"\
	                 "None"   "Use a static driver"`                           

	if [ $? != 0 ]; then
		return 0
	fi

	case $COMMAND in
		'Enter')  cfg_module_enter  ;;
		'Choose') cfg_module_choose ;;
		'None')   MODULE=''         ;;
	esac
	return 0
}

# cfg_mode()
#
# Prompts user for MODE setting. Two options are presented:
#	1) dynamic (use dhcp)
#	2) static
#
# POST-CONDITIONS:
#	MODE       - 'dynamic' for dhcp, or 'static' for static
#
cfg_mode() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MODE"                                  \
	                 --ok-label       "$BTN_SELECT"                            \
	                 --cancel-label   "$BTN_BACK"                              \
	                 --menu                                                    \
	                 "Choose which mode this network device uses.              \
                      Select 'dynamic' to use dhcp, select 'static'            \
                      to specify IP, BROADCAST, NETMASK, GATEWAY, or           \
                      select '${BTN_BACK}' to keep current setting             \
                     (${MODE})"                                                \
	                 0 0 0                                                     \
	                 "dynamic" "use dhcp"                                      \
	                 "static" "specify network settings"`

	if [ $? != 0 ]; then
		return 0
	fi

	case $COMMAND in
		'dynamic') MODE='dynamic'   ;;
		'static')  MODE='static'    ;;
	esac


	return 0
}

# cfg_ip()
#
# Prompts user to enter the ip address.
#
# POST-CONDITIONS:
#	IP         - IP address
#
cfg_ip() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure IP address"                            \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the IP address for this network device"            \
	                 0 0 $IP`

	if [ $? -eq 0 ]; then
		IP=$COMMAND
	fi
	return 0
}


# cfg_broadcast()
#
# Prompts user to enter the broadcast address.
#
# POST-CONDITIONS:
# 	BROADCAST  - broadcast address
#
cfg_broadcast() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure BROADCAST address"                     \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the broadcast address for this network device"     \
	                 0 0 $BROADCAST`

	if [ $? -eq 0 ]; then
		BROADCAST=$COMMAND
	fi
	return 0
}


# cfg_netmask()
#
# Prompts user to enter the netmask.
#
# POST-CONDITIONS:
#	NETMASK    - netmask
#
cfg_netmask() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure NETMASK"                               \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the netmask for this network device"               \
	                 0 0 $NETMASK`

	if [ $? -eq 0 ]; then
		NETMASK=$COMMAND
	fi
	return 0
}


# cfg_gateway()
#
# Prompts user to enter the gateway address.
#
# POST-CONDITIONS:
#	GATEWAY    - gateway address
#
cfg_gateway() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure GATEWAY address"                       \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the gateway address for this network device"       \
	                 0 0 $GATEWAY`

	if [ $? -eq 0 ]; then
		GATEWAY=$COMMAND
	fi
	return 0
}

# remove_device()
#
# Prompts user to confirm removing the device file.
#
# PARAMETERS: absolute path to network device file
#
remove_device() {
	if [ -z "$1" ]; then
		echo "Error: remove_device() called with no parameter"
		exit 1
	fi

	devname=`basename $1 .dev`

	if [ "$devname" == "lo" ]; then
		# give special warning about removing loopback device
		COMMAND=`$DIALOG --backtitle "$BACKTITLE"                              \
		                 --stdout                                              \
		                 --title "Confirm loopback device removal"             \
		                 --yesno                                               \
		                 "The loopback network device is necessary to make local connections to your machine. Removing this device may break some software! Are you absolutely sure you want to remove the loopback device: ${devname}?" \
		                 0 0`
	else
		# confirm removal of network device
		COMMAND=`$DIALOG --backtitle "$BACKTITLE"                              \
		                 --stdout                                              \
		                 --title "Confirm device removal"                      \
		                 --yesno                                               \
		                 "Are you sure you want to remove device file: ${devname}?" \
		                 0 0`
	fi

	if [ $? -eq 0 ]; then
		rm -f $1

		# cause getnetdevs() to run to remove device from main menu
		unset GOTNETDEVS devname
		
		return 1 # return 1 to return back to main menu
	fi

	unset devname
	return 0
}

# save_device()
#
# Prompts user to confirm saving the device file.
#
# PARAMETERS: absolute path to network device file
#
save_device() {
	if [ -z "$1" ]; then
		echo "Error: save_device() called with no parameter"
		exit 1
	fi

	devname=$(basename $1)

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Confirm device saving"                           \
	                 --yesno                                                   \
	                 "Are you sure you want to save device file: ${devname}?"  \
	                 0 0`

	if [ $? -eq 0 ]; then
		real_save $1
		unset devname
		return 1 # return 1 to return back to main menu
	fi
	
	unset devname
	return 0
}

# real_save()
#
# Saves the network device file.
#
# PARAMETERS: absolute path to network device file
#
# POST-CONDITIONS:
#	device file is saved
#
real_save() {
	if [ -z "$1" ]; then
		echo "Error: real_save() called with no parameter"
		exit 1
	fi
	cat > $1 << EOF
# $devname configuration
# created by: ${BACKTITLE}
# last modified: `date`
MODULE=${MODULE}
MODE=${MODE}
IP=${IP}
BROADCAST=${BROADCAST}
NETMASK=${NETMASK}
GATEWAY=${GATEWAY}
EOF

}

# add_device()
#
# Prompts user for device name and passes control
# to cfg_device.
#
add_device() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Add new network device"                          \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the name for this device (e.g. eth0, plip1)"       \
	                 0 0`

	if [ $? != 0 ]; then
		return 0
	fi

	if [ -z "$COMMAND" ]; then
		return 0
	fi

	cfg_device "${NETDEVDIR}/${COMMAND}.dev"

	# cause getnetdevs() to run to pick up new device
	unset GOTNETDEVS

	return 0
}

# cfg_device()
#
# Presents user with menu to configure network options as
# well as options to remove or save the configuration.
#
# PARAMETERS: absolute path to network device file
#
# POST-CONDITIONS:
#	device file is saved
#
cfg_device() {
	if [ -z "$1" ]; then
		echo "Error: cfg_device() called with no parameter"
		exit 1
	fi

	# load the network device file
	loadnetdev "$1"

	true
	while [ $? -eq 0 ]; do

		if [ -z "$MODULE" ]; then
			dmodule="None (use static driver)"
		else
			dmodule=$MODULE
		fi

		if [ `echo $MODE` = 'dynamic' ]; then
			COMMAND=`$DIALOG --backtitle "$BACKTITLE"                          \
			                 --stdout                                          \
		                     --title "Modify, Remove Network Device"           \
			                 --ok-label       "$BTN_SELECT"                    \
			                 --cancel-label   "$BTN_BACK"                      \
			                 --menu                                            \
			                 "Choose a setting to modify, or select Remove to remove the device" \
			                 0 0 0                                             \
			                 "MODULE" "${dmodule}"                             \
			                 "MODE" "dynamic (use dhcp)"                       \
			                 "Remove" "Remove this network device"             \
			                 "Save" "Save these settings to the device file"`
		else
			COMMAND=`$DIALOG --backtitle "$BACKTITLE"                          \
			                 --stdout                                          \
		                     --title "Modify, Remove Network Device"           \
			                 --ok-label       "$BTN_SELECT"                    \
			                 --cancel-label   "$BTN_BACK"                      \
			                 --menu                                            \
			                 "Choose a setting to modify, or select Remove to remove the device" \
			                 0 0 0                                             \
			                 "MODULE" "${dmodule}"                             \
			                 "MODE" "static"                                   \
			                 "IP" "${IP}"                                      \
			                 "BROADCAST" "${BROADCAST}"                        \
			                 "NETMASK" "${NETMASK}"                            \
			                 "GATEWAY" "${GATEWAY}"                            \
			                 "Remove" "Remove this network device"             \
			                 "Save" "Save these settings to the device file"`
		fi


		if [ $? != 0 ]; then
			unset dmodule
			return 0
		fi

		case $COMMAND in
			'MODULE')    cfg_module          ;;
			'MODE')      cfg_mode            ;;
			'IP')        cfg_ip              ;;
			'BROADCAST') cfg_broadcast       ;;
			'GATEWAY')   cfg_gateway         ;;
			'NETMASK')   cfg_netmask         ;;
			'Remove')    remove_device "$1"  ;;
			'Save')      save_device "$1"    ;;
		esac

	done

	unset dmodule
	return 0
}

# parse_args()
#
# ARGUMENTS:
#
#	--check_hostname : calls check_hostname
#	--check_devdir   : calls check_devdir
#	--check_lo       : calls check_lo
#
parse_args() {

	if [ $# -lt 1 ]; then
		return;
	fi

	if [ $# -gt 1 ]; then
		echo "Error: too many arguments"
		exit 1;
	fi

	case $1 in
		'--check_hostname')	check_hostname
		                    exit 0            ;;
		'--check_devdir')   check_devdir
		                    exit 0            ;;
		'--check_lo')       check_lo
		                    exit 0            ;;
		*) echo "Error: Invalid argument: $1"
		   exit 1                             ;;
	esac

}

# main()
#
# The netconf main menu.
#
main() {

	parse_args $*
	check_hostname
	check_devdir
	check_lo

	unset GOTNETMODS GOTNETDEVS

	true
	while [ $? -eq 0 ]; do

		getnetdevs

		curhostname=`cat $HOSTNAMEFN`

		COMMAND=`$DIALOG --backtitle "$BACKTITLE"                               \
		                 --stdout                                               \
		                 --title "Add, Modify, Remove Netowrk Devices"          \
		                 --ok-label       "$BTN_SELECT"                         \
		                 --cancel-label   "$BTN_EXIT"                           \
		                 --menu                                                 \
		                 "Choose a device to modify or remove, or select Add to add a new device. Change will allow you to change the hostname of this computer." \
		                 0 0 0                                                  \
		                 ${NETDEVSMENU[*]}                                      \
		                 "Add" "Add new network device"                         \
		                 "Hostname" "Change hostname (currently: $curhostname)" \
		                 "DNS" "Configure DNS servers"`

		if [ $? != 0 ]; then
			# Exit
			exit 0
		fi

		case $COMMAND in
			'Add')      add_device                        ;;
			'Hostname') cfg_hostname                      ;;
			'DNS')      cfg_dns                           ;;
			*)          cfg_device "${NETDEVS[$COMMAND]}" ;;
		esac

		unset curhostname
	done
}


# ------------------------- Entry Point ----------------------------- #
if [ "$ROOTCHECK" -eq 1 ]; then
	if [ "$UID" != 0 ]; then
		echo "Enter the root password, please."
		su  -c "$0 $*"
		exit
	fi
fi

main $*
