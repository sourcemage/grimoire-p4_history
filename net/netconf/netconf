#!/bin/bash
#
# vi: ts=4 sw=4 noet
#--------------------------- bashdoc ---------------------------------#
## @Synposis   SourceMage network configuration tool
## @Copyright  Copyright 2003-2004 SourceMage Team
## @License    GPL v2
##
## <p>
## netconf is network configuration tool written in bash for the
## <a href="http://www.sourcemage.org/">SourceMage GNU/Linux</a>
## distribution. It uses dialog to provide a menu driven interface 
## to configuring network devices.
##
## <p>
## Network devices in <a href="http://www.sourcemage.org/">SourceMage
## </a> are configured using files in /etc/sysconfig/network. Each 
## device has its own file and must end with the extension ".dev". 
## These files specify options for the device and may even override
## special functions to perform extra activities when a device is
## brought up or down. netconf does not currently provide a means
## for specifying these special functions. However, it will leave
## them untouched when editing a device file that contains them.
##
## <p>
## In addition to configuring these network device files, netconf
## can also configure nameservers (/etc/resolv.conf) and the machine's
## hostname (/etc/hostname and /etc/hosts).
##
## <p>
## This is free software; you can redistribute it and/or
## modify it under the terms of the GNU General Public
## License as published by the Free Software Foundation; either
## version 2 of the License, or (at your option) any later version.
##
## <p>
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## General Public License for more details.
##
## <p>
## You should have received a copy of the GNU General Public
## License along with this software; if not, write to the Free
## Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#---------------------------------------------------------------------#
#
# ------------------------- ChangeLog ------------------------------- #
# 2004-12-08  Arjan Bouter <abouter@sourcemage.org>
#     - added WIFI settings
#     - added cfg_wifi
#
# 2004-10-08  Robert Helgesson <net@sourcemage.org>
#     - added sw=4 noet to vi settings
#     - fixed handling when the $NETDEVDIR directory is empty (bug #7459)
#
# 2004-04-29  charkins <charkins@pobox.com>
#     - finished adding bashdoc comments and code cleanups
#     - removed sedit function, now use 'sed -i' to edit in-place
#
# 2004-04-24  charkins <charkins@pobox.com>
#     - started adding bashdoc comments
#     - replaced basename usage with get_basename() function
#     - minor code cleanups
#
# 2004-04-12  charkins <charkins@pobox.com>
#     - sort module names in getnetmods() courtesy of rycee (bug #6496)
#     - version 1.4
#
# 2004-03-16  charkins <charkins@pobox.com>
#     - fix parsing of module names in getnetmods() courtesy
#	    of rycee (bug #6373)
#
# 2004-02-11  charkins <charkins@pobox.com>
#     - removed special handling of loopback device, lo.dev file will
#       be removed automatically if it exists (bug #5776)
# 
# 2004-01-20  charkins <charkins@pobox.com>
#     - small fix in cfg_mtu() where dialog was defaulting to GATEWAY
#       rather than MTU
#     - modified save_update() to use new cat_or_sedit() function
#     - added cat_or_sedit() to selectively sedit or cat depending
#       on if the sed pattern can be greped from the file; fixes
#       problem of adding new fields to an existing device file
#     - version 1.1
#
# 2003-10-28  charkins <charkins@pobox.com>
#     - stole sedit() function from sorcery's libmisc
#     - renamed save_device() to confirm_save() for clarity
#     - renamed real_save() to save_new() for clarity
#     - added save_update() to make in-place changes to a device file
#       using sedit, allowing network functions to be preserved in files
#     - confirm_save() confirms if the user wishes to save a device
#       file, if they answer yes, it calls either save_new() or 
#       save_update() to save the file depending on if the device
#       file exists
#     - made use of local in many functions and removed unset's where
#       no longer needed
#     - corrected spelling error in 2003-06-19 change entry :-)
#     - version 1.0
#
# 2003-10-26  charkins <charkins@pobox.com>
#     - shortened a couple strings to prevent them from being cut off
#     - added cfg_pointopoint()
#     - added cfg_mtu()
#     - added toggle_boot()
#     - updated loadnetdev() and cfg_device() to support POINTOPOINT,
#       MTU and UP_ON_BOOT options
#
# 2003-08-04  charkins <charkins@pobox.com>
#     - fixed a case bug in cfg_ns(): changed '*') to *)
# 
# 2003-07-28  charkins <charkins@pobox.com>
#     - cfg_hostname() dialog now has a cancel button
#     - cancelling changes to hostname or trying to set a blank
#       hostname will now leave /etc/hostname unchanged
# 
# 2003-07-17  charkins <charkins@pobox.com>
#     - minor reorganization of configuration variables
#
# 2003-06-20  charkins <charkins@pobox.com>
#     - added mangle_hosts() function to update the /etc/hosts file
#       when the hostname is changed, all entries for 127.0.0.1 are
#       removed and the localhost and hostname entries are then added
#       back in
#     - mangle_hosts() will also create the /etc/hosts file if it
#       does not exist including the comment section describing the
#       file
#     - renamed change_hostname() to cfg_hostname() to be more
#       consistent with other function names
#     - added option to configure DNS on main menu, the dns menu
#       is implemented in cfg_dns() which uses cfg_ns() to set an
#       individual nameserver, supports up to three nameservers
#       (as per the resolv.conf man page), search/domain/options
#       cannot be specified through netconf, though only nameserver
#       lines will be modified in /etc/resolv.conf
#     - version 0.9
#
# 2003-06-19  charkins <charkins@pobox.com>
#     - change_hostname now creates the hostname file automatically
#       with the hostname='sourcemage' if it doesn't exist, this
#       should gaurantee its existence whether the user likes it or
#       not :-)
#     - added some command line options for performing some basic
#       tasks, only one may be specified at a time and it will
#       exit immediately after the task is finished
#          --check_hostname: checks if the hostname file exists, 
#                            and prompts the user for a hostname if
#                            it doesn't exist
#          --check_devdir:   checks if the network device directory
#                            exists and prompts the user to create it
#                            if it doesn't exist
#          --check_lo:       checks if the loopback device exists
#                            and prompts the user to create it if
#                            it doesn't exist
#     - version 0.8
#
# 2003-06-19  charkins <charkins@pobox.com>
#     - changing hostname, ip, broadcast, netmask, gateway
#       or module will default to current value
#     - added option to change hostname from main menu
#     - pressing ESC or entering a blank hostname will now
#       use 'sourcemage' as the hostname
#     - added --aspect parameter (currently set to 25) to DIALOG
#       to improve the general appearance of some dialogs
#     - version 0.7
#
# 2003-06-19  charkins <charkins@pobox.com>
#     - added check_hostname and check_lo to check on startup
#       for existence of hostname file and loopback network device
#     - changed the 'su' call to not set any environment variables
#     - integrated ChangeLog into script for easier management
#     - version 0.6
# 
# 2002-11-05  charkins <charkins@pobox.com>
#     - corrected integer comparisons to use -eq instead of ==
#     - added special handling of loopback device in remove_device()
#       and getnetdevs()
#     - version 0.5
# 
# 2002-11-04  charkins <charkins@pobox.com>
#     - realized that 'true' returns an exit status (duh), removed
#       zeroreturn() in favor of 'true'
#     - added check_devdir() to check on startup for the existence 
#       and correct permissions of NETDEVDIR, will prompt user to 
#       create the directory if it does not exist
# 
# 2002-11-03  charkins <charkins@pobox.com>
#     - applied Neal's changes to save_device() to use cat instead
#       of echoing data into the device file
# 
# 2002-10-30  charkins <charkins@pobox.com>
#     - moved testing of GOTNETDEVS and GOTNETMODS flags into
#       their respective functions, getnetdevs() and getnetmods()
#       will return without performing any work if the flag
#       variable is non-null
#     - added GOTNETDEVS flag to prevent unnecessary calls
#       to getnetdevs()
#     - fixed more bugs related to new filenaming
#     - other small clean-ups
#     - version 0.4
# 
# 2002-10-28  charkins <charkins@pobox.com>
#     - fixed bug in getnetdevs() which used old filenaming scheme
#     - version 0.3
# 
# 2002-10-28  charkins <charkins@pobox.com>
#     - switched to <devicename>.dev filenaming scheme
#     - version 0.2
# 
# 2002-10-28  charkins <charkins@pobox.com>
#     - initial implementation
#     - version 0.1
#
# ----------------------- Configuration ----------------------------- #
# NETCONFVERSION: version number of this script
#      ROOTCHECK: if user is not root, then su and run script
#      NETDEVDIR: directory to store network device files
#     HOSTNAMEFN: name of file containing hostname
#        HOSTSFN: name of file containing hosts
#       RESOLVFN: name of file containing nameservers
#
NETCONFVERSION='1.5'
ROOTCHECK=1
NETDEVDIR=/etc/sysconfig/network
HOSTNAMEFN=/etc/hostname
HOSTSFN=/etc/hosts
RESOLVFN=/etc/resolv.conf

# -------------------------- Testing -------------------------------- #
# To test this script without running as root and without modifying
# the actual network settings for a system, uncomment the following
# block of variables. This will disable the root check and look in
# the current working directory for the various files.
# 
#ROOTCHECK=0
#NETDEVDIR=network
#HOSTNAMEFN=hostname
#HOSTSFN=hosts
#RESOLVFN=resolv.conf


# ----------------------- Other Globals ----------------------------- #
# DIALOG - dialog program used, could be taken from /etc/sorcery/config
DIALOG="dialog --aspect 25"

# button labels
BTN_ACCEPT='Accept'
BTN_SELECT='Select'
BTN_CANCEL='Cancel'
BTN_EXIT='Exit'
BTN_BACK='Back'

# BACKTITLE - shown at the top of the screen
BACKTITLE="SourceMage Network Configuration Tool - version ${NETCONFVERSION}"



# ------------------------- Functions ------------------------------- #
#--- get_basename()
##
## Strip directory and optionally a suffix from a filename. This
## should function identically to the basename command from coreutils.
##
## @param      path
## @param      suffix [optional]
## @Stdout     basename of path
#---
function get_basename() {
	local s

	# remove trailing slash if it exists
	s=${1%/}

	# strip directory by removing largest .*/ prefix
	s=${s##*/}

	# strip suffix if necessary
	if [ -n "$2" ]; then
		s=${s%"$2"}
	fi

	echo $s
}

#--- getnetmods()
##
## If GOTNETMODS is null, it parses output of 'modprobe -l |grep net' 
## and constructs two arrays of available network modules. Otherwise,
## it immediately returns.
##
## @Global      GOTNETMODS: arrays are constructed if this is null<br>
## @Global      NETMODS: array of network modules<br>
## @Global      NETMODSMENU: array of id / network module pairs
## @External    modprobe, sed
#---
function getnetmods() {
	# only run once
	if [ -n "$GOTNETMODS" ]; then
		return
	fi

	local id
	local modname

	unset NETMODSMENU NETMODS
	id=0
	for modname in $( modprobe -l \
	                | sed -n '/\/net\// { s!.*/!!; s!\..*!!; p; }' | sort); do
		NETMODSMENU[$id]="${id} ${modname}"
		NETMODS[$id]="${modname}"
		id=$((id+1))
	done
	GOTNETMODS=1

	return
}

#--- getnetdevs()
#
## If GOTNETDEVS is null, it checks NETDEVDIR for network device 
## files and constructs two arrays of configured devices. 
## Otherwise, it immediately returns. If lo.dev exists, it is
## silently removed. 
##
## @Global      GOTNETDEVS: arrays are constructed if this is null<br>
## @Global      NETDEVS: array of configured network devices<br>
## @Global      NETDEVSMENU: array of id / network device pairs<br>
## @Global      NETDEVDIR: path to network device directory
## @External    rm
#---
function getnetdevs() {
	# only run if necessary (on start, add or remove)
	if [ -n "$GOTNETDEVS" ]; then
		return 0;
	fi

	# remove the unused lo.dev file if it exists
	if [ -e ${NETDEVDIR}/lo.dev ]; then
		rm -f ${NETDEVDIR}/lo.dev >> /dev/null
	fi

	local id
	local i

	unset NETDEVSMENU NETDEVS
	id=0
	for i in $NETDEVDIR/*.dev; do
		if [ "$i" = "$NETDEVDIR/*.dev" ] ; then
			break
		fi
		NETDEVSMENU[$id]="${id} `get_basename $i .dev`"
		NETDEVS[$id]="${i}"
		id=$((id+1))
	done
	GOTNETDEVS=1
}

#--- cfg_ns()
##
## Prompts the user for a name server ip address and stores
## it in a global variable. If the user cancels the dialog, 
## no change is made.
##
## @param       name server number to configure (1-3)
## @Global      ns1: first nameserver<br>
## @Global      ns2: second nameserver<br>
## @Global      ns3: third nameserver
## @External    dialog
##
#---
function cfg_ns() {
	if [ -z "$1" ]; then
		echo "Error: cfg_ns() called with no parameter"
		exit 1
	fi

	local ns
	case $1 in 
		'1') ns=$ns1 ;;
		'2') ns=$ns2 ;;
		'3') ns=$ns3 ;;
		  *) ns=""   ;;
	esac

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                  \
	                 --stdout                                  \
	                 --title "Configure Nameserver $1"         \
	                 --ok-label       "$BTN_ACCEPT"            \
	                 --cancel-label   "$BTN_CANCEL"            \
	                 --inputbox                                \
	                 "Enter the IP address of nameserver $1:"  \
	                  0 0 $ns`

	if [ $? -eq 0 ]; then
		case $1 in 
			'1') ns1=$COMMAND ;;
			'2') ns2=$COMMAND ;;
			'3') ns3=$COMMAND ;;
		esac
	fi

}



# TODO: some sort of bug with nameserver parsing

#--- cfg_dns()
##
## Presents user with menu to configure dns settings. Up to
## three nameservers may be specified.
##
## @Global      ns1: first nameserver<br>
## @Global      ns2: second nameserver<br>
## @Global      ns3: third nameserver<br>
## @Global      RESOLVFN: path to resolv.conf
## @External    dialog, grep, sed, mv, rm
#---
function cfg_dns() {

	local i
	unset ns1
	unset ns2
	unset ns3

	if [ ! -f "$RESOLVFN" ]; then
		touch $RESOLVFN
	fi

	# find the current nameservers
	for i in `grep ^nameserver $RESOLVFN | sed 's/^nameserver //'`; do
		if [ -z "$ns1" ]; then
			echo "ns1=$i" >> /tmp/foo
			ns1="$i"
		elif [ -z "$ns2" ]; then
			echo "ns2=$i" >> /tmp/foo
			ns2="$i"
		elif [ -z "$ns3" ]; then
			echo "ns3=$i" >> /tmp/foo
			ns3="$i"
		else
			break;
		fi
	done

	while [ true ]; do

		COMMAND=`$DIALOG --backtitle "$BACKTITLE"            \
		                 --stdout                            \
		                 --title "Configure DNS"             \
		                 --ok-label       "$BTN_SELECT"      \
		                 --cancel-label   "$BTN_CANCEL"      \
		                 --menu                              \
		                 "Choose a name server to modify:"   \
		                 0 0 0                               \
		                 "1" "$ns1"                          \
		                 "2" "$ns2"                          \
		                 "3" "$ns3"                          \
		                 "Save" "Save changes to $RESOLVFN"`

		if [ $? != 0 ]; then
			return 0
		fi

		case $COMMAND in
			'1') cfg_ns "1" ;;
			'2') cfg_ns "2" ;;
			'3') cfg_ns "3" ;;

			'Save')
				mv $RESOLVFN /tmp/resolv.conf.$$
				grep -v ^nameserver /tmp/resolv.conf.$$ > $RESOLVFN
				if [ ${#ns1} -gt 0 ]; then
					echo "nameserver $ns1" >> $RESOLVFN
				fi
				if [ ${#ns2} -gt 0 ]; then
					echo "nameserver $ns2" >> $RESOLVFN
				fi
				if [ ${#ns3} -gt 0 ]; then
					echo "nameserver $ns3" >> $RESOLVFN
				fi
				rm /tmp/resolv.conf.$$
				return 0
				;;
		esac

	done

}



#--- check_hostname()
##
## Calls cfg_hostname if no hostname is currently
## specified.
##
## @Global      HOSTNAMEFN: path to hosts file
#---
function check_hostname() {

	# check if HOSTNAMEFN exists
	if [ ! -f "$HOSTNAMEFN" ]; then
		cfg_hostname
	fi

}

#--- cfg_hostname()
##
## Prompts the user for the hostname for this machine.
## It defaults to the current hostname, or 'sourcemage'
## if no hostname is currently specified. Cancelling the
## dialog leaves the hostname unchanged, or set to
## 'sourcemage' if there was previously no hostname.
##
## @Global      HOSTNAMEFN: path to hostname file
## @External    cat, dialog
#---
function cfg_hostname() {

	local curhostname

	# read in current hostname
	if [ -f "$HOSTNAMEFN" ]; then
		curhostname=`cat $HOSTNAMEFN`
	else
		echo "sourcemage" > $HOSTNAMEFN
		curhostname="sourcemage"
		mangle_hosts
	fi

	# prompt user to change hostname
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                \
	                 --stdout                                \
	                 --title "Configure Hostname"            \
	                 --ok-label       "$BTN_ACCEPT"          \
	                 --cancel-label   "$BTN_CANCEL"          \
	                 --inputbox                              \
	                 "What should this computer be called?"  \
	                  0 0 $curhostname`

	# check if user accepted their changes
	if [ $? -eq 0 ] && [ ${#COMMAND} -gt 0 ]; then
		curhostname="$COMMAND"
		echo "$curhostname" > $HOSTNAMEFN
		mangle_hosts
	fi

}

#--- mangle_hosts()
##
## Mangles the /etc/hosts file to include entries
## for localhost and the specified hostname. First
## all 127.0.0.1 lines are removed, then two lines
## are added:
## <pre>
##    127.0.0.1       localhost
##    127.0.0.1       <hostname>
## </pre>
##
## @Global      HOSTSFN: path to hosts file
## @External    cat, mv, grep
#---
function mangle_hosts() {

	if [ ! -f "$HOSTSFN" ]; then
		cat > $HOSTSFN << EOF
#
# hosts         This file describes a number of hostname-to-address
#               mappings for the TCP/IP subsystem.  It is mostly
#               used at boot time, when no name servers are running.
#               On small systems, this file can be used instead of a
#               "named" name server.  Just add the names, addresses
#               and any aliases to this file...
#
EOF
	fi

	mv $HOSTSFN /tmp/hosts.$$
	grep -v ^127.0.0.1 /tmp/hosts.$$    >> $HOSTSFN
	echo "127.0.0.1       localhost"    >> $HOSTSFN
    echo "127.0.0.1       $curhostname" >> $HOSTSFN
	rm -f /tmp/hosts.$$
}

#--- check_devdir()
##
## Checks to see if NETDEVDIR exists, is a directory and
## is writeable. User will be prompted to create directory
## if it does not exist.
##
## @Global      NETDEVDIR: network device directory
## @External    mkdir, dialog
#---
function check_devdir() {

	# check if NETDEVDIR exists
	if [ ! -e $NETDEVDIR ]; then
		COMMAND=`$DIALOG --backtitle "$BACKTITLE"  \
	                 --stdout                      \
	                 --title "Create Directory"    \
	                 --yesno                       \
	                 "The network configuration directory (${NETDEVDIR}) does not exist, create it now?" \
	                 0 0`

		if [ $? != 0 ]; then
			echo "Error: Directory '${NETDEVDIR}' does not exist"
			exit 1
		fi

		mkdir -p $NETDEVDIR

		if [ $? != 0 ]; then
			echo "Error: Could not create directory '${NETDEVDIR}'"
			exit 1
		fi
		
		return 0
	fi

	# check if NETDEVDIR is a directory
	if [ ! -d $NETDEVDIR ]; then
		echo "Error: '${NETDEVDIR}' exists, but is not a directory"
		exit 1
	fi

	# check if NETDEVDIR is writable
	if [ ! -w $NETDEVDIR ]; then
		echo "Error: '${NETDEVDIR}' is not writeable"
		exit 1
	fi

}

#--- loadnetdev()
##
## Unsets network device variables then loads the
## network device file.
##
## @param     absolute path to network device file
## @Global    MODULE: kernel module or blank for static driver<br>
## @Global    MODE: 'dynamic' for dhcp, or 'static' for static<br>
## @Global    IP: ip address<br>
## @Global    BROADCAST: broadcast address<br>
## @Global    NETMASK: netmask<br>
## @Global    GATEWAY: gateway address<br>
## @Global    POINTTOPOINT: point to point address<br>
## @Global    MTU: maximum transfer unit<br>
## @Global    WIFI: wifi settings passed to iwconfig.<br>
## @Global    UP_ON_BOOT: 'no' if device should not be brought up on boot
#---
function loadnetdev() {
	if [ -z "$1" ]; then
		echo "Error: loadnetdev() called with no parameter"
		exit 1
	fi

	local devname

	unset MODULE MODE IP BROADCAST NETMASK GATEWAY POINTOPOINT MTU WIFI UP_ON_BOOT

	devname=$(get_basename $1 .dev)

	if [ -e $1 ]; then
		# file exists, load it
		source $1
	else
		# new device, set defaults
		MODE='dynamic'
		POINTOPOINT=''
		MTU=''
		WIFI=''
		UP_ON_BOOT='yes'
	fi

}
#--- cfg_module_enter()
##
## Prompts user to enter the kernel module name (without the .o)
##
## @Global    MODULE: kernel module or blank for static driver
## @External  dialog
#---
function cfg_module_enter() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MODULE"                                \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the name of the kernel module which your device uses, without the trailing .o" \
	                 0 0 $MODULE`

	if [ $? -eq 0 ]; then
		MODULE=$COMMAND
	fi
	return 0
}

#--- cfg_module_choose()
##
## Prompts user to select the kernel module from a list
## of available network drivers.
##
## @Global    MODULE: kernel module or blank for static driver
## @External  dialog
#---
function cfg_module_choose() {
	getnetmods

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MODULE"                                \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --menu                                                    \
	                 "Select the network module from the following list, or choose 'Enter' if the module is not shown." \
	                 0 0 0                                                     \
	                 ${NETMODSMENU[*]}                                         \
	                 "Enter"  "Enter a module name"`


	if [ $? != 0 ]; then
		return 0
	fi

	case $COMMAND in
		'Enter') cfg_module_enter              ;;
		*)       MODULE=${NETMODS[${COMMAND}]} ;;
	esac
	return 0
}

#--- cfg_module()
##
## Prompts user for MODULE setting. Three options are presented:
## <ul>
## 	  <li>Enter a module name</li>
##	  <li>Choose from a list of available network modules</li>
##	  <li>None (use static driver)</li>
## </ul>
##
## @Global    MODULE: kernel module or blank for static driver
## @External  dialog
#---
function cfg_module() {
	if [ -z "$MODULE" ]; then
		dmodule="None (use static driver)"
	else
		dmodule=$MODULE
	fi

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MODULE"                                \
	                 --ok-label       "$BTN_SELECT"                            \
	                 --cancel-label   "$BTN_BACK"                              \
	                 --menu                                                    \
	                 "Choose how to select the kernel module, select 'None' if the driver is compiled into the kernel, or select '$BTN_BACK' to keep the current setting (${dmodule})" \
	                 0 0 0                                                     \
	                 "Enter"  "Enter a module name"                            \
	                 "Choose" "Choose from a list of available network modules"\
	                 "None"   "Use a static driver"`                           

	if [ $? != 0 ]; then
		return 0
	fi

	case $COMMAND in
		'Enter')  cfg_module_enter  ;;
		'Choose') cfg_module_choose ;;
		'None')   MODULE=''         ;;
	esac
	return 0
}

#--- cfg_mode()
##
## Prompts user for MODE setting. Two options are presented:
## <ul>
##	  <li>dynamic (use dhcp)</li>
##	  <li>static (specify network settings)</li>
## </ul>
##
## @Global    MODE: 'dynamic' for dhcp, or 'static' for static
## @External  dialog
#---
function cfg_mode() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MODE"                                  \
	                 --ok-label       "$BTN_SELECT"                            \
	                 --cancel-label   "$BTN_BACK"                              \
	                 --menu                                                    \
	                 "Choose which mode this network device uses.              \
                      Select 'dynamic' to use dhcp, select 'static'            \
                      to specify IP, BROADCAST, NETMASK, GATEWAY, or           \
                      select '${BTN_BACK}' to keep current setting             \
                     (${MODE})"                                                \
	                 0 0 0                                                     \
	                 "dynamic" "use dhcp"                                      \
	                 "static" "specify network settings"`

	if [ $? != 0 ]; then
		return 0
	fi

	case $COMMAND in
		'dynamic') MODE='dynamic'   ;;
		'static')  MODE='static'    ;;
	esac


	return 0
}

#--- cfg_ip()
##
## Prompts user to enter the ip address.
##
## @Global    IP: ip address
## @External  dialog
#---
function cfg_ip() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure IP address"                            \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the IP address for this network device"            \
	                 0 0 $IP`

	if [ $? -eq 0 ]; then
		IP=$COMMAND
	fi
	return 0
}


#--- cfg_broadcast()
##
## Prompts user to enter the broadcast address.
##
## @Global    BROADCAST: broadcast address
## @External  dialog
#---
function cfg_broadcast() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure BROADCAST address"                     \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the broadcast address for this network device"     \
	                 0 0 $BROADCAST`

	if [ $? -eq 0 ]; then
		BROADCAST=$COMMAND
	fi
	return 0
}


#--- cfg_netmask()
##
## Prompts user to enter the netmask.
##
## @Global    NETMASK: netmask
## @External  dialog
#---
function cfg_netmask() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure NETMASK"                               \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the netmask for this network device"               \
	                 0 0 $NETMASK`

	if [ $? -eq 0 ]; then
		NETMASK=$COMMAND
	fi
	return 0
}


#--- cfg_gateway()
##
## Prompts user to enter the gateway address.
##
## @Global    GATEWAY: gateway address
## @External  dialog
#---
function cfg_gateway() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure GATEWAY address"                       \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the gateway address for this network device"       \
	                 0 0 $GATEWAY`

	if [ $? -eq 0 ]; then
		GATEWAY=$COMMAND
	fi
	return 0
}

#--- cfg_pointopoint()
##
## Prompts user to enter the point to point address.
##
## @Global    POINTTOPOINT: point to point address
## @External  dialog
#---
function cfg_pointopoint() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure POINTOPOINT address"                   \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the point to point address for this network device"\
	                 0 0 $POINTOPOINT`

	if [ $? -eq 0 ]; then
		POINTOPOINT=$COMMAND
	fi
	return 0
}

#--- cfg_mtu()
##
## Prompts user to enter the maximum transfer unit.
##
## @Global    MTU: maximum transfer unit<br>
## @External  dialog
#---
function cfg_mtu() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MTU"                                   \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the maximum transfer unit for this network device" \
	                 0 0 $MTU`

	if [ $? -eq 0 ]; then
		MTU=$COMMAND
	fi
	return 0
}

#--- cfg_wifi()
##
## Prompts user to set wifi settings
##
## @Global    WIFI: wifi settings passed to iwconfig.<br>
## @External  dialog
#---
function cfg_wifi() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure WIFI"                                   \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the settings for the wifi network. These will be passed to iwconfig" \
	                 0 0 $WIFI`

	if [ $? -eq 0 ]; then
		WIFI=\"$COMMAND\"
	fi
	return 0
}

#--- toggle_boot()
##
## Toggles UP_ON_BOOT state
##
## @Global    UP_ON_BOOT: 'no' if device should not be brought up on boot
#---
function toggle_boot() {
	if [ $UP_ON_BOOT = "no" ]; then
		UP_ON_BOOT="yes"
	else
		UP_ON_BOOT="no"
	fi

	return 0
}

#--- remove_device()
##
## Prompts user to confirm removing the device file.
## If user confirms, the device file is removed and
## the GOTNETDEVS flag is unset to trigger reparsing
## of the network device directory.
##
## @param     absolute path to network device file
## @Global    GOTNETDEVS: unset if device directory should be reparsed
## @External  dialog, rm
#---
function remove_device() {
	if [ -z "$1" ]; then
		echo "Error: remove_device() called with no parameter"
		exit 1
	fi

	local devname

	devname=$(get_basename $1 .dev)

	# confirm removal of network device
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                              \
	                 --stdout                                              \
	                 --title "Confirm device removal"                      \
	                 --yesno                                               \
	                 "Are you sure you want to remove device file: ${devname}?" \
	                 0 0`

	if [ $? -eq 0 ]; then
		rm -f $1

		# cause getnetdevs() to run to remove device from main menu
		unset GOTNETDEVS devname
		
		return 1 # return 1 to return back to main menu
	fi

	return 0
}

#--- confirm_save()
##
## Prompts user to confirm saving the device file.
## If the user confirms, an appropriate function is called
## to save the device (save_new or save_update). The GOTNETDEVS
## flag is unset to trigger reparsing of the network device
## directory.
##
## @param     absolute path to network device file
## @Global    GOTNETDEVS: unset if device directory should be reparsed
## @External  dialog
#---
function confirm_save() {
	if [ -z "$1" ]; then
		echo "Error: confirm_save() called with no parameter"
		exit 1
	fi

	local devname
	devname=$(get_basename $1)

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Confirm device saving"                           \
	                 --yesno                                                   \
	                 "Are you sure you want to save device file: ${devname}?"  \
	                 0 0`

	if [ $? -eq 0 ]; then
		if [ -e $1 ]; then
			save_update $1
		else
			save_new $1
		fi
		return 1 # return 1 to return back to main menu
	fi
	
	return 0
}


#--- save_new()
##
## Saves a new network device file. This function is called
## when a network device file does not yet exist and the user
## wishes to save the device. 
## 
## @param     absolute path to network device file
## @Global    MODULE: kernel module or blank for static driver<br>
## @Global    MODE: 'dynamic' for dhcp, or 'static' for static<br>
## @Global    IP: ip address<br>
## @Global    BROADCAST: broadcast address<br>
## @Global    NETMASK: netmask<br>
## @Global    GATEWAY: gateway address<br>
## @Global    POINTTOPOINT: point to point address<br>
## @Global    MTU: maximum transfer unit<br>
## @Global    WIFI: wifi settings passed to iwconfig<br>
## @Global    UP_ON_BOOT: 'no' if device should not be brought up on boot
## @External  cat, date
#---
function save_new() {
	if [ -z "$1" ]; then
		echo "Error: save_new() called with no parameter"
		exit 1
	fi

	local now
	now=`date`
	cat > $1 << EOF
# $devname configuration
# created by: ${BACKTITLE}
# created on: $now
# last modified: $now
MODULE=${MODULE}
MODE=${MODE}
IP=${IP}
BROADCAST=${BROADCAST}
NETMASK=${NETMASK}
GATEWAY=${GATEWAY}
POINTOPOINT=${POINTOPOINT}
MTU=${MTU}
WIFI=${WIFI}
UP_ON_BOOT=${UP_ON_BOOT}
EOF

}

#--- save_update()
##
## Updates an existing network device file. This function is
## called when a network device file does exist and the user
## wishes to save changes to the device. It makes use of
## the cat_or_sedit function to modify lines in-place in
## the device file if the setting exists in the file,
## otherwise the setting is appended to the file. This should
## preserve any overridden network functions in the device
## file.
## 
## @param     absolute path to network device file
## @Global    MODULE: kernel module or blank for static driver<br>
## @Global    MODE: 'dynamic' for dhcp, or 'static' for static<br>
## @Global    IP: ip address<br>
## @Global    BROADCAST: broadcast address<br>
## @Global    NETMASK: netmask<br>
## @Global    GATEWAY: gateway address<br>
## @Global    POINTTOPOINT: point to point address<br>
## @Global    MTU: maximum transfer unit<br>
## @Global    WIFI: wifi settings passed to iwconfig<br>
## @Global    UP_ON_BOOT: 'no' if device should not be brought up on boot
## @External  date
#---
function save_update() {
	if [ -z "$1" ]; then
		echo "Error: save_update() called with no parameter"
		exit 1
	fi

	if [ ! -e $1 ]; then
		echo "Error: save_update() device file does not exist: $1"
		exit 1
	fi

	cat_or_sedit "^# created by:.*" "# created by: ${BACKTITLE}" $1
	cat_or_sedit "^# last modified:.*" "# last modified: `date`" $1
	cat_or_sedit "^MODULE=.*" "MODULE=${MODULE}" $1
	cat_or_sedit "^MODE=.*" "MODE=${MODE}" $1
	cat_or_sedit "^IP=.*" "IP=${IP}" $1
	cat_or_sedit "^BROADCAST=.*" "BROADCAST=${BROADCAST}" $1
	cat_or_sedit "^NETMASK=.*" "NETMASK=${NETMASK}" $1
	cat_or_sedit "^GATEWAY=.*" "GATEWAY=${GATEWAY}" $1
	cat_or_sedit "^POINTOPOINT=.*" "POINTOPOINT=${POINTOPOINT}" $1
	cat_or_sedit "^MTU=.*" "MTU=${MTU}" $1
	cat_or_sedit "^WIFI=.*" "WIFI=${WIFI}" $1
	cat_or_sedit "^UP_ON_BOOT=.*" "UP_ON_BOOT=${UP_ON_BOOT}" $1

}

#--- cat_or_sedit()
##
## A hack to either sedit an existing line, or add a new
## line if one doesn't exist.
##
## @param     pattern to search for
## @param     line to replace pattern with, or add as new line
## @param     absolute path to network device file
## @External  grep, cat
#---
function cat_or_sedit() {
	if ( cat $3 | grep -q "$1" ); then
		sed -i "s/${1}/${2}/" ${3}
	else
		echo "$2" >> ${3}
	fi
}

#--- add_device()
##
## Prompts user for name of new device and passes control
## to cfg_device. GOTNETDEVS is unset to force reparsing
## of network device directory.
##
## @Global      NETDEVDIR: network device directory<br>
## @Global      GOTNETDEVS: unset if device directory should be reparsed
## @External    dialog
#---
function add_device() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Add new network device"                          \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the name for this device (e.g. eth0, plip1)"       \
	                 0 0`

	if [ $? != 0 ]; then
		return 0
	fi

	if [ -z "$COMMAND" ]; then
		return 0
	fi

	cfg_device "${NETDEVDIR}/${COMMAND}.dev"

	# cause getnetdevs() to run to pick up new device
	unset GOTNETDEVS

	return 0
}

#--- cfg_device()
##
## Presents user with menu to configure network options as
## well as options to remove or save the configuration.
##
## @param     absolute path to network device file
## @Global    MODULE: kernel module or blank for static driver<br>
## @Global    MODE: 'dynamic' for dhcp, or 'static' for static<br>
## @Global    IP: ip address<br>
## @Global    BROADCAST: broadcast address<br>
## @Global    NETMASK: netmask<br>
## @Global    GATEWAY: gateway address<br>
## @Global    POINTTOPOINT: point to point address<br>
## @Global    MTU: maximum transfer unit<br>
## @Global    WIFI: wifi settings passed to iwconfig<br>
## @Global    UP_ON_BOOT: 'no' if device should not be brought up on boot
## @External  dialog
#---
function cfg_device() {
	if [ -z "$1" ]; then
		echo "Error: cfg_device() called with no parameter"
		exit 1
	fi

	# load the network device file
	loadnetdev "$1"

	local dmodule dmtu dpointopoint

	true
	while [ $? -eq 0 ]; do

		if [ -z "$MODULE" ]; then
			dmodule="Use static driver"
		else
			dmodule=$MODULE
		fi

		if [ -z "$MTU" ]; then
			dmtu="Use default MTU"
		else
			dmtu=$MTU
		fi

		if [ -z "$WIFI" ]; then
			dwifi="No wifi settings"
		else
			dwifi=$WIFI
		fi

		if [ -z "$POINTOPOINT" ]; then
			dpointopoint="None"
		else
			dpointopoint=$POINTOPOINT
		fi

		if [ `echo $MODE` = 'dynamic' ]; then
			COMMAND=`$DIALOG --backtitle "$BACKTITLE"                          \
			                 --stdout                                          \
		                     --title "Modify, Remove Network Device"               \
			                 --ok-label       "$BTN_SELECT"                    \
			                 --cancel-label   "$BTN_BACK"                      \
			                 --menu                                            \
			                 "Choose a setting to modify, or select Remove to remove the device" \
			                 0 0 0                                             \
			                 "MODULE" "${dmodule}"                             \
			                 "MODE" "dynamic (use dhcp)"                       \
			                 "POINTOPOINT" "${dpointopoint}"                   \
			                 "MTU"  "${dmtu}"                                  \
			                 "WIFI"  "${dwifi}"                                \
			                 "UP_ON_BOOT" "${UP_ON_BOOT}"                      \
			                 "Remove" "Remove this network device"             \
			                 "Save" "Save this device file"`
		else
			COMMAND=`$DIALOG --backtitle "$BACKTITLE"                          \
			                 --stdout                                          \
		                     --title "Modify, Remove Network Device"           \
			                 --ok-label       "$BTN_SELECT"                    \
			                 --cancel-label   "$BTN_BACK"                      \
			                 --menu                                            \
			                 "Choose a setting to modify, or select Remove to remove the device" \
			                 0 0 0                                             \
			                 "MODULE" "${dmodule}"                             \
			                 "MODE" "static"                                   \
			                 "IP" "${IP}"                                      \
			                 "BROADCAST" "${BROADCAST}"                        \
			                 "NETMASK" "${NETMASK}"                            \
			                 "GATEWAY" "${GATEWAY}"                            \
			                 "POINTOPOINT" "${dpointopoint}"                   \
			                 "MTU"  "${dmtu}"                                  \
			                 "WIFI"  "${dwifi}"                                \
			                 "UP_ON_BOOT" "${UP_ON_BOOT}"                      \
			                 "Remove" "Remove this network device"             \
			                 "Save" "Save this device file"`
		fi


		if [ $? != 0 ]; then
			return 0
		fi

		case $COMMAND in
			'MODULE')      cfg_module          ;;
			'MODE')        cfg_mode            ;;
			'IP')          cfg_ip              ;;
			'BROADCAST')   cfg_broadcast       ;;
			'GATEWAY')     cfg_gateway         ;;
			'NETMASK')     cfg_netmask         ;;
			'POINTOPOINT') cfg_pointopoint     ;;
			'MTU')         cfg_mtu             ;;
			'WIFI')        cfg_wifi            ;;
			'UP_ON_BOOT')  toggle_boot         ;;
			'Remove')      remove_device "$1"  ;;
			'Save')        confirm_save "$1"   ;;
		esac

	done

	return 0
}

#--- parse_args()
## 
## Parses command line arguments. Accepted arguments are:
## <ul>
## <li>--check_hostname: ensures a hostname is defined in 
##     /etc/hostname, if not the user is forced to enter
##     one</li>
## <li>--check_devdir: checks if the network device directory
##     exists, if it doesn't, the user is prompted to create
##     it</li>
## </ul>
##
## @param    command line argument
##
#---
function parse_args() {

	if [ $# -lt 1 ]; then
		return;
	fi

	if [ $# -gt 1 ]; then
		echo "Error: too many arguments"
		exit 1;
	fi

	case $1 in
		'--check_hostname')	check_hostname
		                    exit 0            ;;
		'--check_devdir')   check_devdir
		                    exit 0            ;;
		*) echo "Error: Invalid argument: $1"
		   exit 1                             ;;
	esac

}

#--- main()
##
## The netconf main menu.
##
## @Arguments   command line arguments, will be passed to parse_args
## @Global      HOSTNAMEFN: path to hosts file<br>
## @Global      NETDEVS: array of configured network devices<br>
## @Global      NETDEVSMENU: array of id / network device pairs<br>
## @Global      GOTNETMODS: unset if kernel modules should be reparsed<br>
## @Global      GOTNETDEVS: unset if device directory should be reparsed
## @External    dialog, cat
#---
function main() {

	parse_args $*
	check_hostname
	check_devdir

	local curhostname
	unset GOTNETMODS GOTNETDEVS

	true
	while [ $? -eq 0 ]; do

		getnetdevs

		curhostname=`cat $HOSTNAMEFN`

		COMMAND=`$DIALOG --backtitle "$BACKTITLE"                               \
		                 --stdout                                               \
		                 --title "Add, Modify, Remove Netowrk Devices"          \
		                 --ok-label       "$BTN_SELECT"                         \
		                 --cancel-label   "$BTN_EXIT"                           \
		                 --menu                                                 \
		                 "Choose a device to modify or remove, or select Add to add a new device. Change will allow you to change the hostname of this computer." \
		                 0 0 0                                                  \
		                 ${NETDEVSMENU[*]}                                      \
		                 "Add" "Add new network device"                         \
		                 "Hostname" "Change hostname (currently: $curhostname)" \
		                 "DNS" "Configure DNS servers"`

		if [ $? != 0 ]; then
			# Exit
			exit 0
		fi

		case $COMMAND in
			'Add')      add_device                        ;;
			'Hostname') cfg_hostname                      ;;
			'DNS')      cfg_dns                           ;;
			*)          cfg_device "${NETDEVS[$COMMAND]}" ;;
		esac

	done
}


# ------------------------- Entry Point ----------------------------- #
if [ "$ROOTCHECK" -eq 1 ]; then
	if [ "$UID" != 0 ]; then
		echo "Enter the root password, please."
		su  -c "$0 $*"
		exit
	fi
fi

main $*
