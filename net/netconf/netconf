#!/bin/bash
#
# netconf
#    A bash/dialog based network configuration tool for the
#    SourceMage GNU/Linux distribution: http://www.sourcemage.org
#
# Copyright (c) 2002-2003 Casey Harkins <charkins@pobox.com>
#
# --------------------------- License ------------------------------- #
# This is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public
# License along with this software; if not, write to the Free
# Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#
# ------------------------- ChangeLog ------------------------------- #
# 2004-03-16  charkins <charkins@pobox.com>
#     - fix parsing of module names in getnetmods() courtesy
#	    of rycee (bug #6373)
#
# 2004-02-11  charkins <charkins@pobox.com>
#     - removed special handling of loopback device, lo.dev file will
#       be removed automatically if it exists (bug #5776)
# 
# 2004-01-20  charkins <charkins@pobox.com>
#     - small fix in cfg_mtu() where dialog was defaulting to GATEWAY
#       rather than MTU
#     - modified save_update() to use new cat_or_sedit() function
#     - added cat_or_sedit() to selectively sedit or cat depending
#       on if the sed pattern can be greped from the file; fixes
#       problem of adding new fields to an existing device file
#     - version 1.1
#
# 2003-10-28  charkins <charkins@pobox.com>
#     - stole sedit() function from sorcery's libmisc
#     - renamed save_device() to confirm_save() for clarity
#     - renamed real_save() to save_new() for clarity
#     - added save_update() to make in-place changes to a device file
#       using sedit, allowing network functions to be preserved in files
#     - confirm_save() confirms if the user wishes to save a device
#       file, if they answer yes, it calls either save_new() or 
#       save_update() to save the file depending on if the device
#       file exists
#     - made use of local in many functions and removed unset's where
#       no longer needed
#     - corrected spelling error in 2003-06-19 change entry :-)
#     - version 1.0
#
# 2003-10-26  charkins <charkins@pobox.com>
#     - shortened a couple strings to prevent them from being cut off
#     - added cfg_pointopoint()
#     - added cfg_mtu()
#     - added toggle_boot()
#     - updated loadnetdev() and cfg_device() to support POINTOPOINT,
#       MTU and UP_ON_BOOT options
#
# 2003-08-04  charkins <charkins@pobox.com>
#     - fixed a case bug in cfg_ns(): changed '*') to *)
# 
# 2003-07-28  charkins <charkins@pobox.com>
#     - cfg_hostname() dialog now has a cancel button
#     - cancelling changes to hostname or trying to set a blank
#       hostname will now leave /etc/hostname unchanged
# 
# 2003-07-17  charkins <charkins@pobox.com>
#     - minor reorganization of configuration variables
#
# 2003-06-20  charkins <charkins@pobox.com>
#     - added mangle_hosts() function to update the /etc/hosts file
#       when the hostname is changed, all entries for 127.0.0.1 are
#       removed and the localhost and hostname entries are then added
#       back in
#     - mangle_hosts() will also create the /etc/hosts file if it
#       does not exist including the comment section describing the
#       file
#     - renamed change_hostname() to cfg_hostname() to be more
#       consistent with other function names
#     - added option to configure DNS on main menu, the dns menu
#       is implemented in cfg_dns() which uses cfg_ns() to set an
#       individual nameserver, supports up to three nameservers
#       (as per the resolv.conf man page), search/domain/options
#       cannot be specified through netconf, though only nameserver
#       lines will be modified in /etc/resolv.conf
#     - version 0.9
#
# 2003-06-19  charkins <charkins@pobox.com>
#     - change_hostname now creates the hostname file automatically
#       with the hostname='sourcemage' if it doesn't exist, this
#       should gaurantee its existence whether the user likes it or
#       not :-)
#     - added some command line options for performing some basic
#       tasks, only one may be specified at a time and it will
#       exit immediately after the task is finished
#          --check_hostname: checks if the hostname file exists, 
#                            and prompts the user for a hostname if
#                            it doesn't exist
#          --check_devdir:   checks if the network device directory
#                            exists and prompts the user to create it
#                            if it doesn't exist
#          --check_lo:       checks if the loopback device exists
#                            and prompts the user to create it if
#                            it doesn't exist
#     - version 0.8
#
# 2003-06-19  charkins <charkins@pobox.com>
#     - changing hostname, ip, broadcast, netmask, gateway
#       or module will default to current value
#     - added option to change hostname from main menu
#     - pressing ESC or entering a blank hostname will now
#       use 'sourcemage' as the hostname
#     - added --aspect parameter (currently set to 25) to DIALOG
#       to improve the general appearance of some dialogs
#     - version 0.7
#
# 2003-06-19  charkins <charkins@pobox.com>
#     - added check_hostname and check_lo to check on startup
#       for existence of hostname file and loopback network device
#     - changed the 'su' call to not set any environment variables
#     - integrated ChangeLog into script for easier management
#     - version 0.6
# 
# 2002-11-05  charkins <charkins@pobox.com>
#     - corrected integer comparisons to use -eq instead of ==
#     - added special handling of loopback device in remove_device()
#       and getnetdevs()
#     - version 0.5
# 
# 2002-11-04  charkins <charkins@pobox.com>
#     - realized that 'true' returns an exit status (duh), removed
#       zeroreturn() in favor of 'true'
#     - added check_devdir() to check on startup for the existence 
#       and correct permissions of NETDEVDIR, will prompt user to 
#       create the directory if it does not exist
# 
# 2002-11-03  charkins <charkins@pobox.com>
#     - applied Neal's changes to save_device() to use cat instead
#       of echoing data into the device file
# 
# 2002-10-30  charkins <charkins@pobox.com>
#     - moved testing of GOTNETDEVS and GOTNETMODS flags into
#       their respective functions, getnetdevs() and getnetmods()
#       will return without performing any work if the flag
#       variable is non-null
#     - added GOTNETDEVS flag to prevent unnecessary calls
#       to getnetdevs()
#     - fixed more bugs related to new filenaming
#     - other small clean-ups
#     - version 0.4
# 
# 2002-10-28  charkins <charkins@pobox.com>
#     - fixed bug in getnetdevs() which used old filenaming scheme
#     - version 0.3
# 
# 2002-10-28  charkins <charkins@pobox.com>
#     - switched to <devicename>.dev filenaming scheme
#     - version 0.2
# 
# 2002-10-28  charkins <charkins@pobox.com>
#     - initial implementation
#     - version 0.1
#
# ----------------------- Configuration ----------------------------- #
# NETCONFVERSION: version number of this script
#      ROOTCHECK: if user is not root, then su and run script
#      NETDEVDIR: directory to store network device files
#     HOSTNAMEFN: name of file containing hostname
#        HOSTSFN: name of file containing hosts
#       RESOLVFN: name of file containing nameservers
#
NETCONFVERSION='1.3'
ROOTCHECK=1
NETDEVDIR=/etc/sysconfig/network
HOSTNAMEFN=/etc/hostname
HOSTSFN=/etc/hosts
RESOLVFN=/etc/resolv.conf

# -------------------------- Testing -------------------------------- #
# To test this script without running as root and without modifying
# the actual network settings for a system, uncomment the following
# block of variables. This will disable the root check and look in
# the current working directory for the various files.
# 
#ROOTCHECK=0
#NETDEVDIR=network
#HOSTNAMEFN=hostname
#HOSTSFN=hosts
#RESOLVFN=resolv.conf


# ----------------------- Other Globals ----------------------------- #
# DIALOG - dialog program used, could be taken from /etc/sorcery/config
DIALOG="dialog --aspect 25"

# button labels
BTN_ACCEPT='Accept'
BTN_SELECT='Select'
BTN_CANCEL='Cancel'
BTN_EXIT='Exit'
BTN_BACK='Back'

# BACKTITLE - shown at the top of the screen
BACKTITLE="SourceMage Network Configuration Tool - version ${NETCONFVERSION}"



# ------------------------- Functions ------------------------------- #
# getnetmods()
#
# Parses output of 'modprobe -l |grep net' and
# constructs two arrays of available network modules.
#
# POST-CONDITIONS:
# 	NETMODS     - array of network device files
# 	NETMODSMENU - array of "id" "network device file" pairs
#
getnetmods() {
	# only run once
	if [ -n "$GOTNETMODS" ]; then
		return 0;
	fi

	local id

	unset NETMODSMENU NETMODS
	id=0
	for i in `modprobe -l |grep net`; do
		i=${i##*/}
		modname=${i%.*}
		NETMODSMENU[$id]="${id} ${modname}"
		NETMODS[$id]="${modname}"
		id=$((id+1))
	done
	GOTNETMODS=1
}

# getnetdevs()
#
# Checks NETDEVDIR for network device files and
# constructs two arrays of these files.
#
# POST-CONDITIONS:
# 	NETDEVS     - array of network device files
# 	NETDEVSMENU - array of "id" "network device file" pairs
#
getnetdevs() {
	# only run if necessary (on start, add or remove)
	if [ -n "$GOTNETDEVS" ]; then
		return 0;
	fi

	# remove the unused lo.dev file if it exists
	if [ -e ${NETDEVDIR}/lo.dev ]; then
		rm -f ${NETDEVDIR}/lo.dev >> /dev/null
	fi

	local id

	unset NETDEVSMENU NETDEVS
	id=0
	for i in `ls $NETDEVDIR/*.dev`; do
		NETDEVSMENU[$id]="${id} `basename $i .dev`"
		NETDEVS[$id]="${i}"
		id=$((id+1))
	done
	GOTNETDEVS=1
}

# cfg_ns()
#
# Prompts the user for a name server ip address
#
# PARAMETERS: nameserver number to configure (1-3)
#
# POST-CONDITIONS:
#   Corresponding ns variable set to users input, or
#   left unchanged if the user cancelled.
cfg_ns() {
	if [ -z "$1" ]; then
		echo "Error: cfg_ns() called with no parameter"
		exit 1
	fi

	local ns
	case $1 in 
		'1') ns=$ns1 ;;
		'2') ns=$ns2 ;;
		'3') ns=$ns3 ;;
		  *) ns=""   ;;
	esac

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure Nameserver $1"                         \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the IP address of nameserver $1:"                  \
	                  0 0 $ns`

	if [ $? -eq 0 ]; then
		case $1 in 
			'1') ns1=$COMMAND ;;
			'2') ns2=$COMMAND ;;
			'3') ns3=$COMMAND ;;
		esac
	fi

}



# cfg_dns()
#
# Presents user with menu to configure dns settings.
#
#
cfg_dns() {

	if [ ! -f "$RESOLVFN" ]; then
		touch $RESOLVFN
	fi

	local ns1 ns2 ns3

	# find the current nameservers
	for i in `grep ^nameserver $RESOLVFN | sed 's/^nameserver //'`; do
		if [ -z $ns1 ]; then
			ns1=$i
		elif [ -z $ns2 ]; then
			ns2=$i
		elif [ -z $ns3 ]; then
			ns3=$i
		else
			break;
		fi
	done

	while [ true ]; do

		COMMAND=`$DIALOG --backtitle "$BACKTITLE"            \
		                 --stdout                            \
		                 --title "Configure DNS"             \
		                 --ok-label       "$BTN_SELECT"      \
		                 --cancel-label   "$BTN_CANCEL"      \
		                 --menu                              \
		                 "Choose a name server to modify:"   \
		                 0 0 0                               \
		                 "1" "$ns1"                          \
		                 "2" "$ns2"                          \
		                 "3" "$ns3"                          \
		                 "Save" "Save changes to $RESOLVFN and return to main menu"`

		if [ $? != 0 ]; then
			return 0
		fi

		case $COMMAND in
			'1') cfg_ns "1" ;;
			'2') cfg_ns "2" ;;
			'3') cfg_ns "3" ;;

			'Save')
				mv $RESOLVFN /tmp/resolv.conf.$$
				grep -v ^nameserver /tmp/resolv.conf.$$ > $RESOLVFN
				if [ ${#ns1} -gt 0 ]; then
					echo "nameserver $ns1" >> $RESOLVFN
				fi
				if [ ${#ns2} -gt 0 ]; then
					echo "nameserver $ns2" >> $RESOLVFN
				fi
				if [ ${#ns3} -gt 0 ]; then
					echo "nameserver $ns3" >> $RESOLVFN
				fi
				rm /tmp/resolv.conf.$$
				return 0
				;;
		esac

	done

}



# check_hostname()
#
# Calls cfg_hostname if no hostname is currently
# specified.
#
check_hostname() {

	# check if HOSTNAMEFN exists
	if [ ! -f "$HOSTNAMEFN" ]; then
		cfg_hostname
	fi

}

# cfg_hostname()
#
# Prompts the user for the hostname for this machine.
# It defaults to the current hostname, or 'sourcemage'
# if no hostname is currently specified.
#
# POST-CONDITIONS:
#   hostname is set in HOSTNAMEFN, if user cancels
#   or enters a blank hostname, 'sourcemage' will be
#   used.
cfg_hostname() {

	local curhostname

	# read in current hostname
	if [ -f "$HOSTNAMEFN" ]; then
		curhostname=`cat $HOSTNAMEFN`
	else
		echo "sourcemage" > $HOSTNAMEFN
		curhostname="sourcemage"
		mangle_hosts
	fi

	# prompt user to change hostname
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure Hostname"                              \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "What should this computer be called?"                    \
	                  0 0 $curhostname`

	# check if user accepted their changes
	if [ $? -eq 0 ] && [ ${#COMMAND} -gt 0 ]; then
		curhostname="$COMMAND"
		echo "$curhostname" > $HOSTNAMEFN
		mangle_hosts
	fi

}

# mangle_hosts()
#
# Mangles the /etc/hosts file to include entries
# for localhost and the specified hostname. First
# all 127.0.0.1 lines are removed, then two lines
# are added:
#    127.0.0.1       localhost
#    127.0.0.1       hostname
# 
mangle_hosts() {

	if [ ! -f "$HOSTSFN" ]; then
		cat > $HOSTSFN << EOF
#
# hosts         This file describes a number of hostname-to-address
#               mappings for the TCP/IP subsystem.  It is mostly
#               used at boot time, when no name servers are running.
#               On small systems, this file can be used instead of a
#               "named" name server.  Just add the names, addresses
#               and any aliases to this file...
#
EOF
	fi

	mv $HOSTSFN /tmp/hosts.$$
	grep -v ^127.0.0.1 /tmp/hosts.$$    >> $HOSTSFN
	echo "127.0.0.1       localhost"    >> $HOSTSFN
    echo "127.0.0.1       $curhostname" >> $HOSTSFN
	rm -f /tmp/hosts.$$
}

# check_devdir()
#
# Checks to see if NETDEVDIR exists, is a directory and
# is writeable. User will be prompted to create directory
# if it does not exist.
#
# POST-CONDITIONS:
#	NETDEVDIR exists, is a directory and is writeable
#
check_devdir() {

	# check if NETDEVDIR exists
	if [ ! -e $NETDEVDIR ]; then
		COMMAND=`$DIALOG --backtitle "$BACKTITLE"                              \
	                 --stdout                                                  \
	                 --title "Create Directory"                                \
	                 --yesno                                                   \
	                 "The network configuration directory (${NETDEVDIR}) does not exist, create it now?" \
	                 0 0`

		if [ $? != 0 ]; then
			echo "Error: Directory '${NETDEVDIR}' does not exist"
			exit 1
		fi

		mkdir -p $NETDEVDIR

		if [ $? != 0 ]; then
			echo "Error: Could not create directory '${NETDEVDIR}'"
			exit 1
		fi
		
		return 0
	fi

	# check if NETDEVDIR is a directory
	if [ ! -d $NETDEVDIR ]; then
		echo "Error: '${NETDEVDIR}' exists, but is not a directory"
		exit 1
	fi

	# check if NETDEVDIR is writable
	if [ ! -w $NETDEVDIR ]; then
		echo "Error: '${NETDEVDIR}' is not writeable"
		exit 1
	fi

}

# loadnetdev()
#
# Unsets network device variables then loads the
# network device file.
#
# PARAMETERS: absolute path to network device file
#
# POST-CONDITIONS:
#	MODULE      - kernel module to load, or blank for static driver
#	MODE        - 'dynamic' for dhcp, or 'static' for static
#	IP          - IP address
# 	BROADCAST   - broadcast address
#	NETMASK     - netmask
#	GATEWAY     - gateway address
#	POINTOPOINT - point to point address
#	MTU         - maximum transfer unit
#	UP_ON_BOOT  - bring up the network device on boot
#
loadnetdev() {
	if [ -z "$1" ]; then
		echo "Error: loadnetdev() called with no parameter"
		exit 1
	fi

	local devname

	unset MODULE MODE IP BROADCAST NETMASK GATEWAY POINTOPOINT MTU UP_ON_BOOT

	devname=`basename $1 .dev`

	if [ -e $1 ]; then
		# file exists, load it
		source $1
	else
		# new device, set defaults
		MODE='dynamic'
		POINTOPOINT=''
		MTU=''
		UP_ON_BOOT='yes'
	fi

}

# cfg_module_enter()
#
# Prompts user to enter the kernel module name (without the .o)
#
# POST-CONDITIONS:
#	MODULE - kernel module to load
#
cfg_module_enter() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MODULE"                                \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the name of the kernel module which your device uses, without the trailing .o" \
	                 0 0 $MODULE`

	if [ $? -eq 0 ]; then
		MODULE=$COMMAND
	fi
	return 0
}

# cfg_module_choose()
#
# Prompts user to select the kernel module from a list
# of available network drivers (uses modprobe -l | grep net)
#
# POST-CONDITIONS:
#	MODULE - kernel module to load
#
cfg_module_choose() {
	getnetmods

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MODULE"                                \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --menu                                                    \
	                 "Select the network module from the following list, or choose 'Enter' if the module is not shown." \
	                 0 0 0                                                     \
	                 ${NETMODSMENU[*]}                                         \
	                 "Enter"  "Enter a module name"`


	if [ $? != 0 ]; then
		return 0
	fi

	case $COMMAND in
		'Enter') cfg_module_enter              ;;
		*)       MODULE=${NETMODS[${COMMAND}]} ;;
	esac
	return 0
}

# cfg_module()
#
# Prompts user for MODULE setting. Three options are presented:
# 	1) Enter module name
#	2) Select from list (modprobe -l |grep net)
#	3) None (use static driver)
#
# POST-CONDITIONS:
#	MODULE - kernel module to load, or blank for static driver
#
cfg_module() {
	if [ -z "$MODULE" ]; then
		dmodule="None (use static driver)"
	else
		dmodule=$MODULE
	fi

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MODULE"                                \
	                 --ok-label       "$BTN_SELECT"                            \
	                 --cancel-label   "$BTN_BACK"                              \
	                 --menu                                                    \
	                 "Choose how to select the kernel module, select 'None' if the driver is compiled into the kernel, or select '$BTN_BACK' to keep the current setting (${dmodule})" \
	                 0 0 0                                                     \
	                 "Enter"  "Enter a module name"                            \
	                 "Choose" "Choose from a list of available network modules"\
	                 "None"   "Use a static driver"`                           

	if [ $? != 0 ]; then
		return 0
	fi

	case $COMMAND in
		'Enter')  cfg_module_enter  ;;
		'Choose') cfg_module_choose ;;
		'None')   MODULE=''         ;;
	esac
	return 0
}

# cfg_mode()
#
# Prompts user for MODE setting. Two options are presented:
#	1) dynamic (use dhcp)
#	2) static
#
# POST-CONDITIONS:
#	MODE       - 'dynamic' for dhcp, or 'static' for static
#
cfg_mode() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MODE"                                  \
	                 --ok-label       "$BTN_SELECT"                            \
	                 --cancel-label   "$BTN_BACK"                              \
	                 --menu                                                    \
	                 "Choose which mode this network device uses.              \
                      Select 'dynamic' to use dhcp, select 'static'            \
                      to specify IP, BROADCAST, NETMASK, GATEWAY, or           \
                      select '${BTN_BACK}' to keep current setting             \
                     (${MODE})"                                                \
	                 0 0 0                                                     \
	                 "dynamic" "use dhcp"                                      \
	                 "static" "specify network settings"`

	if [ $? != 0 ]; then
		return 0
	fi

	case $COMMAND in
		'dynamic') MODE='dynamic'   ;;
		'static')  MODE='static'    ;;
	esac


	return 0
}

# cfg_ip()
#
# Prompts user to enter the ip address.
#
# POST-CONDITIONS:
#	IP         - IP address
#
cfg_ip() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure IP address"                            \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the IP address for this network device"            \
	                 0 0 $IP`

	if [ $? -eq 0 ]; then
		IP=$COMMAND
	fi
	return 0
}


# cfg_broadcast()
#
# Prompts user to enter the broadcast address.
#
# POST-CONDITIONS:
# 	BROADCAST  - broadcast address
#
cfg_broadcast() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure BROADCAST address"                     \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the broadcast address for this network device"     \
	                 0 0 $BROADCAST`

	if [ $? -eq 0 ]; then
		BROADCAST=$COMMAND
	fi
	return 0
}


# cfg_netmask()
#
# Prompts user to enter the netmask.
#
# POST-CONDITIONS:
#	NETMASK    - netmask
#
cfg_netmask() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure NETMASK"                               \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the netmask for this network device"               \
	                 0 0 $NETMASK`

	if [ $? -eq 0 ]; then
		NETMASK=$COMMAND
	fi
	return 0
}


# cfg_gateway()
#
# Prompts user to enter the gateway address.
#
# POST-CONDITIONS:
#	GATEWAY    - gateway address
#
cfg_gateway() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure GATEWAY address"                       \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the gateway address for this network device"       \
	                 0 0 $GATEWAY`

	if [ $? -eq 0 ]; then
		GATEWAY=$COMMAND
	fi
	return 0
}

# cfg_pointopoint()
#
# Prompts user to enter the point to point address.
#
# POST-CONDITIONS:
#	POINTOPOINT - point to point address
#
cfg_pointopoint() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure POINTOPOINT address"                   \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the point to point address for this network device"\
	                 0 0 $POINTOPOINT`

	if [ $? -eq 0 ]; then
		POINTOPOINT=$COMMAND
	fi
	return 0
}

# cfg_mtu()
#
# Prompts user to enter the maximum transfer unit.
#
# POST-CONDITIONS:
#	MTU        - maximum transfer unit
#
cfg_mtu() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Configure MTU"                                   \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the maximum transfer unit for this network device" \
	                 0 0 $MTU`

	if [ $? -eq 0 ]; then
		MTU=$COMMAND
	fi
	return 0
}

# toggle_boot()
#
# Toggles UP_ON_BOOT state
#
# POST-CONDITIONS:
#	UP_ON_BOOT       - opposite of previous UP_ON_BOOT value
#
toggle_boot() {
	if [ $UP_ON_BOOT = "no" ]; then
		UP_ON_BOOT="yes"
	else
		UP_ON_BOOT="no"
	fi

	return 0
}

# remove_device()
#
# Prompts user to confirm removing the device file.
#
# PARAMETERS: absolute path to network device file
#
remove_device() {
	if [ -z "$1" ]; then
		echo "Error: remove_device() called with no parameter"
		exit 1
	fi

	local devname

	devname=`basename $1 .dev`

	# confirm removal of network device
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                              \
	                 --stdout                                              \
	                 --title "Confirm device removal"                      \
	                 --yesno                                               \
	                 "Are you sure you want to remove device file: ${devname}?" \
	                 0 0`

	if [ $? -eq 0 ]; then
		rm -f $1

		# cause getnetdevs() to run to remove device from main menu
		unset GOTNETDEVS devname
		
		return 1 # return 1 to return back to main menu
	fi

	return 0
}

# confirm_save()
#
# Prompts user to confirm saving the device file.
#
# PARAMETERS: absolute path to network device file
#
confirm_save() {
	if [ -z "$1" ]; then
		echo "Error: confirm_save() called with no parameter"
		exit 1
	fi

	local devname
	devname=$(basename $1)

	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Confirm device saving"                           \
	                 --yesno                                                   \
	                 "Are you sure you want to save device file: ${devname}?"  \
	                 0 0`

	if [ $? -eq 0 ]; then
		if [ -e $1 ]; then
			save_update $1
		else
			save_new $1
		fi
		return 1 # return 1 to return back to main menu
	fi
	
	return 0
}

# save_new()
#
# Saves a new network device file.
# 
# PARAMETERS: absolute path to network device file
#
# POST-CONDITIONS:
#	device file is saved
#
save_new() {
	if [ -z "$1" ]; then
		echo "Error: save_new() called with no parameter"
		exit 1
	fi

	local now
	now=`date`
	cat > $1 << EOF
# $devname configuration
# created by: ${BACKTITLE}
# created on: $now
# last modified: $now
MODULE=${MODULE}
MODE=${MODE}
IP=${IP}
BROADCAST=${BROADCAST}
NETMASK=${NETMASK}
GATEWAY=${GATEWAY}
POINTOPOINT=${POINTOPOINT}
MTU=${MTU}
UP_ON_BOOT=${UP_ON_BOOT}
EOF

}

# save_update()
#
# Updates an existing network device file.
# 
# PARAMETERS: absolute path to network device file
#
# POST-CONDITIONS:
#	device file is saved
#
save_update() {
	if [ -z "$1" ]; then
		echo "Error: save_update() called with no parameter"
		exit 1
	fi

	if [ ! -e $1 ]; then
		echo "Error: save_update() device file does not exist: $1"
		exit 1
	fi

	cat_or_sedit "^# created by:.*" "# created by: ${BACKTITLE}" $1
	cat_or_sedit "^# last modified:.*" "# last modified: `date`" $1
	cat_or_sedit "^MODULE=.*" "MODULE=${MODULE}" $1
	cat_or_sedit "^MODE=.*" "MODE=${MODE}" $1
	cat_or_sedit "^IP=.*" "IP=${IP}" $1
	cat_or_sedit "^BROADCAST=.*" "BROADCAST=${BROADCAST}" $1
	cat_or_sedit "^NETMASK=.*" "NETMASK=${NETMASK}" $1
	cat_or_sedit "^GATEWAY=.*" "GATEWAY=${GATEWAY}" $1
	cat_or_sedit "^POINTOPOINT=.*" "POINTOPOINT=${POINTOPOINT}" $1
	cat_or_sedit "^MTU=.*" "MTU=${MTU}" $1
	cat_or_sedit "^UP_ON_BOOT=.*" "UP_ON_BOOT=${UP_ON_BOOT}" $1


	#sedit "s/^# created by:.*/# created by: ${BACKTITLE}/" $1
	#sedit "s/^# last modified:.*/# last modified: `date`/" $1
	#sedit "s/^MODULE=.*/MODULE=${MODULE}/" $1
	#sedit "s/^MODE=.*/MODE=${MODE}/" $1
	#sedit "s/^IP=.*/IP=${IP}/" $1
	#sedit "s/^BROADCAST=.*/BROADCAST=${BROADCAST}/" $1
	#sedit "s/^NETMASK=.*/NETMASK=${NETMASK}/" $1
	#sedit "s/^GATEWAY=.*/GATEWAY=${GATEWAY}/" $1
	#sedit "s/^POINTOPOINT=.*/POINTOPOINT=${POINTOPOINT}/" $1
	#sedit "s/^MTU=.*/MTU=${MTU}/" $1
	#sedit "s/^UP_ON_BOOT=.*/UP_ON_BOOT=${UP_ON_BOOT}/" $1

}

# cat_or_sedit()
#
# A hack to either sedit an existing line, or add a new
# line if one doesn't exist.
#
# PARAMETERS: <pattern> <line> <filename>
#
# POST-CONDITIONS:
#   <line> is in <filename>
#
cat_or_sedit() {
	if ( cat $3 | grep -q "$1" ); then
		sedit "s/${1}/${2}/" ${3}
	else
		echo "$2" >> ${3}
	fi
}



# sedit
# 
# sedit function stolen from sorcery to perform sed commands
# "in-place" on a file. Modified slightly to restore the file
# if sed command fails.
#
# PARAMETERS: sed command
#             filename
#
# source: /var/lib/sorcery/modules/libmisc::real_sedit()
sedit()  {
	(
		# Execute in a subshell to avoid globally affecting the umask
		umask 077
		TMP_FILE="/tmp/`basename  $2`.$$.$RANDOM"      &&
		rm    -rf    $TMP_FILE                         &&
		cp    $2     $TMP_FILE                         &&
                ( sed "$1" $TMP_FILE > $2 || cp $TMP_FILE $2 ) &&
		rm -rf $TMP_FILE
	)
}


# add_device()
#
# Prompts user for device name and passes control
# to cfg_device.
#
add_device() {
	COMMAND=`$DIALOG --backtitle "$BACKTITLE"                                  \
	                 --stdout                                                  \
	                 --title "Add new network device"                          \
	                 --ok-label       "$BTN_ACCEPT"                            \
	                 --cancel-label   "$BTN_CANCEL"                            \
	                 --inputbox                                                \
	                 "Enter the name for this device (e.g. eth0, plip1)"       \
	                 0 0`

	if [ $? != 0 ]; then
		return 0
	fi

	if [ -z "$COMMAND" ]; then
		return 0
	fi

	cfg_device "${NETDEVDIR}/${COMMAND}.dev"

	# cause getnetdevs() to run to pick up new device
	unset GOTNETDEVS

	return 0
}

# cfg_device()
#
# Presents user with menu to configure network options as
# well as options to remove or save the configuration.
#
# PARAMETERS: absolute path to network device file
#
# POST-CONDITIONS:
#	device file is saved
#
cfg_device() {
	if [ -z "$1" ]; then
		echo "Error: cfg_device() called with no parameter"
		exit 1
	fi

	# load the network device file
	loadnetdev "$1"

	local dmodule dmtu dpointopoint

	true
	while [ $? -eq 0 ]; do

		if [ -z "$MODULE" ]; then
			dmodule="Use static driver"
		else
			dmodule=$MODULE
		fi

		if [ -z "$MTU" ]; then
			dmtu="Use default MTU"
		else
			dmtu=$MTU
		fi

		if [ -z "$POINTOPOINT" ]; then
			dpointopoint="None"
		else
			dpointopoint=$POINTOPOINT
		fi

		if [ `echo $MODE` = 'dynamic' ]; then
			COMMAND=`$DIALOG --backtitle "$BACKTITLE"                          \
			                 --stdout                                          \
		                     --title "Modify, Remove Network Device"               \
			                 --ok-label       "$BTN_SELECT"                    \
			                 --cancel-label   "$BTN_BACK"                      \
			                 --menu                                            \
			                 "Choose a setting to modify, or select Remove to remove the device" \
			                 0 0 0                                             \
			                 "MODULE" "${dmodule}"                             \
			                 "MODE" "dynamic (use dhcp)"                       \
			                 "POINTOPOINT" "${dpointopoint}"                   \
			                 "MTU"  "${dmtu}"                                  \
			                 "UP_ON_BOOT" "${UP_ON_BOOT}"                      \
			                 "Remove" "Remove this network device"             \
			                 "Save" "Save this device file"`
		else
			COMMAND=`$DIALOG --backtitle "$BACKTITLE"                          \
			                 --stdout                                          \
		                     --title "Modify, Remove Network Device"           \
			                 --ok-label       "$BTN_SELECT"                    \
			                 --cancel-label   "$BTN_BACK"                      \
			                 --menu                                            \
			                 "Choose a setting to modify, or select Remove to remove the device" \
			                 0 0 0                                             \
			                 "MODULE" "${dmodule}"                             \
			                 "MODE" "static"                                   \
			                 "IP" "${IP}"                                      \
			                 "BROADCAST" "${BROADCAST}"                        \
			                 "NETMASK" "${NETMASK}"                            \
			                 "GATEWAY" "${GATEWAY}"                            \
			                 "POINTOPOINT" "${dpointopoint}"                   \
			                 "MTU"  "${dmtu}"                                  \
			                 "UP_ON_BOOT" "${UP_ON_BOOT}"                      \
			                 "Remove" "Remove this network device"             \
			                 "Save" "Save this device file"`
		fi


		if [ $? != 0 ]; then
			return 0
		fi

		case $COMMAND in
			'MODULE')      cfg_module          ;;
			'MODE')        cfg_mode            ;;
			'IP')          cfg_ip              ;;
			'BROADCAST')   cfg_broadcast       ;;
			'GATEWAY')     cfg_gateway         ;;
			'NETMASK')     cfg_netmask         ;;
			'POINTOPOINT') cfg_pointopoint     ;;
			'MTU')         cfg_mtu             ;;
			'UP_ON_BOOT')  toggle_boot         ;;
			'Remove')      remove_device "$1"  ;;
			'Save')        confirm_save "$1"   ;;
		esac

	done

	return 0
}

# parse_args()
#
# ARGUMENTS:
#
#	--check_hostname : calls check_hostname
#	--check_devdir   : calls check_devdir
#
parse_args() {

	if [ $# -lt 1 ]; then
		return;
	fi

	if [ $# -gt 1 ]; then
		echo "Error: too many arguments"
		exit 1;
	fi

	case $1 in
		'--check_hostname')	check_hostname
		                    exit 0            ;;
		'--check_devdir')   check_devdir
		                    exit 0            ;;
		*) echo "Error: Invalid argument: $1"
		   exit 1                             ;;
	esac

}

# main()
#
# The netconf main menu.
#
main() {

	parse_args $*
	check_hostname
	check_devdir

	local curhostname
	unset GOTNETMODS GOTNETDEVS

	true
	while [ $? -eq 0 ]; do

		getnetdevs

		curhostname=`cat $HOSTNAMEFN`

		COMMAND=`$DIALOG --backtitle "$BACKTITLE"                               \
		                 --stdout                                               \
		                 --title "Add, Modify, Remove Netowrk Devices"          \
		                 --ok-label       "$BTN_SELECT"                         \
		                 --cancel-label   "$BTN_EXIT"                           \
		                 --menu                                                 \
		                 "Choose a device to modify or remove, or select Add to add a new device. Change will allow you to change the hostname of this computer." \
		                 0 0 0                                                  \
		                 ${NETDEVSMENU[*]}                                      \
		                 "Add" "Add new network device"                         \
		                 "Hostname" "Change hostname (currently: $curhostname)" \
		                 "DNS" "Configure DNS servers"`

		if [ $? != 0 ]; then
			# Exit
			exit 0
		fi

		case $COMMAND in
			'Add')      add_device                        ;;
			'Hostname') cfg_hostname                      ;;
			'DNS')      cfg_dns                           ;;
			*)          cfg_device "${NETDEVS[$COMMAND]}" ;;
		esac

	done
}


# ------------------------- Entry Point ----------------------------- #
if [ "$ROOTCHECK" -eq 1 ]; then
	if [ "$UID" != 0 ]; then
		echo "Enter the root password, please."
		su  -c "$0 $*"
		exit
	fi
fi

main $*
